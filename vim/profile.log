SCRIPT  /home/user/fbarotjr/.vimrc
Sourced 1 time
Total time:   0.553627
 Self time:   0.032128

count  total (s)   self (s)
                            so $HOME/dotfiles/vim/.vimrc
                            
                            " run perl script
    1              0.000010 noremap <leader>t :!clear<cr>:!perl %<cr>
                            
                            " perforce submission
    1              0.000005 nnoremap <leader>c 25GC
    1              0.000011 nnoremap <leader>e :!p4 open %<cr>

SCRIPT  /home/user/fbarotjr/dotfiles/vim/.vimrc
Sourced 1 time
Total time:   0.521480
 Self time:   0.135635

count  total (s)   self (s)
                            if (has("termguicolors"))
    1              0.000064     set termguicolors
    1              0.000002 endif
                            
    1              0.027036 syntax on
                            
    1              0.015835 filetype plugin on
    1              0.004768 filetype indent on
                            
    1              0.015528 call plug#begin()
                            
    1              0.000185 Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }
    1              0.000115 Plug 'vim-perl/vim-perl'
    1              0.000112 Plug 'jiangmiao/auto-pairs'
    1              0.000113 Plug 'jessedhillon/vim-easycomment'
    1              0.000112 Plug 'junegunn/vim-easy-align'
    1              0.000123 Plug 'gioele/vim-autoswap'
    1              0.000118 Plug 'tpope/vim-surround'
    1              0.000112 Plug 'morhetz/gruvbox'
    1              0.000112 Plug 'ajh17/VimCompletesMe'
    1              0.000113 Plug 'chrisbra/vim-diff-enhanced'
    1              0.000113 Plug 'itchyny/lightline.vim'
    1              0.000172 Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all'  }
                            "Plug 'blueyed/vim-diminactive'
                            
    1   0.140084   0.000013 call plug#end()
                            
    1              0.001085 set background=dark
    1              0.034470 color gruvbox
    1              0.000005 let g:gruvbox_bold = 0
                            
    1              0.000006 set fillchars=""
                            
    1              0.000004 set ttyfast                     " for fast terminal connections
                            
    1              0.000005 set history=1000                " sets how many lines of history VIM has to remember
                            
    1              0.000003 set autoread                    " set to auto read when a file is changed from the outside
                            
    1              0.000003 let mapleader = ","             " map comma as leader
    1              0.000001 let g:mapleader = ","
                            
    1              0.000002 set number                      " show line number
    1              0.000003 set cursorline                  " highlight current line
    1              0.000005 set so=7                        " set 7 lines to the cursor - when moving vertically using j/k
    1              0.000001 set wildmenu                    " command completion
                            
    1              0.000002 set wildignore=*.o,*~,*.pyc     " ignored stuff on command autocomplete
    1              0.000002 set ruler                       " always show current position
    1              0.000001 set cmdheight=1                 " height of the command bar
                            
    1              0.000003 set backspace=eol,start,indent  " configure backspace so it acts as it should act
    1              0.000003 set whichwrap+=<,>,h,l,[,]      " movement keys wrap
                            
    1              0.000002 set ignorecase                  " ignore case when searching
    1              0.000002 set smartcase                   " search string has upper case makes search case-sensitive
    1              0.000001 set incsearch                   " incremental search
    1              0.000002 set magic                       " allows regex matching with special characters
                            
    1              0.000002 set lazyredraw                  " don't redraw while executing macros
                            
    1              0.000002 set showmatch                   " show matching brackets when text indicator is over them
    1              0.000004 set mat=2                       " how many tenths of a second to blink when matching brackets
                            
    1              0.000001 set noerrorbells                " no annoying sound on errors
    1              0.000002 set novisualbell                " no annoying flash on errors
                            
    1              0.015732 syntax enable                   " enable syntax highlighting
    1              0.000050 set encoding=utf8               " set utf8 as standard encoding and en_US as the standard language
    1              0.000011 set ffs=unix,dos,mac            " for fuck's sake, use Unix as the standard file type
                            
    1              0.000003 set expandtab                   " use spaces instead of tabs
    1              0.000003 set smarttab                    " be smart when using tabs
    1              0.000005 set shiftwidth=4                " 1 tab == 4 spaces
    1              0.000002 set tabstop=4                   " how long tab is
                            
    1              0.000007 set ai                          " auto indent
    1              0.000004 set si                          " smart indent
    1              0.000002 set nowrap                      " don't wrap lines
                            
    1              0.000002 set showcmd                     " show commands the user enters
    1              0.000012 set laststatus=2                " always show the status line
    1              0.000005 set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{getcwd()}%h\ \ \ Line:\ %l
                            
    1              0.000001 set nohlsearch                  " turn off highlighting
                            
    1              0.000002 set noshowmode                  " already taken care of by vim-airline
                            
                            " F1 is evil
    1              0.000013 nnoremap <F1> <Esc>
    1              0.000004 inoremap <F1> <Esc>
    1              0.000003 vnoremap <F1> <Esc>
                            
                            " treat long lines as break lines (useful when moving around in them)
    1              0.000004 map j gj
    1              0.000004 map k gk
                            "
                            " don't get fucked by Shift
    1              0.000012 command! -complete=file -bang -nargs=? W  :w<bang> <args>
    1              0.000007 command! -complete=file -bang -nargs=? Wq :wq<bang> <args>
    1              0.000004 command! -complete=file -bang Q :q<bang>
    1              0.000006 command! -complete=file -bang Qa :qa<bang>
                            
                            " disable arrow keys
    1              0.000006 noremap <up> :echo "use k"<cr>
    1              0.000005 noremap <down> :echo "use j"<cr>
    1              0.000005 noremap <left> :echo "use h"<cr>
    1              0.000004 noremap <right> :echo "use l"<cr>
                            
                            " disable paste mode when exiting Insert mode
    1              0.000002 augroup disablePasteModeWhenExitingInsertMode
    1              0.000184   autocmd!
    1              0.000007   au InsertLeave * set nopaste
    1              0.000002 augroup END
                            
                            " window management
    1              0.000004 nnoremap s <C-W>
    1              0.000002 augroup windowManagementShortcut
    1              0.000038     autocmd!
    1              0.000013     autocmd filetype netrw nnoremap <buffer> s <C-W>
    1              0.000002 augroup END
                            
    1              0.000008 map m :call ToggleMouse()<CR>
    1              0.000003 function! ToggleMouse()
                              if &mouse == 'a'
                                set mouse=
                                echo "Mouse usage disabled"
                              else
                                set mouse=a
                                echo "Mouse usage enabled"
                              endif
                            endfunction
                            
                            " return the cursor to its previous location on load
    1              0.000001 augroup bufRead
    1              0.000040   autocmd!
    1              0.000016   autocmd BufReadPost * normal `"
    1              0.000002 augroup END
                            
                            """"""""""""""""""""""""""""""""""""""""""""
                            " Key bindings
                            """"""""""""""""""""""""""""""""""""""""""""
                            " <Esc> alternatives
    1              0.000005 inoremap jj <Esc>:update<CR>
    1              0.000004 inoremap jk <Esc>:update<CR>
                            
                            " toggle pastemode
    1              0.000004 set pastetoggle=<F5>
                            
    1              0.000004 function! s:buflist()
                              redir => ls
                              silent ls
                              redir END
                              return split(ls, '\n')
                            endfunction
                            
    1              0.000002 function! s:bufopen(e)
                              execute 'buffer' matchstr(a:e, '^[ 0-9]*')
                            endfunction
                            
    1              0.000023 nnoremap <silent> <TAB> :call fzf#run({
                            \   'source':  reverse(<sid>buflist()),
                            \   'sink':    function('<sid>bufopen'),
                            \   'options': '+m',
                            \   'down':    len(<sid>buflist()) + 2
                            \ })<CR>
                            
                            " map <Space> to / (search) and ctrl+<Space> to ? (backwards search)
    1              0.000005 map <space> :set hlsearch<CR>/
    1              0.000003 map <c-@> ?
                            
                            " toggle highlighting
    1              0.000008 noremap <leader><space> :set hlsearch! hlsearch?<CR>
                            
                            " remove trailing whitespaces
    1              0.000006 noremap <leader><c-@> :%s/\s\+$<CR>
                            
    1              0.000006 nnoremap <leader>, :update<CR>
                            
                            " quickly edit and reload vimrc
    1              0.000006 nnoremap <leader>ev :split $MYVIMRC<CR>
    1              0.000007 nnoremap <leader>sv :source $MYVIMRC<CR>
                            
                            " Enter mapped to : in normal mode
    1              0.000003 nnoremap <Enter> :
                            
                            " reselect visual block after indent/outdent
    1              0.000003 vnoremap < <gv
    1              0.000003 vnoremap > >gv
                            
                            " tab navigation
    1              0.000004 nnoremap J :tabprev<CR>
    1              0.000004 nnoremap K :tabnext<CR>
    1              0.000004 nnoremap <C-t> :tabnew<CR>
    1              0.000004 inoremap <C-t> <Esc>:tabnew<CR>
                            
                            " Enter mapped to EasyAlign in visual mode
    1              0.000007 vnoremap <Enter> :EasyAlign
                            
                            " keep search pattern at the center of the screen
    1              0.000006 nnoremap <silent> n nzz
    1              0.000004 nnoremap <silent> N Nzz
    1              0.000003 nnoremap <silent> * *zz
    1              0.000003 nnoremap <silent> # #zz
    1              0.000004 nnoremap <silent> g* g*zz
    1              0.000003 nnoremap <silent> g# g#zz
                            
                            " toggle line wrapping
    1              0.000007 noremap <leader>w :set wrap!<cr>
    1              0.000006 noremap <leader>n :set number!<cr>
                            
                            """"""""""""""""""""""""""""""""""""""""""""
                            " Plugins
                            """"""""""""""""""""""""""""""""""""""""""""
                            " nerdtree
    1              0.000006 map <Leader>d :NERDTreeToggle<CR>
                            
                            "fzf
    1              0.000004 noremap <c-p> :FZF ~<cr>
                            
    1              0.000008 vmap <silent> <C-_> :call ToggleCommentVisual()<CR>
    1              0.000006 nmap <silent> <C-_> :call ToggleCommentLine()<CR>
    1              0.000007 imap <silent> <C-_> <Esc>:call ToggleCommentLine()
                            
    1              0.000001 augroup easyCommentPluginConfig
    1              0.000040   autocmd!
    1              0.000007   au FileType perl let b:comment_style="inline"
    1              0.000003   au FileType perl let b:comment_opener="# "
    1              0.000004   au FileType conf let b:comment_style="inline"
    1              0.000004   au FileType conf let b:comment_opener="# "
    1              0.000008   au FileType bash,sh let b:comment_style="inline"
    1              0.000009   au FileType bash,sh let b:comment_opener="# "
    1              0.000007   au FileType cpp let b:comment_style="block"
    1              0.000003   au FileType cpp let b:comment_opener='/*'
    1              0.000003   au FileType cpp let b:comment_closer='*/'
    1              0.000001 augroup END
                            
                            " autoswap config
    1              0.000004 let g:autoswap_detect_tmux = 1
                            
                            " auto-pairs
    1              0.000002 let g:AutoPairsCenterLine = 0
                            
                            """"""""""""""""""""""""""""""""""""""""""""
                            " Functions
                            """"""""""""""""""""""""""""""""""""""""""""
                            
                            " returns true if paste mode is enabled
    1              0.000003 function! HasPaste()
                                if &paste
                                    return 'PASTE MODE  '
                                en
                                return ''
                            endfunction
                            
                            " started In Diff-Mode set diffexpr (plugin not loaded yet)
    1              0.000002 if &diff
                                let &diffexpr='EnhancedDiff#Diff("git diff", "--diff-algorithm=patience")'
                            endif
                            
    1              0.000013 let g:lightline = {
                                \ 'colorscheme': 'gruvbox',
                                \ 'component': {
                                \   'lineinfo': ' %3l:%-2v',
                                \ },
                                \ 'component_function': {
                                \   'readonly': 'LightlineReadonly',
                                \ },
                                \ 'separator': { 'left': '', 'right': '' },
                                \ 'subseparator': { 'left': '', 'right': '' }
                                \ }
    1              0.000002 function! LightlineReadonly()
                                return &readonly ? '' : ''
                            endfunction
                            
    1              0.000006 set swapfile
    1              0.000005 set backupdir=~/.vim/backup//   " custom location for vim safety net
    1              0.000002 set directory=~/.vim/swap//
    1              0.000002 set undodir=~/.vim/undo//
                            

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/syntax/syntax.vim
Sourced 2 times
Total time:   0.217444
 Self time:   0.092845

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 04
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    2              0.000046 if !has("syntax")
                              finish
                            endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    2              0.000014 if exists("syntax_on") || exists("syntax_manual")
    1              0.037144   so <sfile>:p:h/nosyntax.vim
    1              0.000003 endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    2              0.038521 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    2              0.000011 if exists("did_load_filetypes")
    1              0.000003   let s:did_ft = 1
    1              0.000001 else
    1              0.016831   filetype on
    1              0.000005   let s:did_ft = 0
    1              0.000001 endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected.
    2              0.000004 augroup syntaxset
    2              0.000012   au! FileType *	exe "set syntax=" . expand("<amatch>")
    2              0.000002 augroup END
                            
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    2              0.000004 doautoall syntaxset FileType
    2              0.000003 if !s:did_ft
    1              0.000001   doautoall filetypedetect BufRead
    1              0.000001 endif

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/syntax/synload.vim
Sourced 2 times
Total time:   0.100241
 Self time:   0.054294

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2016 Nov 04
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    2              0.000034 if !has("syntax")
                              finish
                            endif
                            
                            " let others know that syntax has been switched on
    2              0.000015 let syntax_on = 1
                            
                            " Set the default highlighting colors.  Use a color scheme if specified.
    2              0.000008 if exists("colors_name")
    1              0.000304   exe "colors " . colors_name
    1              0.000003 else
    1              0.053457   runtime! syntax/syncolor.vim
    1              0.000004 endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    2              0.000046 let s:cpo_save = &cpo
    2              0.000033 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    2              0.000019 au! Syntax
                            
    2              0.000032 au Syntax *		call s:SynSet()
                            
    2              0.000011 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
                                for name in split(s, '\.')
                                  exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
    2              0.000048 au Syntax c,cpp,cs,idl,java,php,datascript
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    2              0.000016 if exists("mysyntaxfile")
                              let s:fname = expand(mysyntaxfile)
                              if filereadable(s:fname)
                                execute "source " . fnameescape(s:fname)
                              endif
                            endif
                            
                            " Restore 'cpoptions'
    2              0.000021 let &cpo = s:cpo_save
    2              0.000012 unlet s:cpo_save

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/syntax/syncolor.vim
Sourced 6 times
Total time:   0.035235
 Self time:   0.035235

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 12
                            
                            " This file sets up the default methods for highlighting.
                            " It is loaded from "synload.vim" and from Vim for ":syntax reset".
                            " Also used from init_highlight().
                            
    6              0.000074 if !exists("syntax_cmd") || syntax_cmd == "on"
                              " ":syntax on" works like in Vim 5.7: set colors but keep links
    3              0.000041   command -nargs=* SynColor hi <args>
    3              0.000015   command -nargs=* SynLink hi link <args>
    3              0.000005 else
    3              0.000006   if syntax_cmd == "enable"
                                " ":syntax enable" keeps any existing colors
    1              0.000016     command -nargs=* SynColor hi def <args>
    1              0.000008     command -nargs=* SynLink hi def link <args>
    1              0.000002   elseif syntax_cmd == "reset"
                                " ":syntax reset" resets all colors to the default
    2              0.000016     command -nargs=* SynColor hi <args>
    2              0.000010     command -nargs=* SynLink hi! link <args>
    2              0.000002   else
                                " User defined syncolor file has already set the colors.
                                finish
                              endif
    3              0.000003 endif
                            
                            " Many terminals can only use six different colors (plus black and white).
                            " Therefore the number of colors used is kept low. It doesn't look nice with
                            " too many colors anyway.
                            " Careful with "cterm=bold", it changes the color to bright for some terminals.
                            " There are two sets of defaults: for a dark and a light background.
    6              0.000018 if &background == "dark"
    5              0.000070   SynColor Comment	term=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
    5              0.000035   SynColor Constant	term=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
    5              0.000044   SynColor Special	term=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
    5              0.000030   SynColor Identifier	term=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
    5              0.000036   SynColor Statement	term=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
    5              0.000033   SynColor PreProc	term=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
    5              0.000035   SynColor Type		term=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
    5              0.000038   SynColor Underlined	term=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
    5              0.000034   SynColor Ignore	term=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
    5              0.000005 else
    1              0.000017   SynColor Comment	term=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
    1              0.000008   SynColor Constant	term=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
    1              0.033547   SynColor Special	term=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
    1              0.000033   SynColor Identifier	term=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
    1              0.000011   SynColor Statement	term=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
    1              0.000016   SynColor PreProc	term=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
    1              0.000011   SynColor Type		term=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
    1              0.000010   SynColor Underlined	term=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
    1              0.000010   SynColor Ignore	term=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
    1              0.000002 endif
    6              0.000057 SynColor Error		term=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
    6              0.000057 SynColor Todo		term=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
                            
                            " Common groups that link to default highlighting.
                            " You can specify other highlighting easily.
    6              0.000031 SynLink String		Constant
    6              0.000026 SynLink Character	Constant
    6              0.000025 SynLink Number		Constant
    6              0.000025 SynLink Boolean		Constant
    6              0.000025 SynLink Float		Number
    6              0.000026 SynLink Function	Identifier
    6              0.000026 SynLink Conditional	Statement
    6              0.000025 SynLink Repeat		Statement
    6              0.000037 SynLink Label		Statement
    6              0.000027 SynLink Operator	Statement
    6              0.000025 SynLink Keyword		Statement
    6              0.000026 SynLink Exception	Statement
    6              0.000026 SynLink Include		PreProc
    6              0.000031 SynLink Define		PreProc
    6              0.000029 SynLink Macro		PreProc
    6              0.000027 SynLink PreCondit	PreProc
    6              0.000026 SynLink StorageClass	Type
    6              0.000026 SynLink Structure	Type
    6              0.000025 SynLink Typedef		Type
    6              0.000029 SynLink Tag		Special
    6              0.000026 SynLink SpecialChar	Special
    6              0.000025 SynLink Delimiter	Special
    6              0.000027 SynLink SpecialComment	Special
    6              0.000025 SynLink Debug		Special
                            
    6              0.000011 delcommand SynColor
    6              0.000017 delcommand SynLink

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/filetype.vim
Sourced 4 times
Total time:   0.081583
 Self time:   0.081122

count  total (s)   self (s)
                            " Vim support file to detect file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2017 Jun 22
                            
                            " Listen very carefully, I will say this only once
    4              0.000053 if exists("did_load_filetypes")
    2              0.000007   finish
                            endif
    2              0.000010 let did_load_filetypes = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    2              0.000034 let s:cpo_save = &cpo
    2              0.000024 set cpo&vim
                            
    2              0.000008 augroup filetypedetect
                            
                            " Ignored extensions
    2              0.000011 if exists("*fnameescape")
    2              0.000165 au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew
                            	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
    2              0.000028 au BufNewFile,BufRead *~
                            	\ let s:name = expand("<afile>") |
                            	\ let s:short = substitute(s:name, '\~$', '', '') |
                            	\ if s:name != s:short && s:short != "" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
                            	\ endif |
                            	\ unlet! s:name s:short
    2              0.000025 au BufNewFile,BufRead ?\+.in
                            	\ if expand("<afile>:t") != "configure.in" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
                            	\ endif
    2              0.000006 elseif &verbose > 0
                              echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
                            endif
                            
                            " Pattern used to match file names which should not be inspected.
                            " Currently finds compressed files.
    2              0.000010 if !exists("g:ft_ignore_pat")
    1              0.000005   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
    1              0.000001 endif
                            
                            " Function used for patterns that end in a star: don't set the filetype if the
                            " file name matches ft_ignore_pat.
    2              0.000011 func! s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            
                            " Vim help file
    2              0.000049 au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt	setf help
                            
                            " Abaqus or Trasys
    2              0.000013 au BufNewFile,BufRead *.inp			call s:Check_inp()
                            
    2              0.000006 func! s:Check_inp()
                              if getline(1) =~ '^\*'
                                setf abaqus
                              else
                                let n = 1
                                if line("$") > 500
                                  let nmax = 500
                                else
                                  let nmax = line("$")
                                endif
                                while n <= nmax
                                  if getline(n) =~? "^header surface data"
                            	setf trasys
                            	break
                                  endif
                                  let n = n + 1
                                endwhile
                              endif
                            endfunc
                            
                            " A-A-P recipe
    2              0.000014 au BufNewFile,BufRead *.aap			setf aap
                            
                            " A2ps printing utility
    2              0.000056 au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
                            
                            " ABAB/4
    2              0.000017 au BufNewFile,BufRead *.abap			setf abap
                            
                            " ABC music notation
    2              0.000014 au BufNewFile,BufRead *.abc			setf abc
                            
                            " ABEL
    2              0.000012 au BufNewFile,BufRead *.abl			setf abel
                            
                            " AceDB
    2              0.000012 au BufNewFile,BufRead *.wrm			setf acedb
                            
                            " Ada (83, 9X, 95)
    2              0.000028 au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
    2              0.000023 if has("vms")
                              au BufNewFile,BufRead *.gpr,*.ada_m,*.adc	setf ada
                            else
    2              0.000014   au BufNewFile,BufRead *.gpr			setf ada
    2              0.000003 endif
                            
                            " AHDL
    2              0.000015 au BufNewFile,BufRead *.tdf			setf ahdl
                            
                            " AMPL
    2              0.000013 au BufNewFile,BufRead *.run			setf ampl
                            
                            " Ant
    2              0.000015 au BufNewFile,BufRead build.xml			setf ant
                            
                            " Arduino
    2              0.000021 au BufNewFile,BufRead *.ino,*.pde		setf arduino
                            
                            " Apache style config file
    2              0.000024 au BufNewFile,BufRead proftpd.conf*		call s:StarSetf('apachestyle')
                            
                            " Apache config file
    2              0.000027 au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache
                            
                            " XA65 MOS6510 cross assembler
    2              0.000014 au BufNewFile,BufRead *.a65			setf a65
                            
                            " Applescript
    2              0.000033 au BufNewFile,BufRead *.scpt			setf applescript
                            
                            " Applix ELF
    2              0.000019 au BufNewFile,BufRead *.am
                            	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
                            
                            " ALSA configuration
    2              0.000045 au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
                            
                            " Arc Macro Language
    2              0.000015 au BufNewFile,BufRead *.aml			setf aml
                            
                            " APT config file
    2              0.000015 au BufNewFile,BufRead apt.conf		       setf aptconf
    2              0.000024 au BufNewFile,BufRead */.aptitude/config       setf aptconf
    2              0.000043 au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
                            
                            " Arch Inventory file
    2              0.000035 au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch
                            
                            " ART*Enterprise (formerly ART-IM)
    2              0.000015 au BufNewFile,BufRead *.art			setf art
                            
                            " AsciiDoc
    2              0.000024 au BufNewFile,BufRead *.asciidoc,*.adoc		setf asciidoc
                            
                            " ASN.1
    2              0.000021 au BufNewFile,BufRead *.asn,*.asn1		setf asn
                            
                            " Active Server Pages (with Visual Basic Script)
    2              0.000020 au BufNewFile,BufRead *.asa
                            	\ if exists("g:filetype_asa") |
                            	\   exe "setf " . g:filetype_asa |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Active Server Pages (with Perl or Visual Basic Script)
    2              0.000024 au BufNewFile,BufRead *.asp
                            	\ if exists("g:filetype_asp") |
                            	\   exe "setf " . g:filetype_asp |
                            	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
                            	\   setf aspperl |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Grub (must be before catch *.lst)
    2              0.000049 au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
                            
                            " Assembly (all kinds)
                            " *.lst is not pure assembly, it has two extra columns (address, byte codes)
    2              0.000049 au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call s:FTasm()
                            
                            " This function checks for the kind of assembly that is wanted by the user, or
                            " can be detected from the first five lines of the file.
    2              0.000011 func! s:FTasm()
                              " make sure b:asmsyntax exists
                              if !exists("b:asmsyntax")
                                let b:asmsyntax = ""
                              endif
                            
                              if b:asmsyntax == ""
                                call s:FTasmsyntax()
                              endif
                            
                              " if b:asmsyntax still isn't set, default to asmsyntax or GNU
                              if b:asmsyntax == ""
                                if exists("g:asmsyntax")
                                  let b:asmsyntax = g:asmsyntax
                                else
                                  let b:asmsyntax = "asm"
                                endif
                              endif
                            
                              exe "setf " . fnameescape(b:asmsyntax)
                            endfunc
                            
    2              0.000006 func! s:FTasmsyntax()
                              " see if file contains any asmsyntax=foo overrides. If so, change
                              " b:asmsyntax appropriately
                              let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
                            	\" ".getline(5)." "
                              let match = matchstr(head, '\sasmsyntax=\zs[a-zA-Z0-9]\+\ze\s')
                              if match != ''
                                let b:asmsyntax = match
                              elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
                                let b:asmsyntax = "vmasm"
                              endif
                            endfunc
                            
                            " Macro (VAX)
    2              0.000018 au BufNewFile,BufRead *.mar			setf vmasm
                            
                            " Atlas
    2              0.000021 au BufNewFile,BufRead *.atl,*.as		setf atlas
                            
                            " Autoit v3
    2              0.000015 au BufNewFile,BufRead *.au3			setf autoit
                            
                            " Autohotkey
    2              0.000019 au BufNewFile,BufRead *.ahk			setf autohotkey
                            
                            " Automake
    2              0.000034 au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake
                            
                            " Autotest .at files are actually m4
    2              0.000013 au BufNewFile,BufRead *.at			setf m4
                            
                            " Avenue
    2              0.000021 au BufNewFile,BufRead *.ave			setf ave
                            
                            " Awk
    2              0.000015 au BufNewFile,BufRead *.awk			setf awk
                            
                            " B
    2              0.000037 au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b
                            
                            " BASIC or Visual Basic
    2              0.000015 au BufNewFile,BufRead *.bas			call s:FTVB("basic")
                            
                            " Check if one of the first five lines contains "VB_Name".  In that case it is
                            " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
    2              0.000007 func! s:FTVB(alt)
                              if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)'
                                setf vb
                              else
                                exe "setf " . a:alt
                              endif
                            endfunc
                            
                            " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
    2              0.000050 au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl	setf vb
                            
                            " IBasic file (similar to QBasic)
    2              0.000023 au BufNewFile,BufRead *.iba,*.ibi		setf ibasic
                            
                            " FreeBasic file (similar to QBasic)
    2              0.000024 au BufNewFile,BufRead *.fb,*.bi			setf freebasic
                            
                            " Batch file for MSDOS.
    2              0.000024 au BufNewFile,BufRead *.bat,*.sys		setf dosbatch
                            " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
    2              0.000034 au BufNewFile,BufRead *.cmd
                            	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
                            
                            " Batch file for 4DOS
    2              0.000017 au BufNewFile,BufRead *.btm			call s:FTbtm()
    2              0.000007 func! s:FTbtm()
                              if exists("g:dosbatch_syntax_for_btm") && g:dosbatch_syntax_for_btm
                                setf dosbatch
                              else
                                setf btm
                              endif
                            endfunc
                            
                            " BC calculator
    2              0.000014 au BufNewFile,BufRead *.bc			setf bc
                            
                            " BDF font
    2              0.000016 au BufNewFile,BufRead *.bdf			setf bdf
                            
                            " BibTeX bibliography database file
    2              0.000018 au BufNewFile,BufRead *.bib			setf bib
                            
                            " BibTeX Bibliography Style
    2              0.000019 au BufNewFile,BufRead *.bst			setf bst
                            
                            " BIND configuration
                            " sudoedit uses namedXXXX.conf
    2              0.000029 au BufNewFile,BufRead named*.conf,rndc*.conf	setf named
                            
                            " BIND zone
    2              0.000021 au BufNewFile,BufRead named.root		setf bindzone
    2              0.000015 au BufNewFile,BufRead *.db			call s:BindzoneCheck('')
                            
    2              0.000007 func! s:BindzoneCheck(default)
                              if getline(1).getline(2).getline(3).getline(4) =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                setf bindzone
                              elseif a:default != ''
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            " Blank
    2              0.000016 au BufNewFile,BufRead *.bl			setf blank
                            
                            " Blkid cache file
    2              0.000034 au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
                            
                            " Bazel (http://bazel.io)
    2              0.000033 autocmd BufRead,BufNewFile *.bzl,WORKSPACE 	setf bzl
    2              0.000010 if has("fname_case")
                              " There is another check for BUILD further below.
    2              0.000024   autocmd BufRead,BufNewFile BUILD		setf bzl
    2              0.000003 endif
                            
                            " C or lpc
    2              0.000013 au BufNewFile,BufRead *.c			call s:FTlpc()
                            
    2              0.000007 func! s:FTlpc()
                              if exists("g:lpc_syntax_for_c")
                                let lnum = 1
                                while lnum <= 12
                                  if getline(lnum) =~# '^\(//\|inherit\|private\|protected\|nosave\|string\|object\|mapping\|mixed\)'
                            	setf lpc
                            	return
                                  endif
                                  let lnum = lnum + 1
                                endwhile
                              endif
                              setf c
                            endfunc
                            
                            " Calendar
    2              0.000017 au BufNewFile,BufRead calendar			setf calendar
                            
                            " C#
    2              0.000015 au BufNewFile,BufRead *.cs			setf cs
                            
                            " CSDL
    2              0.000019 au BufNewFile,BufRead *.csdl			setf csdl
                            
                            " Cabal
    2              0.000020 au BufNewFile,BufRead *.cabal			setf cabal
                            
                            " Cdrdao TOC
    2              0.000016 au BufNewFile,BufRead *.toc			setf cdrtoc
                            
                            " Cdrdao config
    2              0.000068 au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf
                            
                            " Cfengine
    2              0.000025 au BufNewFile,BufRead cfengine.conf		setf cfengine
                            
                            " ChaiScript
    2              0.000015 au BufRead,BufNewFile *.chai			setf chaiscript
                            
                            " Comshare Dimension Definition Language
    2              0.000019 au BufNewFile,BufRead *.cdl			setf cdl
                            
                            " Conary Recipe
    2              0.000016 au BufNewFile,BufRead *.recipe			setf conaryrecipe
                            
                            " Controllable Regex Mutilator
    2              0.000023 au BufNewFile,BufRead *.crm			setf crm
                            
                            " Cyn++
    2              0.000018 au BufNewFile,BufRead *.cyn			setf cynpp
                            
                            " Cynlib
                            " .cc and .cpp files can be C++ or Cynlib.
    2              0.000018 au BufNewFile,BufRead *.cc
                            	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
    2              0.000020 au BufNewFile,BufRead *.cpp
                            	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
                            
                            " C++
    2              0.000120 au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
    2              0.000010 if has("fname_case")
    2              0.000030   au BufNewFile,BufRead *.C,*.H setf cpp
    2              0.000004 endif
                            
                            " .h files can be C, Ch C++, ObjC or ObjC++.
                            " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
                            " detected automatically.
    2              0.000016 au BufNewFile,BufRead *.h			call s:FTheader()
                            
    2              0.000007 func! s:FTheader()
                              if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
                                if exists("g:c_syntax_for_h")
                                  setf objc
                                else
                                  setf objcpp
                                endif
                              elseif exists("g:c_syntax_for_h")
                                setf c
                              elseif exists("g:ch_syntax_for_h")
                                setf ch
                              else
                                setf cpp
                              endif
                            endfunc
                            
                            " Ch (CHscript)
    2              0.000021 au BufNewFile,BufRead *.chf			setf ch
                            
                            " TLH files are C++ headers generated by Visual C++'s #import from typelibs
    2              0.000018 au BufNewFile,BufRead *.tlh			setf cpp
                            
                            " Cascading Style Sheets
    2              0.000017 au BufNewFile,BufRead *.css			setf css
                            
                            " Century Term Command Scripts (*.cmd too)
    2              0.000019 au BufNewFile,BufRead *.con			setf cterm
                            
                            " Changelog
    2              0.000063 au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch
                            					\	setf debchangelog
                            
    2              0.000027 au BufNewFile,BufRead [cC]hange[lL]og
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| else
                            	\|   setf changelog
                            	\| endif
                            
    2              0.000021 au BufNewFile,BufRead NEWS
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| endif
                            
                            " CHILL
    2              0.000018 au BufNewFile,BufRead *..ch			setf chill
                            
                            " Changes for WEB and CWEB or CHILL
    2              0.000017 au BufNewFile,BufRead *.ch			call s:FTchange()
                            
                            " This function checks if one of the first ten lines start with a '@'.  In
                            " that case it is probably a change file.
                            " If the first line starts with # or ! it's probably a ch file.
                            " If a line has "main", "include", "//" ir "/*" it's probably ch.
                            " Otherwise CHILL is assumed.
    2              0.000008 func! s:FTchange()
                              let lnum = 1
                              while lnum <= 10
                                if getline(lnum)[0] == '@'
                                  setf change
                                  return
                                endif
                                if lnum == 1 && (getline(1)[0] == '#' || getline(1)[0] == '!')
                                  setf ch
                                  return
                                endif
                                if getline(lnum) =~ "MODULE"
                                  setf chill
                                  return
                                endif
                                if getline(lnum) =~ 'main\s*(\|#\s*include\|//'
                                  setf ch
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                              setf chill
                            endfunc
                            
                            " ChordPro
    2              0.000075 au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro
                            
                            " Clean
    2              0.000033 au BufNewFile,BufRead *.dcl,*.icl		setf clean
                            
                            " Clever
    2              0.000018 au BufNewFile,BufRead *.eni			setf cl
                            
                            " Clever or dtd
    2              0.000018 au BufNewFile,BufRead *.ent			call s:FTent()
                            
    2              0.000006 func! s:FTent()
                              " This function checks for valid cl syntax in the first five lines.
                              " Look for either an opening comment, '#', or a block start, '{".
                              " If not found, assume SGML.
                              let lnum = 1
                              while lnum < 6
                                let line = getline(lnum)
                                if line =~ '^\s*[#{]'
                                  setf cl
                                  return
                                elseif line !~ '^\s*$'
                                  " Not a blank line, not a comment, and not a block start,
                                  " so doesn't look like valid cl code.
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf dtd
                            endfunc
                            
                            " Clipper (or FoxPro; could also be eviews)
    2              0.000031 au BufNewFile,BufRead *.prg
                            	\ if exists("g:filetype_prg") |
                            	\   exe "setf " . g:filetype_prg |
                            	\ else |
                            	\   setf clipper |
                            	\ endif
                            
                            " Clojure
    2              0.000051 au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc		setf clojure
                            
                            " Cmake
    2              0.000044 au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake
                            
                            " Cmusrc
    2              0.000043 au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
    2              0.000024 au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc
                            
                            " Cobol
    2              0.000048 au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
                            "   cobol or zope form controller python script? (heuristic)
    2              0.000025 au BufNewFile,BufRead *.cpy
                            	\ if getline(1) =~ '^##' |
                            	\   setf python |
                            	\ else |
                            	\   setf cobol |
                            	\ endif
                            
                            " Coco/R
    2              0.000019 au BufNewFile,BufRead *.atg			setf coco
                            
                            " Cold Fusion
    2              0.000047 au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf
                            
                            " Configure scripts
    2              0.000038 au BufNewFile,BufRead configure.in,configure.ac setf config
                            
                            " CUDA  Cumpute Unified Device Architecture
    2              0.000020 au BufNewFile,BufRead *.cu			setf cuda
                            
                            " Dockerfile
    2              0.000033 au BufNewFile,BufRead Dockerfile,*.Dockerfile	setf dockerfile
                            
                            " WildPackets EtherPeek Decoder
    2              0.000018 au BufNewFile,BufRead *.dcd			setf dcd
                            
                            " Enlightenment configuration files
    2              0.000021 au BufNewFile,BufRead *enlightenment/*.cfg	setf c
                            
                            " Eterm
    2              0.000019 au BufNewFile,BufRead *Eterm/*.cfg		setf eterm
                            
                            " Euphoria 3 or 4
    2              0.000066 au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()
    2              0.000009 if has("fname_case")
    2              0.000072    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()
    2              0.000003 endif
                            
    2              0.000006 func! s:EuphoriaCheck()
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              else
                                setf euphoria3
                              endif
                            endfunc
                            
                            " Lynx config files
    2              0.000024 au BufNewFile,BufRead lynx.cfg			setf lynx
                            
                            " Quake
    2              0.000051 au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
    2              0.000024 au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake
                            
                            " Quake C
    2              0.000020 au BufNewFile,BufRead *.qc			setf c
                            
                            " Configure files
    2              0.000023 au BufNewFile,BufRead *.cfg			setf cfg
                            
                            " Cucumber
    2              0.000018 au BufNewFile,BufRead *.feature			setf cucumber
                            
                            " Communicating Sequential Processes
    2              0.000033 au BufNewFile,BufRead *.csp,*.fdr		setf csp
                            
                            " CUPL logic description and simulation
    2              0.000023 au BufNewFile,BufRead *.pld			setf cupl
    2              0.000037 au BufNewFile,BufRead *.si			setf cuplsim
                            
                            " Debian Control
    2              0.000036 au BufNewFile,BufRead */debian/control		setf debcontrol
    2              0.000037 au BufNewFile,BufRead control
                            	\  if getline(1) =~ '^Source:'
                            	\|   setf debcontrol
                            	\| endif
                            
                            " Debian Sources.list
    2              0.000047 au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
    2              0.000047 au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources
                            
                            " Deny hosts
    2              0.000039 au BufNewFile,BufRead denyhosts.conf		setf denyhosts
                            
                            " dnsmasq(8) configuration files
    2              0.000029 au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq
                            
                            " ROCKLinux package description
    2              0.000019 au BufNewFile,BufRead *.desc			setf desc
                            
                            " the D language or dtrace
    2              0.000016 au BufNewFile,BufRead *.d			call s:DtraceCheck()
                            
    2              0.000007 func! s:DtraceCheck()
                              let lines = getline(1, min([line("$"), 100]))
                              if match(lines, '^module\>\|^import\>') > -1
                                " D files often start with a module and/or import statement.
                                setf d
                              elseif match(lines, '^#!\S\+dtrace\|#pragma\s\+D\s\+option\|:\S\{-}:\S\{-}:') > -1
                                setf dtrace
                              else
                                setf d
                              endif
                            endfunc
                            
                            " Desktop files
    2              0.000039 au BufNewFile,BufRead *.desktop,.directory	setf desktop
                            
                            " Dict config
    2              0.000034 au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf
                            
                            " Dictd config
    2              0.000025 au BufNewFile,BufRead dictd.conf		setf dictdconf
                            
                            " Diff files
    2              0.000048 au BufNewFile,BufRead *.diff,*.rej,*.patch	setf diff
                            
                            " Dircolors
    2              0.000054 au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors
                            
                            " Diva (with Skill) or InstallShield
    2              0.000032 au BufNewFile,BufRead *.rul
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
                            	\   setf ishd |
                            	\ else |
                            	\   setf diva |
                            	\ endif
                            
                            " DCL (Digital Command Language - vms) or DNS zone file
    2              0.000023 au BufNewFile,BufRead *.com			call s:BindzoneCheck('dcl')
                            
                            " DOT
    2              0.000027 au BufNewFile,BufRead *.dot			setf dot
                            
                            " Dylan - lid files
    2              0.000023 au BufNewFile,BufRead *.lid			setf dylanlid
                            
                            " Dylan - intr files (melange)
    2              0.000046 au BufNewFile,BufRead *.intr			setf dylanintr
                            
                            " Dylan
    2              0.000022 au BufNewFile,BufRead *.dylan			setf dylan
                            
                            " Microsoft Module Definition
    2              0.000021 au BufNewFile,BufRead *.def			setf def
                            
                            " Dracula
    2              0.000065 au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula
                            
                            " Datascript
    2              0.000019 au BufNewFile,BufRead *.ds			setf datascript
                            
                            " dsl
    2              0.000024 au BufNewFile,BufRead *.dsl			setf dsl
                            
                            " DTD (Document Type Definition for XML)
    2              0.000020 au BufNewFile,BufRead *.dtd			setf dtd
                            
                            " DTS/DSTI (device tree files)
    2              0.000033 au BufNewFile,BufRead *.dts,*.dtsi		setf dts
                            
                            " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
    2              0.000024 au BufNewFile,BufRead *.ed\(f\|if\|o\)		setf edif
    2              0.000028 au BufNewFile,BufRead *.edn
                            	\ if getline(1) =~ '^\s*(\s*edif\>' |
                            	\   setf edif |
                            	\ else |
                            	\   setf clojure |
                            	\ endif
                            
                            " EditorConfig (close enough to dosini)
    2              0.000027 au BufNewFile,BufRead .editorconfig		setf dosini
                            
                            " Embedix Component Description
    2              0.000024 au BufNewFile,BufRead *.ecd			setf ecd
                            
                            " Eiffel or Specman or Euphoria
    2              0.000029 au BufNewFile,BufRead *.e,*.E			call s:FTe()
                            
                            " Elinks configuration
    2              0.000053 au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf	setf elinks
                            
    2              0.000007 func! s:FTe()
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              else
                                let n = 1
                                while n < 100 && n < line("$")
                                  if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
                            	setf specman
                            	return
                                  endif
                                  let n = n + 1
                                endwhile
                                setf eiffel
                              endif
                            endfunc
                            
                            " ERicsson LANGuage; Yaws is erlang too
    2              0.000058 au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang
                            
                            " Elm Filter Rules file
    2              0.000023 au BufNewFile,BufRead filter-rules		setf elmfilt
                            
                            " ESMTP rc file
    2              0.000034 au BufNewFile,BufRead *esmtprc			setf esmtprc
                            
                            " ESQL-C
    2              0.000035 au BufNewFile,BufRead *.ec,*.EC			setf esqlc
                            
                            " Esterel
    2              0.000021 au BufNewFile,BufRead *.strl			setf esterel
                            
                            " Essbase script
    2              0.000024 au BufNewFile,BufRead *.csc			setf csc
                            
                            " Exim
    2              0.000022 au BufNewFile,BufRead exim.conf			setf exim
                            
                            " Expect
    2              0.000023 au BufNewFile,BufRead *.exp			setf expect
                            
                            " Exports
    2              0.000027 au BufNewFile,BufRead exports			setf exports
                            
                            " Falcon
    2              0.000024 au BufNewFile,BufRead *.fal			setf falcon
                            
                            " Fantom
    2              0.000040 au BufNewFile,BufRead *.fan,*.fwt		setf fan
                            
                            " Factor
    2              0.000024 au BufNewFile,BufRead *.factor			setf factor
                            
                            " Fetchmail RC file
    2              0.000031 au BufNewFile,BufRead .fetchmailrc		setf fetchmail
                            
                            " FlexWiki - disabled, because it has side effects when a .wiki file
                            " is not actually FlexWiki
                            "au BufNewFile,BufRead *.wiki			setf flexwiki
                            
                            " Focus Executable
    2              0.000042 au BufNewFile,BufRead *.fex,*.focexec		setf focexec
                            
                            " Focus Master file (but not for auto.master)
    2              0.000042 au BufNewFile,BufRead auto.master		setf conf
    2              0.000047 au BufNewFile,BufRead *.mas,*.master		setf master
                            
                            " Forth
    2              0.000039 au BufNewFile,BufRead *.fs,*.ft			setf forth
                            
                            " Reva Forth
    2              0.000019 au BufNewFile,BufRead *.frt			setf reva
                            
                            " Fortran
    2              0.000012 if has("fname_case")
    2              0.000143   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
    2              0.000003 endif
    2              0.000161 au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
                            
                            " Framescript
    2              0.000022 au BufNewFile,BufRead *.fsl			setf framescript
                            
                            " FStab
    2              0.000087 au BufNewFile,BufRead fstab,mtab		setf fstab
                            
                            " GDB command files
    2              0.000034 au BufNewFile,BufRead .gdbinit			setf gdb
                            
                            " GDMO
    2              0.000041 au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo
                            
                            " Gedcom
    2              0.000042 au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom
                            
                            " Git
    2              0.000050 au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG setf gitcommit
    2              0.000050 au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
    2              0.000028 au BufNewFile,BufRead *.git/modules/*/config	setf gitconfig
    2              0.000023 au BufNewFile,BufRead */.config/git/config	setf gitconfig
    2              0.000012 if !empty($XDG_CONFIG_HOME)
                              au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config	setf gitconfig
                            endif
    2              0.000024 au BufNewFile,BufRead git-rebase-todo		setf gitrebase
    2              0.000025 au BufNewFile,BufRead .msg.[0-9]*
                                  \ if getline(1) =~ '^From.*# This line is ignored.$' |
                                  \   setf gitsendemail |
                                  \ endif
    2              0.000023 au BufNewFile,BufRead *.git/*
                                  \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
                                  \   setf git |
                                  \ endif
                            
                            " Gkrellmrc
    2              0.000035 au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc
                            
                            " GP scripts (2.0 and onward)
    2              0.000037 au BufNewFile,BufRead *.gp,.gprc		setf gp
                            
                            " GPG
    2              0.000021 au BufNewFile,BufRead */.gnupg/options		setf gpg
    2              0.000022 au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
    2              0.000025 au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
    2              0.000008 if !empty($GNUPGHOME)
                              au BufNewFile,BufRead $GNUPGHOME/options	setf gpg
                              au BufNewFile,BufRead $GNUPGHOME/gpg.conf	setf gpg
                            endif
                            
                            " gnash(1) configuration files
    2              0.000073 au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
                            
                            " Gitolite
    2              0.000022 au BufNewFile,BufRead gitolite.conf		setf gitolite
    2              0.000024 au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
    2              0.000047 au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc	setf perl
                            
                            " Gnuplot scripts
    2              0.000025 au BufNewFile,BufRead *.gpi			setf gnuplot
                            
                            " Go (Google)
    2              0.000020 au BufNewFile,BufRead *.go			setf go
                            
                            " GrADS scripts
    2              0.000019 au BufNewFile,BufRead *.gs			setf grads
                            
                            " Gretl
    2              0.000019 au BufNewFile,BufRead *.gretl			setf gretl
                            
                            " Groovy
    2              0.000048 au BufNewFile,BufRead *.gradle,*.groovy		setf groovy
                            
                            " GNU Server Pages
    2              0.000027 au BufNewFile,BufRead *.gsp			setf gsp
                            
                            " Group file
    2              0.000155 au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
                            
                            " GTK RC
    2              0.000044 au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc
                            
                            " Haml
    2              0.000020 au BufNewFile,BufRead *.haml			setf haml
                            
                            " Hamster Classic | Playground files
    2              0.000041 au BufNewFile,BufRead *.hsc,*.hsm		setf hamster
                            
                            " Haskell
    2              0.000036 au BufNewFile,BufRead *.hs,*.hs-boot		setf haskell
    2              0.000029 au BufNewFile,BufRead *.lhs			setf lhaskell
    2              0.000025 au BufNewFile,BufRead *.chs			setf chaskell
                            
                            " Haste
    2              0.000022 au BufNewFile,BufRead *.ht			setf haste
    2              0.000021 au BufNewFile,BufRead *.htpp			setf hastepreproc
                            
                            " Hercules
    2              0.000072 au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum	setf hercules
                            
                            " HEX (Intel)
    2              0.000042 au BufNewFile,BufRead *.hex,*.h32		setf hex
                            
                            " Tilde (must be before HTML)
    2              0.000021 au BufNewFile,BufRead *.t.html			setf tilde
                            
                            " HTML (.shtml and .stm for server side)
    2              0.000073 au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
                            
                            " Distinguish between HTML, XHTML and Django
    2              0.000008 func! s:FThtml()
                              let n = 1
                              while n < 10 && n < line("$")
                                if getline(n) =~ '\<DTD\s\+XHTML\s'
                                  setf xhtml
                                  return
                                endif
                                if getline(n) =~ '{%\s*\(extends\|block\|load\)\>\|{#\s\+'
                                  setf htmldjango
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf html
                            endfunc
                            
                            " HTML with Ruby - eRuby
    2              0.000048 au BufNewFile,BufRead *.erb,*.rhtml		setf eruby
                            
                            " HTML with M4
    2              0.000023 au BufNewFile,BufRead *.html.m4			setf htmlm4
                            
                            " HTML Cheetah template
    2              0.000021 au BufNewFile,BufRead *.tmpl			setf htmlcheetah
                            
                            " Host config
    2              0.000024 au BufNewFile,BufRead */etc/host.conf		setf hostconf
                            
                            " Hosts access
    2              0.000041 au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
                            
                            " Hyper Builder
    2              0.000022 au BufNewFile,BufRead *.hb			setf hb
                            
                            " Httest
    2              0.000045 au BufNewFile,BufRead *.htt,*.htb		setf httest
                            
                            " Icon
    2              0.000024 au BufNewFile,BufRead *.icn			setf icon
                            
                            " IDL (Interface Description Language)
    2              0.000025 au BufNewFile,BufRead *.idl			call s:FTidl()
                            
                            " Distinguish between standard IDL and MS-IDL
    2              0.000005 func! s:FTidl()
                              let n = 1
                              while n < 50 && n < line("$")
                                if getline(n) =~ '^\s*import\s\+"\(unknwn\|objidl\)\.idl"'
                                  setf msidl
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf idl
                            endfunc
                            
                            " Microsoft IDL (Interface Description Language)  Also *.idl
                            " MOF = WMI (Windows Management Instrumentation) Managed Object Format
    2              0.000049 au BufNewFile,BufRead *.odl,*.mof		setf msidl
                            
                            " Icewm menu
    2              0.000024 au BufNewFile,BufRead */.icewm/menu		setf icemenu
                            
                            " Indent profile (must come before IDL *.pro!)
    2              0.000023 au BufNewFile,BufRead .indent.pro		setf indent
    2              0.000023 au BufNewFile,BufRead indent.pro		call s:ProtoCheck('indent')
                            
                            " IDL (Interactive Data Language)
    2              0.000026 au BufNewFile,BufRead *.pro			call s:ProtoCheck('idlang')
                            
                            " Distinguish between "default" and Cproto prototype file. */
    2              0.000005 func! s:ProtoCheck(default)
                              " Cproto files have a comment in the first line and a function prototype in
                              " the second line, it always ends in ";".  Indent files may also have
                              " comments, thus we can't match comments to see the difference.
                              " IDL files can have a single ';' in the second line, require at least one
                              " chacter before the ';'.
                              if getline(2) =~ '.;$'
                                setf cpp
                              else
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            
                            " Indent RC
    2              0.000029 au BufNewFile,BufRead indentrc			setf indent
                            
                            " Inform
    2              0.000048 au BufNewFile,BufRead *.inf,*.INF		setf inform
                            
                            " Initng
    2              0.000042 au BufNewFile,BufRead */etc/initng/*/*.i,*.ii	setf initng
                            
                            " Innovation Data Processing
    2              0.000064 au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c 	setf upstreamdat
    2              0.000104 au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c 	setf upstreamlog
    2              0.000072 au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
    2              0.000076 au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c 	setf usserverlog
    2              0.000064 au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c 	setf usw2kagtlog
                            
                            " Ipfilter
    2              0.000059 au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter
                            
                            " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
    2              0.000063 au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl
                            
                            " .INI file for MSDOS
    2              0.000028 au BufNewFile,BufRead *.ini			setf dosini
                            
                            " SysV Inittab
    2              0.000031 au BufNewFile,BufRead inittab			setf inittab
                            
                            " Inno Setup
    2              0.000028 au BufNewFile,BufRead *.iss			setf iss
                            
                            " J
    2              0.000026 au BufNewFile,BufRead *.ijs			setf j
                            
                            " JAL
    2              0.000047 au BufNewFile,BufRead *.jal,*.JAL		setf jal
                            
                            " Jam
    2              0.000048 au BufNewFile,BufRead *.jpl,*.jpr		setf jam
                            
                            " Java
    2              0.000050 au BufNewFile,BufRead *.java,*.jav		setf java
                            
                            " JavaCC
    2              0.000047 au BufNewFile,BufRead *.jj,*.jjt		setf javacc
                            
                            " JavaScript, ECMAScript
    2              0.000080 au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx   setf javascript
                            
                            " Java Server Pages
    2              0.000027 au BufNewFile,BufRead *.jsp			setf jsp
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
    2              0.000064 au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
    2              0.000027 au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')
                            
                            " Jess
    2              0.000029 au BufNewFile,BufRead *.clp			setf jess
                            
                            " Jgraph
    2              0.000029 au BufNewFile,BufRead *.jgr			setf jgraph
                            
                            " Jovial
    2              0.000076 au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial
                            
                            " JSON
    2              0.000060 au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest	setf json
                            
                            " Kixtart
    2              0.000031 au BufNewFile,BufRead *.kix			setf kix
                            
                            " Kimwitu[++]
    2              0.000022 au BufNewFile,BufRead *.k			setf kwt
                            
                            " Kivy
    2              0.000024 au BufNewFile,BufRead *.kv			setf kivy
                            
                            " KDE script
    2              0.000024 au BufNewFile,BufRead *.ks			setf kscript
                            
                            " Kconfig
    2              0.000047 au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig
                            
                            " Lace (ISE)
    2              0.000054 au BufNewFile,BufRead *.ace,*.ACE		setf lace
                            
                            " Latte
    2              0.000048 au BufNewFile,BufRead *.latte,*.lte		setf latte
                            
                            " Limits
    2              0.000075 au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits
                            
                            " LambdaProlog (*.mod too, see Modsim)
    2              0.000034 au BufNewFile,BufRead *.sig			setf lprolog
                            
                            " LDAP LDIF
    2              0.000025 au BufNewFile,BufRead *.ldif			setf ldif
                            
                            " Ld loader
    2              0.000025 au BufNewFile,BufRead *.ld			setf ld
                            
                            " Less
    2              0.000025 au BufNewFile,BufRead *.less			setf less
                            
                            " Lex
    2              0.000092 au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++	setf lex
                            
                            " Libao
    2              0.000048 au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao
                            
                            " Libsensors
    2              0.000052 au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors
                            
                            " LFTP
    2              0.000063 au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp
                            
                            " Lifelines (or Lex for C++!)
    2              0.000027 au BufNewFile,BufRead *.ll			setf lifelines
                            
                            " Lilo: Linux loader
    2              0.000029 au BufNewFile,BufRead lilo.conf			setf lilo
                            
                            " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
    2              0.000010 if has("fname_case")
    2              0.000165   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
    2              0.000004 else
                              au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
                            endif
                            
                            " SBCL implementation of Common Lisp
    2              0.000052 au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp
                            
                            " Liquid
    2              0.000027 au BufNewFile,BufRead *.liquid			setf liquid
                            
                            " Lite
    2              0.000045 au BufNewFile,BufRead *.lite,*.lt		setf lite
                            
                            " LiteStep RC files
    2              0.000030 au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep
                            
                            " Login access
    2              0.000032 au BufNewFile,BufRead */etc/login.access	setf loginaccess
                            
                            " Login defs
    2              0.000028 au BufNewFile,BufRead */etc/login.defs		setf logindefs
                            
                            " Logtalk
    2              0.000039 au BufNewFile,BufRead *.lgt			setf logtalk
                            
                            " LOTOS
    2              0.000053 au BufNewFile,BufRead *.lot,*.lotos		setf lotos
                            
                            " Lout (also: *.lt)
    2              0.000050 au BufNewFile,BufRead *.lou,*.lout		setf lout
                            
                            " Lua
    2              0.000032 au BufNewFile,BufRead *.lua			setf lua
                            
                            " Luarocks
    2              0.000028 au BufNewFile,BufRead *.rockspec		setf lua
                            
                            " Linden Scripting Language (Second Life)
    2              0.000031 au BufNewFile,BufRead *.lsl			setf lsl
                            
                            " Lynx style file (or LotusScript!)
    2              0.000032 au BufNewFile,BufRead *.lss			setf lss
                            
                            " M4
    2              0.000032 au BufNewFile,BufRead *.m4
                            	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
                            
                            " MaGic Point
    2              0.000034 au BufNewFile,BufRead *.mgp			setf mgp
                            
                            " Mail (for Elm, trn, mutt, muttng, rn, slrn)
    2              0.000353 au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
                            
                            " Mail aliases
    2              0.000071 au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases
                            
                            " Mailcap configuration file
    2              0.000061 au BufNewFile,BufRead .mailcap,mailcap		setf mailcap
                            
                            " Makefile
    2              0.000122 au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
                            
                            " MakeIndex
    2              0.000074 au BufNewFile,BufRead *.ist,*.mst		setf ist
                            
                            " Mallard
    2              0.000038 au BufNewFile,BufRead *.page			setf mallard
                            
                            " Manpage
    2              0.000035 au BufNewFile,BufRead *.man			setf man
                            
                            " Man config
    2              0.000063 au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf
                            
                            " Maple V
    2              0.000081 au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple
                            
                            " Map (UMN mapserver config file)
    2              0.000036 au BufNewFile,BufRead *.map			setf map
                            
                            " Markdown
    2              0.000138 au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
                            
                            " Mason
    2              0.000071 au BufNewFile,BufRead *.mason,*.mhtml,*.comp	setf mason
                            
                            " Mathematica, Matlab, Murphi or Objective C
    2              0.000030 au BufNewFile,BufRead *.m			call s:FTm()
                            
    2              0.000008 func! s:FTm()
                              let n = 1
                              let saw_comment = 0 " Whether we've seen a multiline comment leader.
                              while n < 100
                                let line = getline(n)
                                if line =~ '^\s*/\*'
                                  " /* ... */ is a comment in Objective C and Murphi, so we can't conclude
                                  " it's either of them yet, but track this as a hint in case we don't see
                                  " anything more definitive.
                                  let saw_comment = 1
                                endif
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|@import\>\|//\)'
                                  setf objc
                                  return
                                endif
                                if line =~ '^\s*%'
                                  setf matlab
                                  return
                                endif
                                if line =~ '^\s*(\*'
                                  setf mma
                                  return
                                endif
                                if line =~ '^\c\s*\(\(type\|var\)\>\|--\)'
                                  setf murphi
                                  return
                                endif
                                let n = n + 1
                              endwhile
                            
                              if saw_comment
                                " We didn't see anything definitive, but this looks like either Objective C
                                " or Murphi based on the comment leader. Assume the former as it is more
                                " common.
                                setf objc
                              elseif exists("g:filetype_m")
                                " Use user specified default filetype for .m
                                exe "setf " . g:filetype_m
                              else
                                " Default is matlab
                                setf matlab
                              endif
                            endfunc
                            
                            " Mathematica notebook
    2              0.000044 au BufNewFile,BufRead *.nb			setf mma
                            
                            " Maya Extension Language
    2              0.000038 au BufNewFile,BufRead *.mel			setf mel
                            
                            " Mercurial (hg) commit file
    2              0.000034 au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit
                            
                            " Mercurial config (looks like generic config file)
    2              0.000057 au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg
                            
                            " Messages (logs mostly)
    2              0.000070 au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
                            
                            " Metafont
    2              0.000037 au BufNewFile,BufRead *.mf			setf mf
                            
                            " MetaPost
    2              0.000030 au BufNewFile,BufRead *.mp			setf mp
                            
                            " MGL
    2              0.000036 au BufNewFile,BufRead *.mgl			setf mgl
                            
                            " MIX - Knuth assembly
    2              0.000059 au BufNewFile,BufRead *.mix,*.mixal		setf mix
                            
                            " MMIX or VMS makefile
    2              0.000043 au BufNewFile,BufRead *.mms			call s:FTmms()
                            
                            " Symbian meta-makefile definition (MMP)
    2              0.000038 au BufNewFile,BufRead *.mmp			setf mmp
                            
    2              0.000008 func! s:FTmms()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(%\|//\)' || line =~ '^\*'
                                  setf mmix
                                  return
                                endif
                                if line =~ '^\s*#'
                                  setf make
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf mmix
                            endfunc
                            
                            
                            " Modsim III (or LambdaProlog)
    2              0.000051 au BufNewFile,BufRead *.mod
                            	\ if getline(1) =~ '\<module\>' |
                            	\   setf lprolog |
                            	\ else |
                            	\   setf modsim3 |
                            	\ endif
                            
                            " Modula 2  (.md removed in favor of Markdown)
    2              0.000114 au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi	setf modula2
                            
                            " Modula 3 (.m3, .i3, .mg, .ig)
    2              0.000036 au BufNewFile,BufRead *.[mi][3g]		setf modula3
                            
                            " Monk
    2              0.000116 au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk
                            
                            " MOO
    2              0.000044 au BufNewFile,BufRead *.moo			setf moo
                            
                            " Modconf
    2              0.000089 au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
                            
                            " Mplayer config
    2              0.000066 au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf
                            
                            " Motorola S record
    2              0.000144 au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec	setf srec
                            
                            " Mrxvtrc
    2              0.000056 au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc
                            
                            " Msql
    2              0.000031 au BufNewFile,BufRead *.msql			setf msql
                            
                            " Mysql
    2              0.000036 au BufNewFile,BufRead *.mysql			setf mysql
                            
                            " Mutt setup files (must be before catch *.rc)
    2              0.000037 au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')
                            
                            " M$ Resource files
    2              0.000063 au BufNewFile,BufRead *.rc,*.rch		setf rc
                            
                            " MuPAD source
    2              0.000034 au BufRead,BufNewFile *.mu			setf mupad
                            
                            " Mush
    2              0.000030 au BufNewFile,BufRead *.mush			setf mush
                            
                            " Mutt setup file (also for Muttng)
    2              0.000035 au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc
                            
                            " Nano
    2              0.000064 au BufNewFile,BufRead */etc/nanorc,*.nanorc  	setf nanorc
                            
                            " Nastran input/DMAP
                            "au BufNewFile,BufRead *.dat			setf nastran
                            
                            " Natural
    2              0.000036 au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural
                            
                            " Netrc
    2              0.000035 au BufNewFile,BufRead .netrc			setf netrc
                            
                            " Ninja file
    2              0.000037 au BufNewFile,BufRead *.ninja			setf ninja
                            
                            " Novell netware batch files
    2              0.000040 au BufNewFile,BufRead *.ncf			setf ncf
                            
                            " Nroff/Troff (*.ms and *.t are checked below)
    2              0.000040 au BufNewFile,BufRead *.me
                            	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
                            	\   setf nroff |
                            	\ endif
    2              0.000134 au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
    2              0.000038 au BufNewFile,BufRead *.[1-9]			call s:FTnroff()
                            
                            " This function checks if one of the first five lines start with a dot.  In
                            " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
    2              0.000006 func! s:FTnroff()
                              if getline(1)[0] . getline(2)[0] . getline(3)[0] . getline(4)[0] . getline(5)[0] =~ '\.'
                                setf nroff
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Nroff or Objective C++
    2              0.000045 au BufNewFile,BufRead *.mm			call s:FTmm()
                            
    2              0.000006 func! s:FTmm()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|@import\>\|/\*\)'
                                  setf objcpp
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf nroff
                            endfunc
                            
                            " Not Quite C
    2              0.000053 au BufNewFile,BufRead *.nqc			setf nqc
                            
                            " NSE - Nmap Script Engine - uses Lua syntax
    2              0.000042 au BufNewFile,BufRead *.nse			setf lua
                            
                            " NSIS
    2              0.000070 au BufNewFile,BufRead *.nsi,*.nsh		setf nsis
                            
                            " OCAML
    2              0.000148 au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit	setf ocaml
                            
                            " Occam
    2              0.000053 au BufNewFile,BufRead *.occ			setf occam
                            
                            " Omnimark
    2              0.000072 au BufNewFile,BufRead *.xom,*.xin		setf omnimark
                            
                            " OpenROAD
    2              0.000035 au BufNewFile,BufRead *.or			setf openroad
                            
                            " OPL
    2              0.000036 au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl
                            
                            " Oracle config file
    2              0.000051 au BufNewFile,BufRead *.ora			setf ora
                            
                            " Packet filter conf
    2              0.000040 au BufNewFile,BufRead pf.conf			setf pf
                            
                            " Pam conf
    2              0.000037 au BufNewFile,BufRead */etc/pam.conf		setf pamconf
                            
                            " PApp
    2              0.000080 au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp
                            
                            " Password file
    2              0.000211 au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
                            
                            " Pascal (also *.p)
    2              0.000045 au BufNewFile,BufRead *.pas			setf pascal
                            
                            " Delphi project file
    2              0.000043 au BufNewFile,BufRead *.dpr			setf pascal
                            
                            " PDF
    2              0.000042 au BufNewFile,BufRead *.pdf			setf pdf
                            
                            " Perl
    2              0.000009 if has("fname_case")
    2              0.000067   au BufNewFile,BufRead *.pl,*.PL		call s:FTpl()
    2              0.000004 else
                              au BufNewFile,BufRead *.pl			call s:FTpl()
                            endif
    2              0.000090 au BufNewFile,BufRead *.plx,*.al,*.psgi		setf perl
    2              0.000096 au BufNewFile,BufRead *.p6,*.pm6,*.pl6		setf perl6
                            
    2              0.000008 func! s:FTpl()
                              if exists("g:filetype_pl")
                                exe "setf " . g:filetype_pl
                              else
                                " recognize Prolog by specific text in the first non-empty line
                                " require a blank after the '%' because Perl uses "%list" and "%translate"
                                let l = getline(nextnonblank(1))
                                if l =~ '\<prolog\>' || l =~ '^\s*\(%\+\(\s\|$\)\|/\*\)' || l =~ ':-'
                                  setf prolog
                                else
                                  setf perl
                                endif
                              endif
                            endfunc
                            
                            " Perl, XPM or XPM2
    2              0.000054 au BufNewFile,BufRead *.pm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ elseif getline(1) =~ "XPM" |
                            	\   setf xpm |
                            	\ else |
                            	\   setf perl |
                            	\ endif
                            
                            " Perl POD
    2              0.000045 au BufNewFile,BufRead *.pod			setf pod
    2              0.000038 au BufNewFile,BufRead *.pod6			setf pod6
                            
                            " Php, php3, php4, etc.
                            " Also Phtml (was used for PHP 2 in the past)
                            " Also .ctp for Cake template file
    2              0.000128 au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php
                            
                            " Pike
    2              0.000117 au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
                            
                            " Pinfo config
    2              0.000066 au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo
                            
                            " Palm Resource compiler
    2              0.000045 au BufNewFile,BufRead *.rcp			setf pilrc
                            
                            " Pine config
    2              0.000113 au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine
                            
                            " PL/1, PL/I
    2              0.000079 au BufNewFile,BufRead *.pli,*.pl1		setf pli
                            
                            " PL/M (also: *.inp)
    2              0.000103 au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm
                            
                            " PL/SQL
    2              0.000071 au BufNewFile,BufRead *.pls,*.plsql		setf plsql
                            
                            " PLP
    2              0.000058 au BufNewFile,BufRead *.plp			setf plp
                            
                            " PO and PO template (GNU gettext)
    2              0.000073 au BufNewFile,BufRead *.po,*.pot		setf po
                            
                            " Postfix main config
    2              0.000040 au BufNewFile,BufRead main.cf			setf pfmain
                            
                            " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
    2              0.000215 au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr
                            
                            " PostScript Printer Description
    2              0.000049 au BufNewFile,BufRead *.ppd			setf ppd
                            
                            " Povray
    2              0.000047 au BufNewFile,BufRead *.pov			setf pov
                            
                            " Povray configuration
    2              0.000041 au BufNewFile,BufRead .povrayrc			setf povini
                            
                            " Povray, PHP or assembly
    2              0.000047 au BufNewFile,BufRead *.inc			call s:FTinc()
                            
    2              0.000012 func! s:FTinc()
                              if exists("g:filetype_inc")
                                exe "setf " . g:filetype_inc
                              else
                                let lines = getline(1).getline(2).getline(3)
                                if lines =~? "perlscript"
                                  setf aspperl
                                elseif lines =~ "<%"
                                  setf aspvbs
                                elseif lines =~ "<?"
                                  setf php
                                else
                                  call s:FTasmsyntax()
                                  if exists("b:asmsyntax")
                            	exe "setf " . fnameescape(b:asmsyntax)
                                  else
                            	setf pov
                                  endif
                                endif
                              endif
                            endfunc
                            
                            " Printcap and Termcap
    2              0.000055 au BufNewFile,BufRead *printcap
                            	\ let b:ptcap_type = "print" | setf ptcap
    2              0.000044 au BufNewFile,BufRead *termcap
                            	\ let b:ptcap_type = "term" | setf ptcap
                            
                            " PCCTS / ANTRL
                            "au BufNewFile,BufRead *.g			setf antrl
    2              0.000038 au BufNewFile,BufRead *.g			setf pccts
                            
                            " PPWizard
    2              0.000066 au BufNewFile,BufRead *.it,*.ih			setf ppwiz
                            
                            " Obj 3D file format
                            " TODO: is there a way to avoid MS-Windows Object files?
    2              0.000048 au BufNewFile,BufRead *.obj			setf obj
                            
                            " Oracle Pro*C/C++
    2              0.000041 au BufNewFile,BufRead *.pc			setf proc
                            
                            " Privoxy actions file
    2              0.000041 au BufNewFile,BufRead *.action			setf privoxy
                            
                            " Procmail
    2              0.000065 au BufNewFile,BufRead .procmail,.procmailrc	setf procmail
                            
                            " Progress or CWEB
    2              0.000039 au BufNewFile,BufRead *.w			call s:FTprogress_cweb()
                            
    2              0.000007 func! s:FTprogress_cweb()
                              if exists("g:filetype_w")
                                exe "setf " . g:filetype_w
                                return
                              endif
                              if getline(1) =~ '&ANALYZE' || getline(3) =~ '&GLOBAL-DEFINE'
                                setf progress
                              else
                                setf cweb
                              endif
                            endfunc
                            
                            " Progress or assembly
    2              0.000046 au BufNewFile,BufRead *.i			call s:FTprogress_asm()
                            
    2              0.000006 func! s:FTprogress_asm()
                              if exists("g:filetype_i")
                                exe "setf " . g:filetype_i
                                return
                              endif
                              " This function checks for an assembly comment the first ten lines.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*;' || line =~ '^\*'
                                  call s:FTasm()
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid assembly code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            " Progress or Pascal
    2              0.000049 au BufNewFile,BufRead *.p			call s:FTprogress_pascal()
                            
    2              0.000006 func! s:FTprogress_pascal()
                              if exists("g:filetype_p")
                                exe "setf " . g:filetype_p
                                return
                              endif
                              " This function checks for valid Pascal syntax in the first ten lines.
                              " Look for either an opening comment or a program start.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*\(program\|unit\|procedure\|function\|const\|type\|var\)\>'
                            	\ || line =~ '^\s*{' || line =~ '^\s*(\*'
                                  setf pascal
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid Pascal code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            
                            " Software Distributor Product Specification File (POSIX 1387.2-1995)
    2              0.000056 au BufNewFile,BufRead *.psf			setf psf
    2              0.000082 au BufNewFile,BufRead INDEX,INFO
                            	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
                            	\   setf psf |
                            	\ endif
                            
                            " Prolog
    2              0.000050 au BufNewFile,BufRead *.pdb			setf prolog
                            
                            " Promela
    2              0.000048 au BufNewFile,BufRead *.pml			setf promela
                            
                            " Google protocol buffers
    2              0.000044 au BufNewFile,BufRead *.proto			setf proto
                            
                            " Protocols
    2              0.000042 au BufNewFile,BufRead */etc/protocols		setf protocols
                            
                            " Pyrex
    2              0.000084 au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex
                            
                            " Python, Python Shell Startup Files
                            " Quixote (Python-based web framework)
    2              0.000164 au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl  setf python
                            
                            " Radiance
    2              0.000081 au BufNewFile,BufRead *.rad,*.mat		setf radiance
                            
                            " Ratpoison config/command files
    2              0.000073 au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison
                            
                            " RCS file
    2              0.000049 au BufNewFile,BufRead *\,v			setf rcs
                            
                            " Readline
    2              0.000075 au BufNewFile,BufRead .inputrc,inputrc		setf readline
                            
                            " Registry for MS-Windows
    2              0.000056 au BufNewFile,BufRead *.reg
                            	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
                            
                            " Renderman Interface Bytestream
    2              0.000061 au BufNewFile,BufRead *.rib			setf rib
                            
                            " Rexx
    2              0.000312 au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx
                            
                            " R (Splus)
    2              0.000010 if has("fname_case")
    2              0.000095   au BufNewFile,BufRead *.s,*.S			setf r
    2              0.000005 else
                              au BufNewFile,BufRead *.s			setf r
                            endif
                            
                            " R Help file
    2              0.000009 if has("fname_case")
    2              0.000102   au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
    2              0.000004 else
                              au BufNewFile,BufRead *.rd			setf rhelp
                            endif
                            
                            " R noweb file
    2              0.000009 if has("fname_case")
    2              0.000192   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
    2              0.000005 else
                              au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
                            endif
                            
                            " R Markdown file
    2              0.000008 if has("fname_case")
    2              0.000206   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd		setf rmd
    2              0.000004 else
                              au BufNewFile,BufRead *.rmd,*.smd			setf rmd
                            endif
                            
                            " R reStructuredText file
    2              0.000009 if has("fname_case")
    2              0.000158   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst	setf rrst
    2              0.000005 else
                              au BufNewFile,BufRead *.rrst,*.srst			setf rrst
                            endif
                            
                            " Rexx, Rebol or R
    2              0.000081 au BufNewFile,BufRead *.r,*.R			call s:FTr()
                            
    2              0.000008 func! s:FTr()
                              let max = line("$") > 50 ? 50 : line("$")
                            
                              for n in range(1, max)
                                " Rebol is easy to recognize, check for that first
                                if getline(n) =~? '\<REBOL\>'
                                  setf rebol
                                  return
                                endif
                              endfor
                            
                              for n in range(1, max)
                                " R has # comments
                                if getline(n) =~ '^\s*#'
                                  setf r
                                  return
                                endif
                                " Rexx has /* comments */
                                if getline(n) =~ '^\s*/\*'
                                  setf rexx
                                  return
                                endif
                              endfor
                            
                              " Nothing recognized, use user default or assume Rexx
                              if exists("g:filetype_r")
                                exe "setf " . g:filetype_r
                              else
                                " Rexx used to be the default, but R appears to be much more popular.
                                setf r
                              endif
                            endfunc
                            
                            " Remind
    2              0.000147 au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind
                            
                            " Resolv.conf
    2              0.000063 au BufNewFile,BufRead resolv.conf		setf resolv
                            
                            " Relax NG Compact
    2              0.000062 au BufNewFile,BufRead *.rnc			setf rnc
                            
                            " Relax NG XML
    2              0.000064 au BufNewFile,BufRead *.rng			setf rng
                            
                            " RPL/2
    2              0.000067 au BufNewFile,BufRead *.rpl			setf rpl
                            
                            " Robots.txt
    2              0.000056 au BufNewFile,BufRead robots.txt		setf robots
                            
                            " Rpcgen
    2              0.000051 au BufNewFile,BufRead *.x			setf rpcgen
                            
                            " reStructuredText Documentation Format
    2              0.000063 au BufNewFile,BufRead *.rst			setf rst
                            
                            " RTF
    2              0.000066 au BufNewFile,BufRead *.rtf			setf rtf
                            
                            " Interactive Ruby shell
    2              0.000105 au BufNewFile,BufRead .irbrc,irbrc		setf ruby
                            
                            " Ruby
    2              0.000109 au BufNewFile,BufRead *.rb,*.rbw		setf ruby
                            
                            " RubyGems
    2              0.000064 au BufNewFile,BufRead *.gemspec			setf ruby
                            
                            " Rust
    2              0.000064 au BufNewFile,BufRead *.rs			setf rust
                            
                            " Rackup
    2              0.000068 au BufNewFile,BufRead *.ru			setf ruby
                            
                            " Bundler
    2              0.000064 au BufNewFile,BufRead Gemfile			setf ruby
                            
                            " Ruby on Rails
    2              0.000152 au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby
                            
                            " Rantfile and Rakefile is like Ruby
    2              0.000174 au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby
                            
                            " S-lang (or shader language, or SmallLisp)
    2              0.000065 au BufNewFile,BufRead *.sl			setf slang
                            
                            " Samba config
    2              0.000063 au BufNewFile,BufRead smb.conf			setf samba
                            
                            " SAS script
    2              0.000073 au BufNewFile,BufRead *.sas			setf sas
                            
                            " Sass
    2              0.000069 au BufNewFile,BufRead *.sass			setf sass
                            
                            " Sather
    2              0.000066 au BufNewFile,BufRead *.sa			setf sather
                            
                            " Scala
    2              0.000063 au BufNewFile,BufRead *.scala			setf scala
                            
                            " SBT - Scala Build Tool
    2              0.000074 au BufNewFile,BufRead *.sbt			setf sbt
                            
                            " Scilab
    2              0.000123 au BufNewFile,BufRead *.sci,*.sce		setf scilab
                            
                            " SCSS
    2              0.000065 au BufNewFile,BufRead *.scss			setf scss
                            
                            " SD: Streaming Descriptors
    2              0.000064 au BufNewFile,BufRead *.sd			setf sd
                            
                            " SDL
    2              0.000123 au BufNewFile,BufRead *.sdl,*.pr		setf sdl
                            
                            " sed
    2              0.000074 au BufNewFile,BufRead *.sed			setf sed
                            
                            " Sieve (RFC 3028)
    2              0.000075 au BufNewFile,BufRead *.siv			setf sieve
                            
                            " Sendmail
    2              0.000070 au BufNewFile,BufRead sendmail.cf		setf sm
                            
                            " Sendmail .mc files are actually m4.  Could also be MS Message text file.
    2              0.000066 au BufNewFile,BufRead *.mc			call s:McSetf()
                            
    2              0.000009 func! s:McSetf()
                              " Rely on the file to start with a comment.
                              " MS message text files use ';', Sendmail files use '#' or 'dnl'
                              for lnum in range(1, min([line("$"), 20]))
                                let line = getline(lnum)
                                if line =~ '^\s*\(#\|dnl\)'
                                  setf m4  " Sendmail .mc file
                                  return
                                elseif line =~ '^\s*;'
                                  setf msmessages  " MS Message text file
                                  return
                                endif
                              endfor
                              setf m4  " Default: Sendmail .mc file
                            endfunc
                            
                            " Services
    2              0.000066 au BufNewFile,BufRead */etc/services		setf services
                            
                            " Service Location config
    2              0.000057 au BufNewFile,BufRead */etc/slp.conf		setf slpconf
                            
                            " Service Location registration
    2              0.000054 au BufNewFile,BufRead */etc/slp.reg		setf slpreg
                            
                            " Service Location SPI
    2              0.000054 au BufNewFile,BufRead */etc/slp.spi		setf slpspi
                            
                            " Setserial config
    2              0.000064 au BufNewFile,BufRead */etc/serial.conf		setf setserial
                            
                            " SGML
    2              0.000106 au BufNewFile,BufRead *.sgm,*.sgml
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
                            	\   setf sgmllnx |
                            	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
                            	\   let b:docbk_type = "sgml" |
                            	\   let b:docbk_ver = 4 |
                            	\   setf docbk |
                            	\ else |
                            	\   setf sgml |
                            	\ endif
                            
                            " SGMLDECL
    2              0.000144 au BufNewFile,BufRead *.decl,*.dcl,*.dec
                            	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
                            	\    setf sgmldecl |
                            	\ endif
                            
                            " SGML catalog file
    2              0.000052 au BufNewFile,BufRead catalog			setf catalog
    2              0.000054 au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')
                            
                            " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
                            " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
    2              0.000364 au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD* call SetFileTypeSH("bash")
    2              0.000094 au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
    2              0.000163 au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
                            
                            " Shell script (Arch Linux) or PHP file (Drupal)
    2              0.000062 au BufNewFile,BufRead *.install
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   call SetFileTypeSH("bash") |
                            	\ endif
                            
                            " Also called from scripts.vim.
    2              0.000007 func! SetFileTypeSH(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              if a:name =~ '\<csh\>'
                                " Some .sh scripts contain #!/bin/csh.
                                call SetFileTypeShell("csh")
                                return
                              elseif a:name =~ '\<tcsh\>'
                                " Some .sh scripts contain #!/bin/tcsh.
                                call SetFileTypeShell("tcsh")
                                return
                              elseif a:name =~ '\<zsh\>'
                                " Some .sh scripts contain #!/bin/zsh.
                                call SetFileTypeShell("zsh")
                                return
                              elseif a:name =~ '\<ksh\>'
                                let b:is_kornshell = 1
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif exists("g:bash_is_sh") || a:name =~ '\<bash\>' || a:name =~ '\<bash2\>'
                                let b:is_bash = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif a:name =~ '\<sh\>'
                                let b:is_sh = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                              endif
                              call SetFileTypeShell("sh")
                            endfunc
                            
                            " For shell-like file types, check for an "exec" command hidden in a comment,
                            " as used for Tcl.
                            " Also called from scripts.vim, thus can't be local to this script.
    2              0.000004 func! SetFileTypeShell(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              let l = 2
                              while l < 20 && l < line("$") && getline(l) =~ '^\s*\(#\|$\)'
                                " Skip empty and comment lines.
                                let l = l + 1
                              endwhile
                              if l < line("$") && getline(l) =~ '\s*exec\s' && getline(l - 1) =~ '^\s*#.*\\$'
                                " Found an "exec" line after a comment with continuation
                                let n = substitute(getline(l),'\s*exec\s\+\([^ ]*/\)\=', '', '')
                                if n =~ '\<tclsh\|\<wish'
                                  setf tcl
                                  return
                                endif
                              endif
                              exe "setf " . a:name
                            endfunc
                            
                            " tcsh scripts
    2              0.000163 au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login	call SetFileTypeShell("tcsh")
                            
                            " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
    2              0.000247 au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
                            
    2              0.000007 func! s:CSH()
                              if exists("g:filetype_csh")
                                call SetFileTypeShell(g:filetype_csh)
                              elseif &shell =~ "tcsh"
                                call SetFileTypeShell("tcsh")
                              else
                                call SetFileTypeShell("csh")
                              endif
                            endfunc
                            
                            " Z-Shell script
    2              0.000123 au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
    2              0.000127 au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
    2              0.000068 au BufNewFile,BufRead *.zsh			setf zsh
                            
                            " Scheme
    2              0.000133 au BufNewFile,BufRead *.scm,*.ss,*.rkt		setf scheme
                            
                            " Screen RC
    2              0.000094 au BufNewFile,BufRead .screenrc,screenrc	setf screen
                            
                            " Simula
    2              0.000065 au BufNewFile,BufRead *.sim			setf simula
                            
                            " SINDA
    2              0.000110 au BufNewFile,BufRead *.sin,*.s85		setf sinda
                            
                            " SiSU
    2              0.000207 au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
    2              0.000123 au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
                            
                            " SKILL
    2              0.000135 au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill
                            
                            " SLRN
    2              0.000069 au BufNewFile,BufRead .slrnrc			setf slrnrc
    2              0.000065 au BufNewFile,BufRead *.score			setf slrnsc
                            
                            " Smalltalk (and TeX)
    2              0.000059 au BufNewFile,BufRead *.st			setf st
    2              0.000071 au BufNewFile,BufRead *.cls
                            	\ if getline(1) =~ '^%' |
                            	\  setf tex |
                            	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
                            	\  setf rexx |
                            	\ else |
                            	\  setf st |
                            	\ endif
                            
                            " Smarty templates
    2              0.000068 au BufNewFile,BufRead *.tpl			setf smarty
                            
                            " SMIL or XML
    2              0.000079 au BufNewFile,BufRead *.smil
                            	\ if getline(1) =~ '<?\s*xml.*?>' |
                            	\   setf xml |
                            	\ else |
                            	\   setf smil |
                            	\ endif
                            
                            " SMIL or SNMP MIB file
    2              0.000074 au BufNewFile,BufRead *.smi
                            	\ if getline(1) =~ '\<smil\>' |
                            	\   setf smil |
                            	\ else |
                            	\   setf mib |
                            	\ endif
                            
                            " SMITH
    2              0.000098 au BufNewFile,BufRead *.smt,*.smith		setf smith
                            
                            " Snobol4 and spitbol
    2              0.000108 au BufNewFile,BufRead *.sno,*.spt		setf snobol4
                            
                            " SNMP MIB files
    2              0.000099 au BufNewFile,BufRead *.mib,*.my		setf mib
                            
                            " Snort Configuration
    2              0.000143 au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
    2              0.000061 au BufNewFile,BufRead *.rules			call s:FTRules()
                            
    2              0.000016 let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
    2              0.000007 func! s:FTRules()
                              let path = expand('<amatch>:p')
                              if path =~ '^/\(etc/udev/\%(rules\.d/\)\=.*\.rules\|lib/udev/\%(rules\.d/\)\=.*\.rules\)$'
                                setf udevrules
                                return
                              endif
                              if path =~ '^/etc/ufw/'
                                setf conf  " Better than hog
                                return
                              endif
                              if path =~ '^/\(etc\|usr/share\)/polkit-1/rules\.d'
                                setf javascript
                                return
                              endif
                              try
                                let config_lines = readfile('/etc/udev/udev.conf')
                              catch /^Vim\%((\a\+)\)\=:E484/
                                setf hog
                                return
                              endtry
                              let dir = expand('<amatch>:p:h')
                              for line in config_lines
                                if line =~ s:ft_rules_udev_rules_pattern
                                  let udev_rules = substitute(line, s:ft_rules_udev_rules_pattern, '\1', "")
                                  if dir == udev_rules
                            	setf udevrules
                                  endif
                                  break
                                endif
                              endfor
                              setf hog
                            endfunc
                            
                            
                            " Spec (Linux RPM)
    2              0.000074 au BufNewFile,BufRead *.spec			setf spec
                            
                            " Speedup (AspenTech plant simulator)
    2              0.000139 au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup
                            
                            " Slice
    2              0.000077 au BufNewFile,BufRead *.ice			setf slice
                            
                            " Spice
    2              0.000095 au BufNewFile,BufRead *.sp,*.spice		setf spice
                            
                            " Spyce
    2              0.000110 au BufNewFile,BufRead *.spy,*.spi		setf spyce
                            
                            " Squid
    2              0.000061 au BufNewFile,BufRead squid.conf		setf squid
                            
                            " SQL for Oracle Designer
    2              0.000240 au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql
                            
                            " SQL
    2              0.000071 au BufNewFile,BufRead *.sql			call s:SQL()
                            
    2              0.000007 func! s:SQL()
                              if exists("g:filetype_sql")
                                exe "setf " . g:filetype_sql
                              else
                                setf sql
                              endif
                            endfunc
                            
                            " SQLJ
    2              0.000077 au BufNewFile,BufRead *.sqlj			setf sqlj
                            
                            " SQR
    2              0.000118 au BufNewFile,BufRead *.sqr,*.sqi		setf sqr
                            
                            " OpenSSH configuration
    2              0.000097 au BufNewFile,BufRead ssh_config,*/.ssh/config	setf sshconfig
                            
                            " OpenSSH server configuration
    2              0.000060 au BufNewFile,BufRead sshd_config		setf sshdconfig
                            
                            " Stata
    2              0.000178 au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata	setf stata
                            " Also *.class, but not when it's a Java bytecode file
    2              0.000066 au BufNewFile,BufRead *.class
                            	\ if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
                            
                            " SMCL
    2              0.000140 au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl
                            
                            " Stored Procedures
    2              0.000069 au BufNewFile,BufRead *.stp			setf stp
                            
                            " Standard ML
    2              0.000072 au BufNewFile,BufRead *.sml			setf sml
                            
                            " Sratus VOS command macro
    2              0.000062 au BufNewFile,BufRead *.cm			setf voscm
                            
                            " Sysctl
    2              0.000100 au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl
                            
                            " Systemd unit files
    2              0.000081 au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}	setf systemd
                            
                            " Synopsys Design Constraints
    2              0.000073 au BufNewFile,BufRead *.sdc			setf sdc
                            
                            " Sudoers
    2              0.000113 au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers
                            
                            " SVG (Scalable Vector Graphics)
    2              0.000076 au BufNewFile,BufRead *.svg			setf svg
                            
                            " If the file has an extension of 't' and is in a directory 't' or 'xt' then
                            " it is almost certainly a Perl test file.
                            " If the first line starts with '#' and contains 'perl' it's probably a Perl
                            " file.
                            " (Slow test) If a file contains a 'use' statement then it is almost certainly
                            " a Perl file.
    2              0.000008 func! s:FTperl()
                              let dirname = expand("%:p:h:t")
                              if expand("%:e") == 't' && (dirname == 't' || dirname == 'xt')
                                setf perl
                                return 1
                              endif
                              if getline(1)[0] == '#' && getline(1) =~ 'perl'
                                setf perl
                                return 1
                              endif
                              if search('^use\s\s*\k', 'nc', 30)
                                setf perl
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Tads (or Nroff or Perl test file)
    2              0.000073 au BufNewFile,BufRead *.t
                            	\ if !s:FTnroff() && !s:FTperl() | setf tads | endif
                            
                            " Tags
    2              0.000065 au BufNewFile,BufRead tags			setf tags
                            
                            " TAK
    2              0.000074 au BufNewFile,BufRead *.tak			setf tak
                            
                            " Task
    2              0.000060 au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
    2              0.000066 au BufRead,BufNewFile *.task			setf taskedit
                            
                            " Tcl (JACL too)
    2              0.000221 au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl	setf tcl
                            
                            " TealInfo
    2              0.000107 au BufNewFile,BufRead *.tli			setf tli
                            
                            " Telix Salt
    2              0.000087 au BufNewFile,BufRead *.slt			setf tsalt
                            
                            " Tera Term Language
    2              0.000075 au BufRead,BufNewFile *.ttl			setf teraterm
                            
                            " Terminfo
    2              0.000058 au BufNewFile,BufRead *.ti			setf terminfo
                            
                            " TeX
    2              0.000285 au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
    2              0.000076 au BufNewFile,BufRead *.tex			call s:FTtex()
                            
                            " Choose context, plaintex, or tex (LaTeX) based on these rules:
                            " 1. Check the first line of the file for "%&<format>".
                            " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
                            " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
    2              0.000007 func! s:FTtex()
                              let firstline = getline(1)
                              if firstline =~ '^%&\s*\a\+'
                                let format = tolower(matchstr(firstline, '\a\+'))
                                let format = substitute(format, 'pdf', '', '')
                                if format == 'tex'
                                  let format = 'latex'
                                elseif format == 'plaintex'
                                  let format = 'plain'
                                endif
                              else
                                " Default value, may be changed later:
                                let format = exists("g:tex_flavor") ? g:tex_flavor : 'plain'
                                " Save position, go to the top of the file, find first non-comment line.
                                let save_cursor = getpos('.')
                                call cursor(1,1)
                                let firstNC = search('^\s*[^[:space:]%]', 'c', 1000)
                                if firstNC " Check the next thousand lines for a LaTeX or ConTeXt keyword.
                                  let lpat = 'documentclass\>\|usepackage\>\|begin{\|newcommand\>\|renewcommand\>'
                                  let cpat = 'start\a\+\|setup\a\+\|usemodule\|enablemode\|enableregime\|setvariables\|useencoding\|usesymbols\|stelle\a\+\|verwende\a\+\|stel\a\+\|gebruik\a\+\|usa\a\+\|imposta\a\+\|regle\a\+\|utilisemodule\>'
                                  let kwline = search('^\s*\\\%(' . lpat . '\)\|^\s*\\\(' . cpat . '\)',
                            			      \ 'cnp', firstNC + 1000)
                                  if kwline == 1	" lpat matched
                            	let format = 'latex'
                                  elseif kwline == 2	" cpat matched
                            	let format = 'context'
                                  endif		" If neither matched, keep default set above.
                                  " let lline = search('^\s*\\\%(' . lpat . '\)', 'cn', firstNC + 1000)
                                  " let cline = search('^\s*\\\%(' . cpat . '\)', 'cn', firstNC + 1000)
                                  " if cline > 0
                                  "   let format = 'context'
                                  " endif
                                  " if lline > 0 && (cline == 0 || cline > lline)
                                  "   let format = 'tex'
                                  " endif
                                endif " firstNC
                                call setpos('.', save_cursor)
                              endif " firstline =~ '^%&\s*\a\+'
                            
                              " Translation from formats to file types.  TODO:  add AMSTeX, RevTex, others?
                              if format == 'plain'
                                setf plaintex
                              elseif format == 'context'
                                setf context
                              else " probably LaTeX
                                setf tex
                              endif
                              return
                            endfunc
                            
                            " ConTeXt
    2              0.000212 au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv,*.mkvi   setf context
                            
                            " Texinfo
    2              0.000167 au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo
                            
                            " TeX configuration
    2              0.000069 au BufNewFile,BufRead texmf.cnf			setf texmf
                            
                            " Tidy config
    2              0.000102 au BufNewFile,BufRead .tidyrc,tidyrc		setf tidy
                            
                            " TF mud client
    2              0.000179 au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf
                            
                            " tmux configuration
    2              0.000072 au BufNewFile,BufRead {.,}tmux*.conf		setf tmux
                            
                            " TPP - Text Presentation Program
    2              0.000097 au BufNewFile,BufReadPost *.tpp			setf tpp
                            
                            " Treetop
    2              0.000064 au BufRead,BufNewFile *.treetop			setf treetop
                            
                            " Trustees
    2              0.000064 au BufNewFile,BufRead trustees.conf		setf trustees
                            
                            " TSS - Geometry
    2              0.000088 au BufNewFile,BufReadPost *.tssgm		setf tssgm
                            
                            " TSS - Optics
    2              0.000072 au BufNewFile,BufReadPost *.tssop		setf tssop
                            
                            " TSS - Command Line (temporary)
    2              0.000080 au BufNewFile,BufReadPost *.tsscl		setf tsscl
                            
                            " TWIG files
    2              0.000091 au BufNewFile,BufReadPost *.twig		setf twig
                            
                            " Motif UIT/UIL files
    2              0.000123 au BufNewFile,BufRead *.uit,*.uil		setf uil
                            
                            " Udev conf
    2              0.000072 au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf
                            
                            " Udev permissions
    2              0.000095 au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
                            "
                            " Udev symlinks config
    2              0.000075 au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh
                            
                            " UnrealScript
    2              0.000069 au BufNewFile,BufRead *.uc			setf uc
                            
                            " Updatedb
    2              0.000087 au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb
                            
                            " Upstart (init(8)) config files
    2              0.000087 au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
    2              0.000079 au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
    2              0.000111 au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
    2              0.000108 au BufNewFile,BufRead */.init/*.conf,*/.init/*.override	       setf upstart
    2              0.000071 au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
    2              0.000073 au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart
                            
                            " Vera
    2              0.000162 au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera
                            
                            " Verilog HDL
    2              0.000065 au BufNewFile,BufRead *.v			setf verilog
                            
                            " Verilog-AMS HDL
    2              0.000118 au BufNewFile,BufRead *.va,*.vams		setf verilogams
                            
                            " SystemVerilog
    2              0.000127 au BufNewFile,BufRead *.sv,*.svh		setf systemverilog
                            
                            " VHDL
    2              0.000264 au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
    2              0.000075 au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
                            
                            " Vim script
    2              0.000217 au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim
                            
                            " Viminfo file
    2              0.000114 au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo
                            
                            " Virata Config Script File or Drupal module
    2              0.000151 au BufRead,BufNewFile *.hw,*.module,*.pkg
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   setf virata |
                            	\ endif
                            
                            " Visual Basic (also uses *.bas) or FORM
    2              0.000081 au BufNewFile,BufRead *.frm			call s:FTVB("form")
                            
                            " SaxBasic is close to Visual Basic
    2              0.000082 au BufNewFile,BufRead *.sba			setf vb
                            
                            " Vgrindefs file
    2              0.000071 au BufNewFile,BufRead vgrindefs			setf vgrindefs
                            
                            " VRML V1.0c
    2              0.000080 au BufNewFile,BufRead *.wrl			setf vrml
                            
                            " Vroom (vim testing and executable documentation)
    2              0.000083 au BufNewFile,BufRead *.vroom			setf vroom
                            
                            " Webmacro
    2              0.000091 au BufNewFile,BufRead *.wm			setf webmacro
                            
                            " Wget config
    2              0.000139 au BufNewFile,BufRead .wgetrc,wgetrc		setf wget
                            
                            " Website MetaLanguage
    2              0.000097 au BufNewFile,BufRead *.wml			setf wml
                            
                            " Winbatch
    2              0.000098 au BufNewFile,BufRead *.wbt			setf winbatch
                            
                            " WSML
    2              0.000086 au BufNewFile,BufRead *.wsml			setf wsml
                            
                            " WvDial
    2              0.000132 au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial
                            
                            " CVS RC file
    2              0.000090 au BufNewFile,BufRead .cvsrc			setf cvsrc
                            
                            " CVS commit file
    2              0.000085 au BufNewFile,BufRead cvs\d\+			setf cvs
                            
                            " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
                            " lines in a WEB file).
    2              0.000093 au BufNewFile,BufRead *.web
                            	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
                            	\   setf web |
                            	\ else |
                            	\   setf winbatch |
                            	\ endif
                            
                            " Windows Scripting Host and Windows Script Component
    2              0.000076 au BufNewFile,BufRead *.ws[fc]			setf wsh
                            
                            " XHTML
    2              0.000129 au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml
                            
                            " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
    2              0.000012 au BufEnter *.xpm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ else |
                            	\   setf xpm |
                            	\ endif
    2              0.000007 au BufEnter *.xpm2				setf xpm2
                            
                            " XFree86 config
    2              0.000079 au BufNewFile,BufRead XF86Config
                            	\ if getline(1) =~ '\<XConfigurator\>' |
                            	\   let b:xf86conf_xfree86_version = 3 |
                            	\ endif |
                            	\ setf xf86conf
    2              0.000081 au BufNewFile,BufRead */xorg.conf.d/*.conf
                            	\ let b:xf86conf_xfree86_version = 4 |
                            	\ setf xf86conf
                            
                            " Xorg config
    2              0.000113 au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf
                            
                            " Xinetd conf
    2              0.000074 au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd
                            
                            " XS Perl extension interface language
    2              0.000073 au BufNewFile,BufRead *.xs			setf xs
                            
                            " X resources file
    2              0.000241 au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
                            
                            " Xmath
    2              0.000138 au BufNewFile,BufRead *.msc,*.msf		setf xmath
    2              0.000080 au BufNewFile,BufRead *.ms
                            	\ if !s:FTnroff() | setf xmath | endif
                            
                            " XML  specific variants: docbk and xbl
    2              0.000083 au BufNewFile,BufRead *.xml			call s:FTxml()
                            
    2              0.000010 func! s:FTxml()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                " DocBook 4 or DocBook 5.
                                let is_docbook4 = line =~ '<!DOCTYPE.*DocBook'
                                let is_docbook5 = line =~ ' xmlns="http://docbook.org/ns/docbook"'
                                if is_docbook4 || is_docbook5
                                  let b:docbk_type = "xml"
                                  if is_docbook5
                            	let b:docbk_ver = 5
                                  else
                            	let b:docbk_ver = 4
                                  endif
                                  setf docbk
                                  return
                                endif
                                if line =~ 'xmlns:xbl="http://www.mozilla.org/xbl"'
                                  setf xbl
                                  return
                                endif
                                let n += 1
                              endwhile
                              setf xml
                            endfunc
                            
                            " XMI (holding UML models) is also XML
    2              0.000092 au BufNewFile,BufRead *.xmi			setf xml
                            
                            " CSPROJ files are Visual Studio.NET's XML-based project config files
    2              0.000140 au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml
                            
                            " Qt Linguist translation source and Qt User Interface Files are XML
    2              0.000120 au BufNewFile,BufRead *.ts,*.ui			setf xml
                            
                            " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
    2              0.000083 au BufNewFile,BufRead *.tpm			setf xml
                            
                            " Xdg menus
    2              0.000084 au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml
                            
                            " ATI graphics driver configuration
    2              0.000086 au BufNewFile,BufRead fglrxrc			setf xml
                            
                            " XLIFF (XML Localisation Interchange File Format) is also XML
    2              0.000086 au BufNewFile,BufRead *.xlf			setf xml
    2              0.000076 au BufNewFile,BufRead *.xliff			setf xml
                            
                            " XML User Interface Language
    2              0.000083 au BufNewFile,BufRead *.xul			setf xml
                            
                            " X11 xmodmap (also see below)
    2              0.000075 au BufNewFile,BufRead *Xmodmap			setf xmodmap
                            
                            " Xquery
    2              0.000266 au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery
                            
                            " XSD
    2              0.000138 au BufNewFile,BufRead *.xsd			setf xsd
                            
                            " Xslt
    2              0.000200 au BufNewFile,BufRead *.xsl,*.xslt		setf xslt
                            
                            " Yacc
    2              0.000188 au BufNewFile,BufRead *.yy,*.yxx,*.y++		setf yacc
                            
                            " Yacc or racc
    2              0.000074 au BufNewFile,BufRead *.y			call s:FTy()
                            
    2              0.000009 func! s:FTy()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                if line =~ '^\s*%'
                                  setf yacc
                                  return
                                endif
                                if getline(n) =~ '^\s*\(#\|class\>\)' && getline(n) !~ '^\s*#\s*include'
                                  setf racc
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf yacc
                            endfunc
                            
                            
                            " Yaml
    2              0.000139 au BufNewFile,BufRead *.yaml,*.yml		setf yaml
                            
                            " yum conf (close enough to dosini)
    2              0.000080 au BufNewFile,BufRead */etc/yum.conf		setf dosini
                            
                            " Zimbu
    2              0.000076 au BufNewFile,BufRead *.zu			setf zimbu
                            " Zimbu Templates
    2              0.000093 au BufNewFile,BufRead *.zut			setf zimbutempl
                            
                            " Zope
                            "   dtml (zope dynamic template markup language), pt (zope page template),
                            "   cpt (zope form controller page template)
    2              0.000200 au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call s:FThtml()
                            "   zsql (zope sql method)
    2              0.000088 au BufNewFile,BufRead *.zsql			call s:SQL()
                            
                            " Z80 assembler asz80
    2              0.000100 au BufNewFile,BufRead *.z8a			setf z8a
                            
    2              0.000006 augroup END
                            
                            
                            " Source the user-specified filetype file, for backwards compatibility with
                            " Vim 5.x.
    2              0.000021 if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
                              execute "source " . myfiletypefile
                            endif
                            
                            
                            " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
                            " when there are no matching file name extensions.
                            " Don't do this for compressed files.
    2              0.000003 augroup filetypedetect
    2              0.000087 au BufNewFile,BufRead *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\ | runtime! scripts.vim | endif
    2              0.000018 au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
                            
                            
                            " Extra checks for when no filetype has been detected now.  Mostly used for
                            " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
                            " script file.
                            " Most of these should call s:StarSetf() to avoid names ending in .gz and the
                            " like are used.
                            
                            " More Apache config files
    2              0.000266 au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
    2              0.000274 au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')
                            
                            " Asterisk config file
    2              0.000081 au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
    2              0.000088 au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
                            
                            " Bazaar version control
    2              0.000080 au BufNewFile,BufRead bzr_log.*			setf bzr
                            
                            " Bazel build file
    2              0.000009 if !has("fname_case")
                              au BufNewFile,BufRead BUILD			setf bzl
                            endif
                            
                            " BIND zone
    2              0.000127 au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
                            
                            " Calendar
    2              0.000185 au BufNewFile,BufRead */.calendar/*,
                            	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
                            	\					call s:StarSetf('calendar')
                            
                            " Changelog
    2              0.000095 au BufNewFile,BufRead [cC]hange[lL]og*
                            	\ if getline(1) =~ '; urgency='
                            	\|  call s:StarSetf('debchangelog')
                            	\|else
                            	\|  call s:StarSetf('changelog')
                            	\|endif
                            
                            " Crontab
    2              0.000173 au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')
                            
                            " dnsmasq(8) configuration
    2              0.000087 au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')
                            
                            " Dracula
    2              0.000095 au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')
                            
                            " Fvwm
    2              0.000091 au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
    2              0.000132 au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
                            	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
    2              0.000114 au BufNewFile,BufRead *fvwm2rc*
                            	\ if expand("<afile>:e") == "m4"
                            	\|  call s:StarSetf('fvwm2m4')
                            	\|else
                            	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
                            	\|endif
                            
                            " Gedcom
    2              0.000098 au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')
                            
                            " GTK RC
    2              0.000145 au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')
                            
                            " Jam
    2              0.000155 au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')
                            
                            " Jargon
    2              0.000109 au! BufNewFile,BufRead *jarg*
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
                            	\|  call s:StarSetf('jargon')
                            	\|endif
                            
                            " Kconfig
    2              0.000103 au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')
                            
                            " Lilo: Linux loader
    2              0.000094 au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')
                            
                            " Logcheck
    2              0.000097 au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')
                            
                            " Makefile
    2              0.000095 au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')
                            
                            " Ruby Makefile
    2              0.000091 au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')
                            
                            " Mail (also matches muttrc.vim, so this is below the other checks)
    2              0.000113 au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}	setf mail
                            
    2              0.000087 au BufNewFile,BufRead reportbug-*		call s:StarSetf('mail')
                            
                            " Modconf
    2              0.000088 au BufNewFile,BufRead */etc/modutils/*
                            	\ if executable(expand("<afile>")) != 1
                            	\|  call s:StarSetf('modconf')
                            	\|endif
    2              0.000085 au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')
                            
                            " Mutt setup file
    2              0.000143 au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
    2              0.000141 au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')
                            
                            " Nroff macros
    2              0.000086 au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')
                            
                            " OpenBSD hostname.if
    2              0.000088 au BufNewFile,BufRead /etc/hostname.*		call s:StarSetf('config')
                            
                            " Pam conf
    2              0.000086 au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')
                            
                            " Printcap and Termcap
    2              0.000088 au BufNewFile,BufRead *printcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
                            	\|endif
    2              0.000089 au BufNewFile,BufRead *termcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
                            	\|endif
                            
                            " ReDIF
                            " Only used when the .rdf file was not detected to be XML.
    2              0.000081 au BufRead,BufNewFile *.rdf			call s:Redif()
    2              0.000011 func! s:Redif()
                              let lnum = 1
                              while lnum <= 5 && lnum < line('$')
                                if getline(lnum) =~ "^\ctemplate-type:"
                                  setf redif
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                            endfunc
                            
                            " Remind
    2              0.000079 au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')
                            
                            " Vim script
    2              0.000086 au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')
                            
                            " Subversion commit file
    2              0.000086 au BufNewFile,BufRead svn-commit*.tmp		setf svn
                            
                            " X resources file
    2              0.000174 au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
                            
                            " XFree86 config
    2              0.000085 au BufNewFile,BufRead XF86Config-4*
                            	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
    2              0.000090 au BufNewFile,BufRead XF86Config*
                            	\ if getline(1) =~ '\<XConfigurator\>'
                            	\|  let b:xf86conf_xfree86_version = 3
                            	\|endif
                            	\|call s:StarSetf('xf86conf')
                            
                            " X11 xmodmap
    2              0.000085 au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')
                            
                            " Xinetd conf
    2              0.000085 au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')
                            
                            " yum conf (close enough to dosini)
    2              0.000084 au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')
                            
                            " Z-Shell script
    2              0.000145 au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
                            
                            
                            " Plain text files, needs to be far down to not override others.  This avoids
                            " the "conf" type being used if there is a line starting with '#'.
    2              0.000135 au BufNewFile,BufRead *.text,README		setf text
                            
                            " Help files match *.txt but should have a last line that is a modeline.
    2              0.000103 au BufNewFile,BufRead *.txt	
                            	\  if getline('$') !~ 'vim:.*ft=help'
                            	\|   setf text
                            	\| endif
                            
                            
                            " Use the filetype detect plugins.  They may overrule any of the previously
                            " detected filetypes.
    2              0.031285 runtime! ftdetect/*.vim
                            
                            " NOTE: The above command could have ended the filetypedetect autocmd group
                            " and started another one. Let's make sure it has ended to get to a consistent
                            " state.
    2              0.000005 augroup END
                            
                            " Generic configuration file. Use FALLBACK, it's just guessing!
    2              0.000109 au filetypedetect BufNewFile,BufRead,StdinReadPost *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
                            	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
                            	\   setf FALLBACK conf |
                            	\ endif
                            
                            
                            " If the GUI is already running, may still need to install the Syntax menu.
                            " Don't do it when the 'M' flag is included in 'guioptions'.
    2              0.000042 if has("menu") && has("gui_running")
                                  \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
                              source <sfile>:p:h/menu.vim
                            endif
                            
                            " Function called for testing all functions defined here.  These are
                            " script-local, thus need to be executed here.
                            " Returns a string with error messages (hopefully empty).
    2              0.000007 func! TestFiletypeFuncs(testlist)
                              let output = ''
                              for f in a:testlist
                                try
                                  exe f
                                catch
                                  let output = output . "\n" . f . ": " . v:exception
                                endtry
                              endfor
                              return output
                            endfunc
                            
                            " Restore 'cpoptions'
    2              0.000052 let &cpo = s:cpo_save
    2              0.000015 unlet s:cpo_save

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/ftplugin.vim
Sourced 2 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2006 Apr 30
                            
    2              0.000025 if exists("did_load_ftplugin")
    1              0.000004   finish
                            endif
    1              0.000006 let did_load_ftplugin = 1
                            
    1              0.000003 augroup filetypeplugin
    1              0.000016   au FileType * call s:LoadFTPlugin()
                            
    1              0.000007   func! s:LoadFTPlugin()
                                if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
                                let s = expand("<amatch>")
                                if s != ""
                                  if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
                                  for name in split(s, '\.')
                            	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                  endfor
                                endif
                              endfunc
    1              0.000003 augroup END

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/indent.vim
Sourced 2 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Feb 22
                            
    2              0.000014 if exists("did_indent_on")
    1              0.000002   finish
                            endif
    1              0.000003 let did_indent_on = 1
                            
    1              0.000002 augroup filetypeindent
    1              0.000006   au FileType * call s:LoadIndent()
    1              0.000004   func! s:LoadIndent()
                                if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
                                let s = expand("<amatch>")
                                if s != ""
                                  if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
                                  for name in split(s, '\.')
                            	exe 'runtime! indent/' . name . '.vim'
                                  endfor
                                endif
                              endfunc
    1              0.000003 augroup END

SCRIPT  /home/user/fbarotjr/.vim/autoload/plug.vim
Sourced 1 time
Total time:   0.001957
 Self time:   0.001874

count  total (s)   self (s)
                            " vim-plug: Vim plugin manager
                            " ============================
                            "
                            " Download plug.vim and put it in ~/.vim/autoload
                            "
                            "   curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
                            "     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
                            "
                            " Edit your .vimrc
                            "
                            "   call plug#begin('~/.vim/plugged')
                            "
                            "   " Make sure you use single quotes
                            "
                            "   " Shorthand notation; fetches https://github.com/junegunn/vim-easy-align
                            "   Plug 'junegunn/vim-easy-align'
                            "
                            "   " Any valid git URL is allowed
                            "   Plug 'https://github.com/junegunn/vim-github-dashboard.git'
                            "
                            "   " Multiple Plug commands can be written in a single line using | separators
                            "   Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'
                            "
                            "   " On-demand loading
                            "   Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeToggle' }
                            "   Plug 'tpope/vim-fireplace', { 'for': 'clojure' }
                            "
                            "   " Using a non-master branch
                            "   Plug 'rdnetto/YCM-Generator', { 'branch': 'stable' }
                            "
                            "   " Using a tagged release; wildcard allowed (requires git 1.9.2 or above)
                            "   Plug 'fatih/vim-go', { 'tag': '*' }
                            "
                            "   " Plugin options
                            "   Plug 'nsf/gocode', { 'tag': 'v.20150303', 'rtp': 'vim' }
                            "
                            "   " Plugin outside ~/.vim/plugged with post-update hook
                            "   Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
                            "
                            "   " Unmanaged plugin (manually installed and updated)
                            "   Plug '~/my-prototype-plugin'
                            "
                            "   " Initialize plugin system
                            "   call plug#end()
                            "
                            " Then reload .vimrc and :PlugInstall to install plugins.
                            "
                            " Plug options:
                            "
                            "| Option                  | Description                                      |
                            "| ----------------------- | ------------------------------------------------ |
                            "| `branch`/`tag`/`commit` | Branch/tag/commit of the repository to use       |
                            "| `rtp`                   | Subdirectory that contains Vim plugin            |
                            "| `dir`                   | Custom directory for the plugin                  |
                            "| `as`                    | Use different name for the plugin                |
                            "| `do`                    | Post-update hook (string or funcref)             |
                            "| `on`                    | On-demand loading: Commands or `<Plug>`-mappings |
                            "| `for`                   | On-demand loading: File types                    |
                            "| `frozen`                | Do not update unless explicitly specified        |
                            "
                            " More information: https://github.com/junegunn/vim-plug
                            "
                            "
                            " Copyright (c) 2017 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000006 if exists('g:loaded_plug')
                              finish
                            endif
    1              0.000003 let g:loaded_plug = 1
                            
    1              0.000020 let s:cpo_save = &cpo
    1              0.000013 set cpo&vim
                            
    1              0.000003 let s:plug_src = 'https://github.com/junegunn/vim-plug.git'
    1              0.000008 let s:plug_tab = get(s:, 'plug_tab', -1)
    1              0.000003 let s:plug_buf = get(s:, 'plug_buf', -1)
    1              0.000008 let s:mac_gui = has('gui_macvim') && has('gui_running')
    1              0.000006 let s:is_win = has('win32') || has('win64')
    1              0.000007 let s:nvim = has('nvim-0.2') || (has('nvim') && exists('*jobwait') && !s:is_win)
    1              0.000010 let s:vim8 = has('patch-8.0.0039') && exists('*job_start')
    1              0.000037 let s:me = resolve(expand('<sfile>:p'))
    1              0.000005 let s:base_spec = { 'branch': 'master', 'frozen': 0 }
    1              0.000017 let s:TYPE = {
                            \   'string':  type(''),
                            \   'list':    type([]),
                            \   'dict':    type({}),
                            \   'funcref': type(function('call'))
                            \ }
    1              0.000004 let s:loaded = get(s:, 'loaded', {})
    1              0.000003 let s:triggers = get(s:, 'triggers', {})
                            
    1              0.000003 function! plug#begin(...)
                              if a:0 > 0
                                let s:plug_home_org = a:1
                                let home = s:path(fnamemodify(expand(a:1), ':p'))
                              elseif exists('g:plug_home')
                                let home = s:path(g:plug_home)
                              elseif !empty(&rtp)
                                let home = s:path(split(&rtp, ',')[0]) . '/plugged'
                              else
                                return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')
                              endif
                              if fnamemodify(home, ':t') ==# 'plugin' && fnamemodify(home, ':h') ==# s:first_rtp
                                return s:err('Invalid plug home. '.home.' is a standard Vim runtime path and is not allowed.')
                              endif
                            
                              let g:plug_home = home
                              let g:plugs = {}
                              let g:plugs_order = []
                              let s:triggers = {}
                            
                              call s:define_commands()
                              return 1
                            endfunction
                            
    1              0.000003 function! s:define_commands()
                              command! -nargs=+ -bar Plug call plug#(<args>)
                              if !executable('git')
                                return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')
                              endif
                              command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])
                              command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])
                              command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)
                              command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif
                              command! -nargs=0 -bar PlugStatus  call s:status()
                              command! -nargs=0 -bar PlugDiff    call s:diff()
                              command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)
                            endfunction
                            
    1              0.000002 function! s:to_a(v)
                              return type(a:v) == s:TYPE.list ? a:v : [a:v]
                            endfunction
                            
    1              0.000002 function! s:to_s(v)
                              return type(a:v) == s:TYPE.string ? a:v : join(a:v, "\n") . "\n"
                            endfunction
                            
    1              0.000002 function! s:glob(from, pattern)
                              return s:lines(globpath(a:from, a:pattern))
                            endfunction
                            
    1              0.000002 function! s:source(from, ...)
                              let found = 0
                              for pattern in a:000
                                for vim in s:glob(a:from, pattern)
                                  execute 'source' s:esc(vim)
                                  let found = 1
                                endfor
                              endfor
                              return found
                            endfunction
                            
    1              0.000003 function! s:assoc(dict, key, val)
                              let a:dict[a:key] = add(get(a:dict, a:key, []), a:val)
                            endfunction
                            
    1              0.000001 function! s:ask(message, ...)
                              call inputsave()
                              echohl WarningMsg
                              let answer = input(a:message.(a:0 ? ' (y/N/a) ' : ' (y/N) '))
                              echohl None
                              call inputrestore()
                              echo "\r"
                              return (a:0 && answer =~? '^a') ? 2 : (answer =~? '^y') ? 1 : 0
                            endfunction
                            
    1              0.000002 function! s:ask_no_interrupt(...)
                              try
                                return call('s:ask', a:000)
                              catch
                                return 0
                              endtry
                            endfunction
                            
    1              0.000002 function! plug#end()
                              if !exists('g:plugs')
                                return s:err('Call plug#begin() first')
                              endif
                            
                              if exists('#PlugLOD')
                                augroup PlugLOD
                                  autocmd!
                                augroup END
                                augroup! PlugLOD
                              endif
                              let lod = { 'ft': {}, 'map': {}, 'cmd': {} }
                            
                              if exists('g:did_load_filetypes')
                                filetype off
                              endif
                              for name in g:plugs_order
                                if !has_key(g:plugs, name)
                                  continue
                                endif
                                let plug = g:plugs[name]
                                if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
                                  let s:loaded[name] = 1
                                  continue
                                endif
                            
                                if has_key(plug, 'on')
                                  let s:triggers[name] = { 'map': [], 'cmd': [] }
                                  for cmd in s:to_a(plug.on)
                                    if cmd =~? '^<Plug>.\+'
                                      if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))
                                        call s:assoc(lod.map, cmd, name)
                                      endif
                                      call add(s:triggers[name].map, cmd)
                                    elseif cmd =~# '^[A-Z]'
                                      let cmd = substitute(cmd, '!*$', '', '')
                                      if exists(':'.cmd) != 2
                                        call s:assoc(lod.cmd, cmd, name)
                                      endif
                                      call add(s:triggers[name].cmd, cmd)
                                    else
                                      call s:err('Invalid `on` option: '.cmd.
                                      \ '. Should start with an uppercase letter or `<Plug>`.')
                                    endif
                                  endfor
                                endif
                            
                                if has_key(plug, 'for')
                                  let types = s:to_a(plug.for)
                                  if !empty(types)
                                    augroup filetypedetect
                                    call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')
                                    augroup END
                                  endif
                                  for type in types
                                    call s:assoc(lod.ft, type, name)
                                  endfor
                                endif
                              endfor
                            
                              for [cmd, names] in items(lod.cmd)
                                execute printf(
                                \ 'command! -nargs=* -range -bang -complete=file %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)',
                                \ cmd, string(cmd), string(names))
                              endfor
                            
                              for [map, names] in items(lod.map)
                                for [mode, map_prefix, key_prefix] in
                                      \ [['i', '<C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]
                                  execute printf(
                                  \ '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, %s, "%s")<CR>',
                                  \ mode, map, map_prefix, string(map), string(names), mode != 'i', key_prefix)
                                endfor
                              endfor
                            
                              for [ft, names] in items(lod.ft)
                                augroup PlugLOD
                                  execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)',
                                        \ ft, string(ft), string(names))
                                augroup END
                              endfor
                            
                              call s:reorg_rtp()
                              filetype plugin indent on
                              if has('vim_starting')
                                if has('syntax') && !exists('g:syntax_on')
                                  syntax enable
                                end
                              else
                                call s:reload_plugins()
                              endif
                            endfunction
                            
    1              0.000002 function! s:loaded_names()
                              return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')
                            endfunction
                            
    1              0.000002 function! s:load_plugin(spec)
                              call s:source(s:rtp(a:spec), 'plugin/**/*.vim', 'after/plugin/**/*.vim')
                            endfunction
                            
    1              0.000001 function! s:reload_plugins()
                              for name in s:loaded_names()
                                call s:load_plugin(g:plugs[name])
                              endfor
                            endfunction
                            
    1              0.000002 function! s:trim(str)
                              return substitute(a:str, '[\/]\+$', '', '')
                            endfunction
                            
    1              0.000003 function! s:version_requirement(val, min)
                              for idx in range(0, len(a:min) - 1)
                                let v = get(a:val, idx, 0)
                                if     v < a:min[idx] | return 0
                                elseif v > a:min[idx] | return 1
                                endif
                              endfor
                              return 1
                            endfunction
                            
    1              0.000002 function! s:git_version_requirement(...)
                              if !exists('s:git_version')
                                let s:git_version = map(split(split(s:system('git --version'))[2], '\.'), 'str2nr(v:val)')
                              endif
                              return s:version_requirement(s:git_version, a:000)
                            endfunction
                            
    1              0.000002 function! s:progress_opt(base)
                              return a:base && !s:is_win &&
                                    \ s:git_version_requirement(1, 7, 1) ? '--progress' : ''
                            endfunction
                            
    1              0.000002 if s:is_win
                              function! s:rtp(spec)
                                return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
                              endfunction
                            
                              function! s:path(path)
                                return s:trim(substitute(a:path, '/', '\', 'g'))
                              endfunction
                            
                              function! s:dirpath(path)
                                return s:path(a:path) . '\'
                              endfunction
                            
                              function! s:is_local_plug(repo)
                                return a:repo =~? '^[a-z]:\|^[%~]'
                              endfunction
                            else
    1              0.000001   function! s:rtp(spec)
                                return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
                              endfunction
                            
    1              0.000002   function! s:path(path)
                                return s:trim(a:path)
                              endfunction
                            
    1              0.000001   function! s:dirpath(path)
                                return substitute(a:path, '[/\\]*$', '/', '')
                              endfunction
                            
    1              0.000002   function! s:is_local_plug(repo)
                                return a:repo[0] =~ '[/$~]'
                              endfunction
    1              0.000001 endif
                            
    1              0.000002 function! s:err(msg)
                              echohl ErrorMsg
                              echom '[vim-plug] '.a:msg
                              echohl None
                            endfunction
                            
    1              0.000001 function! s:warn(cmd, msg)
                              echohl WarningMsg
                              execute a:cmd 'a:msg'
                              echohl None
                            endfunction
                            
    1              0.000002 function! s:esc(path)
                              return escape(a:path, ' ')
                            endfunction
                            
    1              0.000001 function! s:escrtp(path)
                              return escape(a:path, ' ,')
                            endfunction
                            
    1              0.000002 function! s:remove_rtp()
                              for name in s:loaded_names()
                                let rtp = s:rtp(g:plugs[name])
                                execute 'set rtp-='.s:escrtp(rtp)
                                let after = globpath(rtp, 'after')
                                if isdirectory(after)
                                  execute 'set rtp-='.s:escrtp(after)
                                endif
                              endfor
                            endfunction
                            
    1              0.000002 function! s:reorg_rtp()
                              if !empty(s:first_rtp)
                                execute 'set rtp-='.s:first_rtp
                                execute 'set rtp-='.s:last_rtp
                              endif
                            
                              " &rtp is modified from outside
                              if exists('s:prtp') && s:prtp !=# &rtp
                                call s:remove_rtp()
                                unlet! s:middle
                              endif
                            
                              let s:middle = get(s:, 'middle', &rtp)
                              let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
                              let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')
                              let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',')
                                             \ . ','.s:middle.','
                                             \ . join(map(afters, 'escape(v:val, ",")'), ',')
                              let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
                              let s:prtp   = &rtp
                            
                              if !empty(s:first_rtp)
                                execute 'set rtp^='.s:first_rtp
                                execute 'set rtp+='.s:last_rtp
                              endif
                            endfunction
                            
    1              0.000002 function! s:doautocmd(...)
                              if exists('#'.join(a:000, '#'))
                                execute 'doautocmd' ((v:version > 703 || has('patch442')) ? '<nomodeline>' : '') join(a:000)
                              endif
                            endfunction
                            
    1              0.000002 function! s:dobufread(names)
                              for name in a:names
                                let path = s:rtp(g:plugs[name]).'/**'
                                for dir in ['ftdetect', 'ftplugin']
                                  if len(finddir(dir, path))
                                    if exists('#BufRead')
                                      doautocmd BufRead
                                    endif
                                    return
                                  endif
                                endfor
                              endfor
                            endfunction
                            
    1              0.000002 function! plug#load(...)
                              if a:0 == 0
                                return s:err('Argument missing: plugin name(s) required')
                              endif
                              if !exists('g:plugs')
                                return s:err('plug#begin was not called')
                              endif
                              let names = a:0 == 1 && type(a:1) == s:TYPE.list ? a:1 : a:000
                              let unknowns = filter(copy(names), '!has_key(g:plugs, v:val)')
                              if !empty(unknowns)
                                let s = len(unknowns) > 1 ? 's' : ''
                                return s:err(printf('Unknown plugin%s: %s', s, join(unknowns, ', ')))
                              end
                              let unloaded = filter(copy(names), '!get(s:loaded, v:val, 0)')
                              if !empty(unloaded)
                                for name in unloaded
                                  call s:lod([name], ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'])
                                endfor
                                call s:dobufread(unloaded)
                                return 1
                              end
                              return 0
                            endfunction
                            
    1              0.000002 function! s:remove_triggers(name)
                              if !has_key(s:triggers, a:name)
                                return
                              endif
                              for cmd in s:triggers[a:name].cmd
                                execute 'silent! delc' cmd
                              endfor
                              for map in s:triggers[a:name].map
                                execute 'silent! unmap' map
                                execute 'silent! iunmap' map
                              endfor
                              call remove(s:triggers, a:name)
                            endfunction
                            
    1              0.000002 function! s:lod(names, types, ...)
                              for name in a:names
                                call s:remove_triggers(name)
                                let s:loaded[name] = 1
                              endfor
                              call s:reorg_rtp()
                            
                              for name in a:names
                                let rtp = s:rtp(g:plugs[name])
                                for dir in a:types
                                  call s:source(rtp, dir.'/**/*.vim')
                                endfor
                                if a:0
                                  if !s:source(rtp, a:1) && !empty(s:glob(rtp, a:2))
                                    execute 'runtime' a:1
                                  endif
                                  call s:source(rtp, a:2)
                                endif
                                call s:doautocmd('User', name)
                              endfor
                            endfunction
                            
    1              0.000002 function! s:lod_ft(pat, names)
                              let syn = 'syntax/'.a:pat.'.vim'
                              call s:lod(a:names, ['plugin', 'after/plugin'], syn, 'after/'.syn)
                              execute 'autocmd! PlugLOD FileType' a:pat
                              call s:doautocmd('filetypeplugin', 'FileType')
                              call s:doautocmd('filetypeindent', 'FileType')
                            endfunction
                            
    1              0.000003 function! s:lod_cmd(cmd, bang, l1, l2, args, names)
                              call s:lod(a:names, ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'])
                              call s:dobufread(a:names)
                              execute printf('%s%s%s %s', (a:l1 == a:l2 ? '' : (a:l1.','.a:l2)), a:cmd, a:bang, a:args)
                            endfunction
                            
    1              0.000002 function! s:lod_map(map, names, with_prefix, prefix)
                              call s:lod(a:names, ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'])
                              call s:dobufread(a:names)
                              let extra = ''
                              while 1
                                let c = getchar(0)
                                if c == 0
                                  break
                                endif
                                let extra .= nr2char(c)
                              endwhile
                            
                              if a:with_prefix
                                let prefix = v:count ? v:count : ''
                                let prefix .= '"'.v:register.a:prefix
                                if mode(1) == 'no'
                                  if v:operator == 'c'
                                    let prefix = "\<esc>" . prefix
                                  endif
                                  let prefix .= v:operator
                                endif
                                call feedkeys(prefix, 'n')
                              endif
                              call feedkeys(substitute(a:map, '^<Plug>', "\<Plug>", '') . extra)
                            endfunction
                            
    1              0.000002 function! plug#(repo, ...)
                              if a:0 > 1
                                return s:err('Invalid number of arguments (1..2)')
                              endif
                            
                              try
                                let repo = s:trim(a:repo)
                                let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
                                let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
                                let spec = extend(s:infer_properties(name, repo), opts)
                                if !has_key(g:plugs, name)
                                  call add(g:plugs_order, name)
                                endif
                                let g:plugs[name] = spec
                                let s:loaded[name] = get(s:loaded, name, 0)
                              catch
                                return s:err(v:exception)
                              endtry
                            endfunction
                            
    1              0.000002 function! s:parse_options(arg)
                              let opts = copy(s:base_spec)
                              let type = type(a:arg)
                              if type == s:TYPE.string
                                let opts.tag = a:arg
                              elseif type == s:TYPE.dict
                                call extend(opts, a:arg)
                                if has_key(opts, 'dir')
                                  let opts.dir = s:dirpath(expand(opts.dir))
                                endif
                              else
                                throw 'Invalid argument type (expected: string or dictionary)'
                              endif
                              return opts
                            endfunction
                            
    1              0.000002 function! s:infer_properties(name, repo)
                              let repo = a:repo
                              if s:is_local_plug(repo)
                                return { 'dir': s:dirpath(expand(repo)) }
                              else
                                if repo =~ ':'
                                  let uri = repo
                                else
                                  if repo !~ '/'
                                    throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
                                  endif
                                  let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
                                  let uri = printf(fmt, repo)
                                endif
                                return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
                              endif
                            endfunction
                            
    1              0.000002 function! s:install(force, names)
                              call s:update_impl(0, a:force, a:names)
                            endfunction
                            
    1              0.000002 function! s:update(force, names)
                              call s:update_impl(1, a:force, a:names)
                            endfunction
                            
    1              0.000002 function! plug#helptags()
                              if !exists('g:plugs')
                                return s:err('plug#begin was not called')
                              endif
                              for spec in values(g:plugs)
                                let docd = join([spec.dir, 'doc'], '/')
                                if isdirectory(docd)
                                  silent! execute 'helptags' s:esc(docd)
                                endif
                              endfor
                              return 1
                            endfunction
                            
    1              0.000001 function! s:syntax()
                              syntax clear
                              syntax region plug1 start=/\%1l/ end=/\%2l/ contains=plugNumber
                              syntax region plug2 start=/\%2l/ end=/\%3l/ contains=plugBracket,plugX
                              syn match plugNumber /[0-9]\+[0-9.]*/ contained
                              syn match plugBracket /[[\]]/ contained
                              syn match plugX /x/ contained
                              syn match plugDash /^-/
                              syn match plugPlus /^+/
                              syn match plugStar /^*/
                              syn match plugMessage /\(^- \)\@<=.*/
                              syn match plugName /\(^- \)\@<=[^ ]*:/
                              syn match plugSha /\%(: \)\@<=[0-9a-f]\{4,}$/
                              syn match plugTag /(tag: [^)]\+)/
                              syn match plugInstall /\(^+ \)\@<=[^:]*/
                              syn match plugUpdate /\(^* \)\@<=[^:]*/
                              syn match plugCommit /^  \X*[0-9a-f]\{7,9} .*/ contains=plugRelDate,plugEdge,plugTag
                              syn match plugEdge /^  \X\+$/
                              syn match plugEdge /^  \X*/ contained nextgroup=plugSha
                              syn match plugSha /[0-9a-f]\{7,9}/ contained
                              syn match plugRelDate /([^)]*)$/ contained
                              syn match plugNotLoaded /(not loaded)$/
                              syn match plugError /^x.*/
                              syn region plugDeleted start=/^\~ .*/ end=/^\ze\S/
                              syn match plugH2 /^.*:\n-\+$/
                              syn keyword Function PlugInstall PlugStatus PlugUpdate PlugClean
                              hi def link plug1       Title
                              hi def link plug2       Repeat
                              hi def link plugH2      Type
                              hi def link plugX       Exception
                              hi def link plugBracket Structure
                              hi def link plugNumber  Number
                            
                              hi def link plugDash    Special
                              hi def link plugPlus    Constant
                              hi def link plugStar    Boolean
                            
                              hi def link plugMessage Function
                              hi def link plugName    Label
                              hi def link plugInstall Function
                              hi def link plugUpdate  Type
                            
                              hi def link plugError   Error
                              hi def link plugDeleted Ignore
                              hi def link plugRelDate Comment
                              hi def link plugEdge    PreProc
                              hi def link plugSha     Identifier
                              hi def link plugTag     Constant
                            
                              hi def link plugNotLoaded Comment
                            endfunction
                            
    1              0.000002 function! s:lpad(str, len)
                              return a:str . repeat(' ', a:len - len(a:str))
                            endfunction
                            
    1              0.000002 function! s:lines(msg)
                              return split(a:msg, "[\r\n]")
                            endfunction
                            
    1              0.000002 function! s:lastline(msg)
                              return get(s:lines(a:msg), -1, '')
                            endfunction
                            
    1              0.000002 function! s:new_window()
                              execute get(g:, 'plug_window', 'vertical topleft new')
                            endfunction
                            
    1              0.000002 function! s:plug_window_exists()
                              let buflist = tabpagebuflist(s:plug_tab)
                              return !empty(buflist) && index(buflist, s:plug_buf) >= 0
                            endfunction
                            
    1              0.000001 function! s:switch_in()
                              if !s:plug_window_exists()
                                return 0
                              endif
                            
                              if winbufnr(0) != s:plug_buf
                                let s:pos = [tabpagenr(), winnr(), winsaveview()]
                                execute 'normal!' s:plug_tab.'gt'
                                let winnr = bufwinnr(s:plug_buf)
                                execute winnr.'wincmd w'
                                call add(s:pos, winsaveview())
                              else
                                let s:pos = [winsaveview()]
                              endif
                            
                              setlocal modifiable
                              return 1
                            endfunction
                            
    1              0.000001 function! s:switch_out(...)
                              call winrestview(s:pos[-1])
                              setlocal nomodifiable
                              if a:0 > 0
                                execute a:1
                              endif
                            
                              if len(s:pos) > 1
                                execute 'normal!' s:pos[0].'gt'
                                execute s:pos[1] 'wincmd w'
                                call winrestview(s:pos[2])
                              endif
                            endfunction
                            
    1              0.000002 function! s:finish_bindings()
                              nnoremap <silent> <buffer> R  :call <SID>retry()<cr>
                              nnoremap <silent> <buffer> D  :PlugDiff<cr>
                              nnoremap <silent> <buffer> S  :PlugStatus<cr>
                              nnoremap <silent> <buffer> U  :call <SID>status_update()<cr>
                              xnoremap <silent> <buffer> U  :call <SID>status_update()<cr>
                              nnoremap <silent> <buffer> ]] :silent! call <SID>section('')<cr>
                              nnoremap <silent> <buffer> [[ :silent! call <SID>section('b')<cr>
                            endfunction
                            
    1              0.000002 function! s:prepare(...)
                              if empty(getcwd())
                                throw 'Invalid current working directory. Cannot proceed.'
                              endif
                            
                              for evar in ['$GIT_DIR', '$GIT_WORK_TREE']
                                if exists(evar)
                                  throw evar.' detected. Cannot proceed.'
                                endif
                              endfor
                            
                              call s:job_abort()
                              if s:switch_in()
                                if b:plug_preview == 1
                                  pc
                                endif
                                enew
                              else
                                call s:new_window()
                              endif
                            
                              nnoremap <silent> <buffer> q  :if b:plug_preview==1<bar>pc<bar>endif<bar>bd<cr>
                              if a:0 == 0
                                call s:finish_bindings()
                              endif
                              let b:plug_preview = -1
                              let s:plug_tab = tabpagenr()
                              let s:plug_buf = winbufnr(0)
                              call s:assign_name()
                            
                              for k in ['<cr>', 'L', 'o', 'X', 'd', 'dd']
                                execute 'silent! unmap <buffer>' k
                              endfor
                              setlocal buftype=nofile bufhidden=wipe nobuflisted nolist noswapfile nowrap cursorline modifiable nospell
                              setf vim-plug
                              if exists('g:syntax_on')
                                call s:syntax()
                              endif
                            endfunction
                            
    1              0.000002 function! s:assign_name()
                              " Assign buffer name
                              let prefix = '[Plugins]'
                              let name   = prefix
                              let idx    = 2
                              while bufexists(name)
                                let name = printf('%s (%s)', prefix, idx)
                                let idx = idx + 1
                              endwhile
                              silent! execute 'f' fnameescape(name)
                            endfunction
                            
    1              0.000002 function! s:chsh(swap)
                              let prev = [&shell, &shellredir]
                              if !s:is_win && a:swap
                                set shell=sh shellredir=>%s\ 2>&1
                              endif
                              return prev
                            endfunction
                            
    1              0.000001 function! s:bang(cmd, ...)
                              try
                                let [sh, shrd] = s:chsh(a:0)
                                " FIXME: Escaping is incomplete. We could use shellescape with eval,
                                "        but it won't work on Windows.
                                let cmd = a:0 ? s:with_cd(a:cmd, a:1) : a:cmd
                                let g:_plug_bang = '!'.escape(cmd, '#!%')
                                execute "normal! :execute g:_plug_bang\<cr>\<cr>"
                              finally
                                unlet g:_plug_bang
                                let [&shell, &shellredir] = [sh, shrd]
                              endtry
                              return v:shell_error ? 'Exit status: ' . v:shell_error : ''
                            endfunction
                            
    1              0.000002 function! s:regress_bar()
                              let bar = substitute(getline(2)[1:-2], '.*\zs=', 'x', '')
                              call s:progress_bar(2, bar, len(bar))
                            endfunction
                            
    1              0.000002 function! s:is_updated(dir)
                              return !empty(s:system_chomp('git log --pretty=format:"%h" "HEAD...HEAD@{1}"', a:dir))
                            endfunction
                            
    1              0.000001 function! s:do(pull, force, todo)
                              for [name, spec] in items(a:todo)
                                if !isdirectory(spec.dir)
                                  continue
                                endif
                                let installed = has_key(s:update.new, name)
                                let updated = installed ? 0 :
                                  \ (a:pull && index(s:update.errors, name) < 0 && s:is_updated(spec.dir))
                                if a:force || installed || updated
                                  execute 'cd' s:esc(spec.dir)
                                  call append(3, '- Post-update hook for '. name .' ... ')
                                  let error = ''
                                  let type = type(spec.do)
                                  if type == s:TYPE.string
                                    if spec.do[0] == ':'
                                      if !get(s:loaded, name, 0)
                                        let s:loaded[name] = 1
                                        call s:reorg_rtp()
                                      endif
                                      call s:load_plugin(spec)
                                      try
                                        execute spec.do[1:]
                                      catch
                                        let error = v:exception
                                      endtry
                                      if !s:plug_window_exists()
                                        cd -
                                        throw 'Warning: vim-plug was terminated by the post-update hook of '.name
                                      endif
                                    else
                                      let error = s:bang(spec.do)
                                    endif
                                  elseif type == s:TYPE.funcref
                                    try
                                      let status = installed ? 'installed' : (updated ? 'updated' : 'unchanged')
                                      call spec.do({ 'name': name, 'status': status, 'force': a:force })
                                    catch
                                      let error = v:exception
                                    endtry
                                  else
                                    let error = 'Invalid hook type'
                                  endif
                                  call s:switch_in()
                                  call setline(4, empty(error) ? (getline(4) . 'OK')
                                                             \ : ('x' . getline(4)[1:] . error))
                                  if !empty(error)
                                    call add(s:update.errors, name)
                                    call s:regress_bar()
                                  endif
                                  cd -
                                endif
                              endfor
                            endfunction
                            
    1              0.000002 function! s:hash_match(a, b)
                              return stridx(a:a, a:b) == 0 || stridx(a:b, a:a) == 0
                            endfunction
                            
    1              0.000002 function! s:checkout(spec)
                              let sha = a:spec.commit
                              let output = s:system('git rev-parse HEAD', a:spec.dir)
                              if !v:shell_error && !s:hash_match(sha, s:lines(output)[0])
                                let output = s:system(
                                      \ 'git fetch --depth 999999 && git checkout '.s:esc(sha).' --', a:spec.dir)
                              endif
                              return output
                            endfunction
                            
    1              0.000002 function! s:finish(pull)
                              let new_frozen = len(filter(keys(s:update.new), 'g:plugs[v:val].frozen'))
                              if new_frozen
                                let s = new_frozen > 1 ? 's' : ''
                                call append(3, printf('- Installed %d frozen plugin%s', new_frozen, s))
                              endif
                              call append(3, '- Finishing ... ') | 4
                              redraw
                              call plug#helptags()
                              call plug#end()
                              call setline(4, getline(4) . 'Done!')
                              redraw
                              let msgs = []
                              if !empty(s:update.errors)
                                call add(msgs, "Press 'R' to retry.")
                              endif
                              if a:pull && len(s:update.new) < len(filter(getline(5, '$'),
                                            \ "v:val =~ '^- ' && stridx(v:val, 'Already up-to-date') < 0"))
                                call add(msgs, "Press 'D' to see the updated changes.")
                              endif
                              echo join(msgs, ' ')
                              call s:finish_bindings()
                            endfunction
                            
    1              0.000001 function! s:retry()
                              if empty(s:update.errors)
                                return
                              endif
                              echo
                              call s:update_impl(s:update.pull, s:update.force,
                                    \ extend(copy(s:update.errors), [s:update.threads]))
                            endfunction
                            
    1              0.000002 function! s:is_managed(name)
                              return has_key(g:plugs[a:name], 'uri')
                            endfunction
                            
    1              0.000001 function! s:names(...)
                              return sort(filter(keys(g:plugs), 'stridx(v:val, a:1) == 0 && s:is_managed(v:val)'))
                            endfunction
                            
    1              0.000002 function! s:check_ruby()
                              silent! ruby require 'thread'; VIM::command("let g:plug_ruby = '#{RUBY_VERSION}'")
                              if !exists('g:plug_ruby')
                                redraw!
                                return s:warn('echom', 'Warning: Ruby interface is broken')
                              endif
                              let ruby_version = split(g:plug_ruby, '\.')
                              unlet g:plug_ruby
                              return s:version_requirement(ruby_version, [1, 8, 7])
                            endfunction
                            
    1              0.000002 function! s:update_impl(pull, force, args) abort
                              let sync = index(a:args, '--sync') >= 0 || has('vim_starting')
                              let args = filter(copy(a:args), 'v:val != "--sync"')
                              let threads = (len(args) > 0 && args[-1] =~ '^[1-9][0-9]*$') ?
                                              \ remove(args, -1) : get(g:, 'plug_threads', 16)
                            
                              let managed = filter(copy(g:plugs), 's:is_managed(v:key)')
                              let todo = empty(args) ? filter(managed, '!v:val.frozen || !isdirectory(v:val.dir)') :
                                                     \ filter(managed, 'index(args, v:key) >= 0')
                            
                              if empty(todo)
                                return s:warn('echo', 'No plugin to '. (a:pull ? 'update' : 'install'))
                              endif
                            
                              if !s:is_win && s:git_version_requirement(2, 3)
                                let s:git_terminal_prompt = exists('$GIT_TERMINAL_PROMPT') ? $GIT_TERMINAL_PROMPT : ''
                                let $GIT_TERMINAL_PROMPT = 0
                                for plug in values(todo)
                                  let plug.uri = substitute(plug.uri,
                                        \ '^https://git::@github\.com', 'https://github.com', '')
                                endfor
                              endif
                            
                              if !isdirectory(g:plug_home)
                                try
                                  call mkdir(g:plug_home, 'p')
                                catch
                                  return s:err(printf('Invalid plug directory: %s. '.
                                          \ 'Try to call plug#begin with a valid directory', g:plug_home))
                                endtry
                              endif
                            
                              if has('nvim') && !exists('*jobwait') && threads > 1
                                call s:warn('echom', '[vim-plug] Update Neovim for parallel installer')
                              endif
                            
                              let use_job = s:nvim || s:vim8
                              let python = (has('python') || has('python3')) && !use_job
                              let ruby = has('ruby') && !use_job && (v:version >= 703 || v:version == 702 && has('patch374')) && !(s:is_win && has('gui_running')) && threads > 1 && s:check_ruby()
                            
                              let s:update = {
                                \ 'start':   reltime(),
                                \ 'all':     todo,
                                \ 'todo':    copy(todo),
                                \ 'errors':  [],
                                \ 'pull':    a:pull,
                                \ 'force':   a:force,
                                \ 'new':     {},
                                \ 'threads': (python || ruby || use_job) ? min([len(todo), threads]) : 1,
                                \ 'bar':     '',
                                \ 'fin':     0
                              \ }
                            
                              call s:prepare(1)
                              call append(0, ['', ''])
                              normal! 2G
                              silent! redraw
                            
                              let s:clone_opt = get(g:, 'plug_shallow', 1) ?
                                    \ '--depth 1' . (s:git_version_requirement(1, 7, 10) ? ' --no-single-branch' : '') : ''
                            
                              if has('win32unix')
                                let s:clone_opt .= ' -c core.eol=lf -c core.autocrlf=input'
                              endif
                            
                              " Python version requirement (>= 2.7)
                              if python && !has('python3') && !ruby && !use_job && s:update.threads > 1
                                redir => pyv
                                silent python import platform; print platform.python_version()
                                redir END
                                let python = s:version_requirement(
                                      \ map(split(split(pyv)[0], '\.'), 'str2nr(v:val)'), [2, 6])
                              endif
                            
                              if (python || ruby) && s:update.threads > 1
                                try
                                  let imd = &imd
                                  if s:mac_gui
                                    set noimd
                                  endif
                                  if ruby
                                    call s:update_ruby()
                                  else
                                    call s:update_python()
                                  endif
                                catch
                                  let lines = getline(4, '$')
                                  let printed = {}
                                  silent! 4,$d _
                                  for line in lines
                                    let name = s:extract_name(line, '.', '')
                                    if empty(name) || !has_key(printed, name)
                                      call append('$', line)
                                      if !empty(name)
                                        let printed[name] = 1
                                        if line[0] == 'x' && index(s:update.errors, name) < 0
                                          call add(s:update.errors, name)
                                        end
                                      endif
                                    endif
                                  endfor
                                finally
                                  let &imd = imd
                                  call s:update_finish()
                                endtry
                              else
                                call s:update_vim()
                                while use_job && sync
                                  sleep 100m
                                  if s:update.fin
                                    break
                                  endif
                                endwhile
                              endif
                            endfunction
                            
    1              0.000004 function! s:log4(name, msg)
                              call setline(4, printf('- %s (%s)', a:msg, a:name))
                              redraw
                            endfunction
                            
    1              0.000002 function! s:update_finish()
                              if exists('s:git_terminal_prompt')
                                let $GIT_TERMINAL_PROMPT = s:git_terminal_prompt
                              endif
                              if s:switch_in()
                                call append(3, '- Updating ...') | 4
                                for [name, spec] in items(filter(copy(s:update.all), 'index(s:update.errors, v:key) < 0 && (s:update.force || s:update.pull || has_key(s:update.new, v:key))'))
                                  let [pos, _] = s:logpos(name)
                                  if !pos
                                    continue
                                  endif
                                  if has_key(spec, 'commit')
                                    call s:log4(name, 'Checking out '.spec.commit)
                                    let out = s:checkout(spec)
                                  elseif has_key(spec, 'tag')
                                    let tag = spec.tag
                                    if tag =~ '\*'
                                      let tags = s:lines(s:system('git tag --list '.s:shellesc(tag).' --sort -version:refname 2>&1', spec.dir))
                                      if !v:shell_error && !empty(tags)
                                        let tag = tags[0]
                                        call s:log4(name, printf('Latest tag for %s -> %s', spec.tag, tag))
                                        call append(3, '')
                                      endif
                                    endif
                                    call s:log4(name, 'Checking out '.tag)
                                    let out = s:system('git checkout -q '.s:esc(tag).' -- 2>&1', spec.dir)
                                  else
                                    let branch = s:esc(get(spec, 'branch', 'master'))
                                    call s:log4(name, 'Merging origin/'.branch)
                                    let out = s:system('git checkout -q '.branch.' -- 2>&1'
                                          \. (has_key(s:update.new, name) ? '' : ('&& git merge --ff-only origin/'.branch.' 2>&1')), spec.dir)
                                  endif
                                  if !v:shell_error && filereadable(spec.dir.'/.gitmodules') &&
                                        \ (s:update.force || has_key(s:update.new, name) || s:is_updated(spec.dir))
                                    call s:log4(name, 'Updating submodules. This may take a while.')
                                    let out .= s:bang('git submodule update --init --recursive 2>&1', spec.dir)
                                  endif
                                  let msg = s:format_message(v:shell_error ? 'x': '-', name, out)
                                  if v:shell_error
                                    call add(s:update.errors, name)
                                    call s:regress_bar()
                                    silent execute pos 'd _'
                                    call append(4, msg) | 4
                                  elseif !empty(out)
                                    call setline(pos, msg[0])
                                  endif
                                  redraw
                                endfor
                                silent 4 d _
                                try
                                  call s:do(s:update.pull, s:update.force, filter(copy(s:update.all), 'index(s:update.errors, v:key) < 0 && has_key(v:val, "do")'))
                                catch
                                  call s:warn('echom', v:exception)
                                  call s:warn('echo', '')
                                  return
                                endtry
                                call s:finish(s:update.pull)
                                call setline(1, 'Updated. Elapsed time: ' . split(reltimestr(reltime(s:update.start)))[0] . ' sec.')
                                call s:switch_out('normal! gg')
                              endif
                            endfunction
                            
    1              0.000002 function! s:job_abort()
                              if (!s:nvim && !s:vim8) || !exists('s:jobs')
                                return
                              endif
                            
                              for [name, j] in items(s:jobs)
                                if s:nvim
                                  silent! call jobstop(j.jobid)
                                elseif s:vim8
                                  silent! call job_stop(j.jobid)
                                endif
                                if j.new
                                  call s:system('rm -rf ' . s:shellesc(g:plugs[name].dir))
                                endif
                              endfor
                              let s:jobs = {}
                            endfunction
                            
    1              0.000002 function! s:last_non_empty_line(lines)
                              let len = len(a:lines)
                              for idx in range(len)
                                let line = a:lines[len-idx-1]
                                if !empty(line)
                                  return line
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000003 function! s:job_out_cb(self, data) abort
                              let self = a:self
                              let data = remove(self.lines, -1) . a:data
                              let lines = map(split(data, "\n", 1), 'split(v:val, "\r", 1)[-1]')
                              call extend(self.lines, lines)
                              " To reduce the number of buffer updates
                              let self.tick = get(self, 'tick', -1) + 1
                              if !self.running || self.tick % len(s:jobs) == 0
                                let bullet = self.running ? (self.new ? '+' : '*') : (self.error ? 'x' : '-')
                                let result = self.error ? join(self.lines, "\n") : s:last_non_empty_line(self.lines)
                                call s:log(bullet, self.name, result)
                              endif
                            endfunction
                            
    1              0.000002 function! s:job_exit_cb(self, data) abort
                              let a:self.running = 0
                              let a:self.error = a:data != 0
                              call s:reap(a:self.name)
                              call s:tick()
                            endfunction
                            
    1              0.000002 function! s:job_cb(fn, job, ch, data)
                              if !s:plug_window_exists() " plug window closed
                                return s:job_abort()
                              endif
                              call call(a:fn, [a:job, a:data])
                            endfunction
                            
    1              0.000003 function! s:nvim_cb(job_id, data, event) dict abort
                              return a:event == 'stdout' ?
                                \ s:job_cb('s:job_out_cb',  self, 0, join(a:data, "\n")) :
                                \ s:job_cb('s:job_exit_cb', self, 0, a:data)
                            endfunction
                            
    1              0.000002 function! s:spawn(name, cmd, opts)
                              let job = { 'name': a:name, 'running': 1, 'error': 0, 'lines': [''],
                                        \ 'new': get(a:opts, 'new', 0) }
                              let s:jobs[a:name] = job
                              let argv = add(s:is_win ? ['cmd', '/c'] : ['sh', '-c'],
                                           \ has_key(a:opts, 'dir') ? s:with_cd(a:cmd, a:opts.dir) : a:cmd)
                            
                              if s:nvim
                                call extend(job, {
                                \ 'on_stdout': function('s:nvim_cb'),
                                \ 'on_exit':   function('s:nvim_cb'),
                                \ })
                                let jid = jobstart(argv, job)
                                if jid > 0
                                  let job.jobid = jid
                                else
                                  let job.running = 0
                                  let job.error   = 1
                                  let job.lines   = [jid < 0 ? argv[0].' is not executable' :
                                        \ 'Invalid arguments (or job table is full)']
                                endif
                              elseif s:vim8
                                let jid = job_start(s:is_win ? join(argv, ' ') : argv, {
                                \ 'out_cb':   function('s:job_cb', ['s:job_out_cb',  job]),
                                \ 'exit_cb':  function('s:job_cb', ['s:job_exit_cb', job]),
                                \ 'out_mode': 'raw'
                                \})
                                if job_status(jid) == 'run'
                                  let job.jobid = jid
                                else
                                  let job.running = 0
                                  let job.error   = 1
                                  let job.lines   = ['Failed to start job']
                                endif
                              else
                                let params = has_key(a:opts, 'dir') ? [a:cmd, a:opts.dir] : [a:cmd]
                                let job.lines = s:lines(call('s:system', params))
                                let job.error = v:shell_error != 0
                                let job.running = 0
                              endif
                            endfunction
                            
    1              0.000001 function! s:reap(name)
                              let job = s:jobs[a:name]
                              if job.error
                                call add(s:update.errors, a:name)
                              elseif get(job, 'new', 0)
                                let s:update.new[a:name] = 1
                              endif
                              let s:update.bar .= job.error ? 'x' : '='
                            
                              let bullet = job.error ? 'x' : '-'
                              let result = job.error ? join(job.lines, "\n") : s:last_non_empty_line(job.lines)
                              call s:log(bullet, a:name, empty(result) ? 'OK' : result)
                              call s:bar()
                            
                              call remove(s:jobs, a:name)
                            endfunction
                            
    1              0.000001 function! s:bar()
                              if s:switch_in()
                                let total = len(s:update.all)
                                call setline(1, (s:update.pull ? 'Updating' : 'Installing').
                                      \ ' plugins ('.len(s:update.bar).'/'.total.')')
                                call s:progress_bar(2, s:update.bar, total)
                                call s:switch_out()
                              endif
                            endfunction
                            
    1              0.000001 function! s:logpos(name)
                              for i in range(4, line('$'))
                                if getline(i) =~# '^[-+x*] '.a:name.':'
                                  for j in range(i + 1, line('$'))
                                    if getline(j) !~ '^ '
                                      return [i, j - 1]
                                    endif
                                  endfor
                                  return [i, i]
                                endif
                              endfor
                              return [0, 0]
                            endfunction
                            
    1              0.000002 function! s:log(bullet, name, lines)
                              if s:switch_in()
                                let [b, e] = s:logpos(a:name)
                                if b > 0
                                  silent execute printf('%d,%d d _', b, e)
                                  if b > winheight('.')
                                    let b = 4
                                  endif
                                else
                                  let b = 4
                                endif
                                " FIXME For some reason, nomodifiable is set after :d in vim8
                                setlocal modifiable
                                call append(b - 1, s:format_message(a:bullet, a:name, a:lines))
                                call s:switch_out()
                              endif
                            endfunction
                            
    1              0.000001 function! s:update_vim()
                              let s:jobs = {}
                            
                              call s:bar()
                              call s:tick()
                            endfunction
                            
    1              0.000001 function! s:tick()
                              let pull = s:update.pull
                              let prog = s:progress_opt(s:nvim || s:vim8)
                            while 1 " Without TCO, Vim stack is bound to explode
                              if empty(s:update.todo)
                                if empty(s:jobs) && !s:update.fin
                                  call s:update_finish()
                                  let s:update.fin = 1
                                endif
                                return
                              endif
                            
                              let name = keys(s:update.todo)[0]
                              let spec = remove(s:update.todo, name)
                              let new  = !isdirectory(spec.dir)
                            
                              call s:log(new ? '+' : '*', name, pull ? 'Updating ...' : 'Installing ...')
                              redraw
                            
                              let has_tag = has_key(spec, 'tag')
                              if !new
                                let [error, _] = s:git_validate(spec, 0)
                                if empty(error)
                                  if pull
                                    let fetch_opt = (has_tag && !empty(globpath(spec.dir, '.git/shallow'))) ? '--depth 99999999' : ''
                                    call s:spawn(name, printf('git fetch %s %s 2>&1', fetch_opt, prog), { 'dir': spec.dir })
                                  else
                                    let s:jobs[name] = { 'running': 0, 'lines': ['Already installed'], 'error': 0 }
                                  endif
                                else
                                  let s:jobs[name] = { 'running': 0, 'lines': s:lines(error), 'error': 1 }
                                endif
                              else
                                call s:spawn(name,
                                      \ printf('git clone %s %s %s %s 2>&1',
                                      \ has_tag ? '' : s:clone_opt,
                                      \ prog,
                                      \ s:shellesc(spec.uri),
                                      \ s:shellesc(s:trim(spec.dir))), { 'new': 1 })
                              endif
                            
                              if !s:jobs[name].running
                                call s:reap(name)
                              endif
                              if len(s:jobs) >= s:update.threads
                                break
                              endif
                            endwhile
                            endfunction
                            
    1              0.000002 function! s:update_python()
                            let py_exe = has('python') ? 'python' : 'python3'
                            execute py_exe "<< EOF"
                            import datetime
                            import functools
                            import os
                            try:
                              import queue
                            except ImportError:
                              import Queue as queue
                            import random
                            import re
                            import shutil
                            import signal
                            import subprocess
                            import tempfile
                            import threading as thr
                            import time
                            import traceback
                            import vim
                            
                            G_NVIM = vim.eval("has('nvim')") == '1'
                            G_PULL = vim.eval('s:update.pull') == '1'
                            G_RETRIES = int(vim.eval('get(g:, "plug_retries", 2)')) + 1
                            G_TIMEOUT = int(vim.eval('get(g:, "plug_timeout", 60)'))
                            G_CLONE_OPT = vim.eval('s:clone_opt')
                            G_PROGRESS = vim.eval('s:progress_opt(1)')
                            G_LOG_PROB = 1.0 / int(vim.eval('s:update.threads'))
                            G_STOP = thr.Event()
                            G_IS_WIN = vim.eval('s:is_win') == '1'
                            
                            class PlugError(Exception):
                              def __init__(self, msg):
                                self.msg = msg
                            class CmdTimedOut(PlugError):
                              pass
                            class CmdFailed(PlugError):
                              pass
                            class InvalidURI(PlugError):
                              pass
                            class Action(object):
                              INSTALL, UPDATE, ERROR, DONE = ['+', '*', 'x', '-']
                            
                            class Buffer(object):
                              def __init__(self, lock, num_plugs, is_pull):
                                self.bar = ''
                                self.event = 'Updating' if is_pull else 'Installing'
                                self.lock = lock
                                self.maxy = int(vim.eval('winheight(".")'))
                                self.num_plugs = num_plugs
                            
                              def __where(self, name):
                                """ Find first line with name in current buffer. Return line num. """
                                found, lnum = False, 0
                                matcher = re.compile('^[-+x*] {0}:'.format(name))
                                for line in vim.current.buffer:
                                  if matcher.search(line) is not None:
                                    found = True
                                    break
                                  lnum += 1
                            
                                if not found:
                                  lnum = -1
                                return lnum
                            
                              def header(self):
                                curbuf = vim.current.buffer
                                curbuf[0] = self.event + ' plugins ({0}/{1})'.format(len(self.bar), self.num_plugs)
                            
                                num_spaces = self.num_plugs - len(self.bar)
                                curbuf[1] = '[{0}{1}]'.format(self.bar, num_spaces * ' ')
                            
                                with self.lock:
                                  vim.command('normal! 2G')
                                  vim.command('redraw')
                            
                              def write(self, action, name, lines):
                                first, rest = lines[0], lines[1:]
                                msg = ['{0} {1}{2}{3}'.format(action, name, ': ' if first else '', first)]
                                msg.extend(['    ' + line for line in rest])
                            
                                try:
                                  if action == Action.ERROR:
                                    self.bar += 'x'
                                    vim.command("call add(s:update.errors, '{0}')".format(name))
                                  elif action == Action.DONE:
                                    self.bar += '='
                            
                                  curbuf = vim.current.buffer
                                  lnum = self.__where(name)
                                  if lnum != -1: # Found matching line num
                                    del curbuf[lnum]
                                    if lnum > self.maxy and action in set([Action.INSTALL, Action.UPDATE]):
                                      lnum = 3
                                  else:
                                    lnum = 3
                                  curbuf.append(msg, lnum)
                            
                                  self.header()
                                except vim.error:
                                  pass
                            
                            class Command(object):
                              CD = 'cd /d' if G_IS_WIN else 'cd'
                            
                              def __init__(self, cmd, cmd_dir=None, timeout=60, cb=None, clean=None):
                                self.cmd = cmd
                                if cmd_dir:
                                  self.cmd = '{0} {1} && {2}'.format(Command.CD, cmd_dir, self.cmd)
                                self.timeout = timeout
                                self.callback = cb if cb else (lambda msg: None)
                                self.clean = clean if clean else (lambda: None)
                                self.proc = None
                            
                              @property
                              def alive(self):
                                """ Returns true only if command still running. """
                                return self.proc and self.proc.poll() is None
                            
                              def execute(self, ntries=3):
                                """ Execute the command with ntries if CmdTimedOut.
                                    Returns the output of the command if no Exception.
                                """
                                attempt, finished, limit = 0, False, self.timeout
                            
                                while not finished:
                                  try:
                                    attempt += 1
                                    result = self.try_command()
                                    finished = True
                                    return result
                                  except CmdTimedOut:
                                    if attempt != ntries:
                                      self.notify_retry()
                                      self.timeout += limit
                                    else:
                                      raise
                            
                              def notify_retry(self):
                                """ Retry required for command, notify user. """
                                for count in range(3, 0, -1):
                                  if G_STOP.is_set():
                                    raise KeyboardInterrupt
                                  msg = 'Timeout. Will retry in {0} second{1} ...'.format(
                                        count, 's' if count != 1 else '')
                                  self.callback([msg])
                                  time.sleep(1)
                                self.callback(['Retrying ...'])
                            
                              def try_command(self):
                                """ Execute a cmd & poll for callback. Returns list of output.
                                    Raises CmdFailed   -> return code for Popen isn't 0
                                    Raises CmdTimedOut -> command exceeded timeout without new output
                                """
                                first_line = True
                            
                                try:
                                  tfile = tempfile.NamedTemporaryFile(mode='w+b')
                                  preexec_fn = not G_IS_WIN and os.setsid or None
                                  self.proc = subprocess.Popen(self.cmd, stdout=tfile,
                                                               stderr=subprocess.STDOUT,
                                                               stdin=subprocess.PIPE, shell=True,
                                                               preexec_fn=preexec_fn)
                                  thrd = thr.Thread(target=(lambda proc: proc.wait()), args=(self.proc,))
                                  thrd.start()
                            
                                  thread_not_started = True
                                  while thread_not_started:
                                    try:
                                      thrd.join(0.1)
                                      thread_not_started = False
                                    except RuntimeError:
                                      pass
                            
                                  while self.alive:
                                    if G_STOP.is_set():
                                      raise KeyboardInterrupt
                            
                                    if first_line or random.random() < G_LOG_PROB:
                                      first_line = False
                                      line = '' if G_IS_WIN else nonblock_read(tfile.name)
                                      if line:
                                        self.callback([line])
                            
                                    time_diff = time.time() - os.path.getmtime(tfile.name)
                                    if time_diff > self.timeout:
                                      raise CmdTimedOut(['Timeout!'])
                            
                                    thrd.join(0.5)
                            
                                  tfile.seek(0)
                                  result = [line.decode('utf-8', 'replace').rstrip() for line in tfile]
                            
                                  if self.proc.returncode != 0:
                                    raise CmdFailed([''] + result)
                            
                                  return result
                                except:
                                  self.terminate()
                                  raise
                            
                              def terminate(self):
                                """ Terminate process and cleanup. """
                                if self.alive:
                                  if G_IS_WIN:
                                    os.kill(self.proc.pid, signal.SIGINT)
                                  else:
                                    os.killpg(self.proc.pid, signal.SIGTERM)
                                self.clean()
                            
                            class Plugin(object):
                              def __init__(self, name, args, buf_q, lock):
                                self.name = name
                                self.args = args
                                self.buf_q = buf_q
                                self.lock = lock
                                self.tag = args.get('tag', 0)
                            
                              def manage(self):
                                try:
                                  if os.path.exists(self.args['dir']):
                                    self.update()
                                  else:
                                    self.install()
                                    with self.lock:
                                      thread_vim_command("let s:update.new['{0}'] = 1".format(self.name))
                                except PlugError as exc:
                                  self.write(Action.ERROR, self.name, exc.msg)
                                except KeyboardInterrupt:
                                  G_STOP.set()
                                  self.write(Action.ERROR, self.name, ['Interrupted!'])
                                except:
                                  # Any exception except those above print stack trace
                                  msg = 'Trace:\n{0}'.format(traceback.format_exc().rstrip())
                                  self.write(Action.ERROR, self.name, msg.split('\n'))
                                  raise
                            
                              def install(self):
                                target = self.args['dir']
                                if target[-1] == '\\':
                                  target = target[0:-1]
                            
                                def clean(target):
                                  def _clean():
                                    try:
                                      shutil.rmtree(target)
                                    except OSError:
                                      pass
                                  return _clean
                            
                                self.write(Action.INSTALL, self.name, ['Installing ...'])
                                callback = functools.partial(self.write, Action.INSTALL, self.name)
                                cmd = 'git clone {0} {1} {2} {3} 2>&1'.format(
                                      '' if self.tag else G_CLONE_OPT, G_PROGRESS, self.args['uri'],
                                      esc(target))
                                com = Command(cmd, None, G_TIMEOUT, callback, clean(target))
                                result = com.execute(G_RETRIES)
                                self.write(Action.DONE, self.name, result[-1:])
                            
                              def repo_uri(self):
                                cmd = 'git rev-parse --abbrev-ref HEAD 2>&1 && git config -f .git/config remote.origin.url'
                                command = Command(cmd, self.args['dir'], G_TIMEOUT,)
                                result = command.execute(G_RETRIES)
                                return result[-1]
                            
                              def update(self):
                                actual_uri = self.repo_uri()
                                expect_uri = self.args['uri']
                                regex = re.compile(r'^(?:\w+://)?(?:[^@/]*@)?([^:/]*(?::[0-9]*)?)[:/](.*?)(?:\.git)?/?$')
                                ma = regex.match(actual_uri)
                                mb = regex.match(expect_uri)
                                if ma is None or mb is None or ma.groups() != mb.groups():
                                  msg = ['',
                                         'Invalid URI: {0}'.format(actual_uri),
                                         'Expected     {0}'.format(expect_uri),
                                         'PlugClean required.']
                                  raise InvalidURI(msg)
                            
                                if G_PULL:
                                  self.write(Action.UPDATE, self.name, ['Updating ...'])
                                  callback = functools.partial(self.write, Action.UPDATE, self.name)
                                  fetch_opt = '--depth 99999999' if self.tag and os.path.isfile(os.path.join(self.args['dir'], '.git/shallow')) else ''
                                  cmd = 'git fetch {0} {1} 2>&1'.format(fetch_opt, G_PROGRESS)
                                  com = Command(cmd, self.args['dir'], G_TIMEOUT, callback)
                                  result = com.execute(G_RETRIES)
                                  self.write(Action.DONE, self.name, result[-1:])
                                else:
                                  self.write(Action.DONE, self.name, ['Already installed'])
                            
                              def write(self, action, name, msg):
                                self.buf_q.put((action, name, msg))
                            
                            class PlugThread(thr.Thread):
                              def __init__(self, tname, args):
                                super(PlugThread, self).__init__()
                                self.tname = tname
                                self.args = args
                            
                              def run(self):
                                thr.current_thread().name = self.tname
                                buf_q, work_q, lock = self.args
                            
                                try:
                                  while not G_STOP.is_set():
                                    name, args = work_q.get_nowait()
                                    plug = Plugin(name, args, buf_q, lock)
                                    plug.manage()
                                    work_q.task_done()
                                except queue.Empty:
                                  pass
                            
                            class RefreshThread(thr.Thread):
                              def __init__(self, lock):
                                super(RefreshThread, self).__init__()
                                self.lock = lock
                                self.running = True
                            
                              def run(self):
                                while self.running:
                                  with self.lock:
                                    thread_vim_command('noautocmd normal! a')
                                  time.sleep(0.33)
                            
                              def stop(self):
                                self.running = False
                            
                            if G_NVIM:
                              def thread_vim_command(cmd):
                                vim.session.threadsafe_call(lambda: vim.command(cmd))
                            else:
                              def thread_vim_command(cmd):
                                vim.command(cmd)
                            
                            def esc(name):
                              return '"' + name.replace('"', '\"') + '"'
                            
                            def nonblock_read(fname):
                              """ Read a file with nonblock flag. Return the last line. """
                              fread = os.open(fname, os.O_RDONLY | os.O_NONBLOCK)
                              buf = os.read(fread, 100000).decode('utf-8', 'replace')
                              os.close(fread)
                            
                              line = buf.rstrip('\r\n')
                              left = max(line.rfind('\r'), line.rfind('\n'))
                              if left != -1:
                                left += 1
                                line = line[left:]
                            
                              return line
                            
                            def main():
                              thr.current_thread().name = 'main'
                              nthreads = int(vim.eval('s:update.threads'))
                              plugs = vim.eval('s:update.todo')
                              mac_gui = vim.eval('s:mac_gui') == '1'
                            
                              lock = thr.Lock()
                              buf = Buffer(lock, len(plugs), G_PULL)
                              buf_q, work_q = queue.Queue(), queue.Queue()
                              for work in plugs.items():
                                work_q.put(work)
                            
                              start_cnt = thr.active_count()
                              for num in range(nthreads):
                                tname = 'PlugT-{0:02}'.format(num)
                                thread = PlugThread(tname, (buf_q, work_q, lock))
                                thread.start()
                              if mac_gui:
                                rthread = RefreshThread(lock)
                                rthread.start()
                            
                              while not buf_q.empty() or thr.active_count() != start_cnt:
                                try:
                                  action, name, msg = buf_q.get(True, 0.25)
                                  buf.write(action, name, ['OK'] if not msg else msg)
                                  buf_q.task_done()
                                except queue.Empty:
                                  pass
                                except KeyboardInterrupt:
                                  G_STOP.set()
                            
                              if mac_gui:
                                rthread.stop()
                                rthread.join()
                            
                            main()
                            EOF
                            endfunction
                            
    1              0.000002 function! s:update_ruby()
                              ruby << EOF
                              module PlugStream
                                SEP = ["\r", "\n", nil]
                                def get_line
                                  buffer = ''
                                  loop do
                                    char = readchar rescue return
                                    if SEP.include? char.chr
                                      buffer << $/
                                      break
                                    else
                                      buffer << char
                                    end
                                  end
                                  buffer
                                end
                              end unless defined?(PlugStream)
                            
                              def esc arg
                                %["#{arg.gsub('"', '\"')}"]
                              end
                            
                              def killall pid
                                pids = [pid]
                                if /mswin|mingw|bccwin/ =~ RUBY_PLATFORM
                                  pids.each { |pid| Process.kill 'INT', pid.to_i rescue nil }
                                else
                                  unless `which pgrep 2> /dev/null`.empty?
                                    children = pids
                                    until children.empty?
                                      children = children.map { |pid|
                                        `pgrep -P #{pid}`.lines.map { |l| l.chomp }
                                      }.flatten
                                      pids += children
                                    end
                                  end
                                  pids.each { |pid| Process.kill 'TERM', pid.to_i rescue nil }
                                end
                              end
                            
                              def compare_git_uri a, b
                                regex = %r{^(?:\w+://)?(?:[^@/]*@)?([^:/]*(?::[0-9]*)?)[:/](.*?)(?:\.git)?/?$}
                                regex.match(a).to_a.drop(1) == regex.match(b).to_a.drop(1)
                              end
                            
                              require 'thread'
                              require 'fileutils'
                              require 'timeout'
                              running = true
                              iswin = VIM::evaluate('s:is_win').to_i == 1
                              pull  = VIM::evaluate('s:update.pull').to_i == 1
                              base  = VIM::evaluate('g:plug_home')
                              all   = VIM::evaluate('s:update.todo')
                              limit = VIM::evaluate('get(g:, "plug_timeout", 60)')
                              tries = VIM::evaluate('get(g:, "plug_retries", 2)') + 1
                              nthr  = VIM::evaluate('s:update.threads').to_i
                              maxy  = VIM::evaluate('winheight(".")').to_i
                              vim7  = VIM::evaluate('v:version').to_i <= 703 && RUBY_PLATFORM =~ /darwin/
                              cd    = iswin ? 'cd /d' : 'cd'
                              tot   = VIM::evaluate('len(s:update.todo)') || 0
                              bar   = ''
                              skip  = 'Already installed'
                              mtx   = Mutex.new
                              take1 = proc { mtx.synchronize { running && all.shift } }
                              logh  = proc {
                                cnt = bar.length
                                $curbuf[1] = "#{pull ? 'Updating' : 'Installing'} plugins (#{cnt}/#{tot})"
                                $curbuf[2] = '[' + bar.ljust(tot) + ']'
                                VIM::command('normal! 2G')
                                VIM::command('redraw')
                              }
                              where = proc { |name| (1..($curbuf.length)).find { |l| $curbuf[l] =~ /^[-+x*] #{name}:/ } }
                              log   = proc { |name, result, type|
                                mtx.synchronize do
                                  ing  = ![true, false].include?(type)
                                  bar += type ? '=' : 'x' unless ing
                                  b = case type
                                      when :install  then '+' when :update then '*'
                                      when true, nil then '-' else
                                        VIM::command("call add(s:update.errors, '#{name}')")
                                        'x'
                                      end
                                  result =
                                    if type || type.nil?
                                      ["#{b} #{name}: #{result.lines.to_a.last || 'OK'}"]
                                    elsif result =~ /^Interrupted|^Timeout/
                                      ["#{b} #{name}: #{result}"]
                                    else
                                      ["#{b} #{name}"] + result.lines.map { |l| "    " << l }
                                    end
                                  if lnum = where.call(name)
                                    $curbuf.delete lnum
                                    lnum = 4 if ing && lnum > maxy
                                  end
                                  result.each_with_index do |line, offset|
                                    $curbuf.append((lnum || 4) - 1 + offset, line.gsub(/\e\[./, '').chomp)
                                  end
                                  logh.call
                                end
                              }
                              bt = proc { |cmd, name, type, cleanup|
                                tried = timeout = 0
                                begin
                                  tried += 1
                                  timeout += limit
                                  fd = nil
                                  data = ''
                                  if iswin
                                    Timeout::timeout(timeout) do
                                      tmp = VIM::evaluate('tempname()')
                                      system("(#{cmd}) > #{tmp}")
                                      data = File.read(tmp).chomp
                                      File.unlink tmp rescue nil
                                    end
                                  else
                                    fd = IO.popen(cmd).extend(PlugStream)
                                    first_line = true
                                    log_prob = 1.0 / nthr
                                    while line = Timeout::timeout(timeout) { fd.get_line }
                                      data << line
                                      log.call name, line.chomp, type if name && (first_line || rand < log_prob)
                                      first_line = false
                                    end
                                    fd.close
                                  end
                                  [$? == 0, data.chomp]
                                rescue Timeout::Error, Interrupt => e
                                  if fd && !fd.closed?
                                    killall fd.pid
                                    fd.close
                                  end
                                  cleanup.call if cleanup
                                  if e.is_a?(Timeout::Error) && tried < tries
                                    3.downto(1) do |countdown|
                                      s = countdown > 1 ? 's' : ''
                                      log.call name, "Timeout. Will retry in #{countdown} second#{s} ...", type
                                      sleep 1
                                    end
                                    log.call name, 'Retrying ...', type
                                    retry
                                  end
                                  [false, e.is_a?(Interrupt) ? "Interrupted!" : "Timeout!"]
                                end
                              }
                              main = Thread.current
                              threads = []
                              watcher = Thread.new {
                                if vim7
                                  while VIM::evaluate('getchar(1)')
                                    sleep 0.1
                                  end
                                else
                                  require 'io/console' # >= Ruby 1.9
                                  nil until IO.console.getch == 3.chr
                                end
                                mtx.synchronize do
                                  running = false
                                  threads.each { |t| t.raise Interrupt } unless vim7
                                end
                                threads.each { |t| t.join rescue nil }
                                main.kill
                              }
                              refresh = Thread.new {
                                while true
                                  mtx.synchronize do
                                    break unless running
                                    VIM::command('noautocmd normal! a')
                                  end
                                  sleep 0.2
                                end
                              } if VIM::evaluate('s:mac_gui') == 1
                            
                              clone_opt = VIM::evaluate('s:clone_opt')
                              progress = VIM::evaluate('s:progress_opt(1)')
                              nthr.times do
                                mtx.synchronize do
                                  threads << Thread.new {
                                    while pair = take1.call
                                      name = pair.first
                                      dir, uri, tag = pair.last.values_at *%w[dir uri tag]
                                      exists = File.directory? dir
                                      ok, result =
                                        if exists
                                          chdir = "#{cd} #{iswin ? dir : esc(dir)}"
                                          ret, data = bt.call "#{chdir} && git rev-parse --abbrev-ref HEAD 2>&1 && git config -f .git/config remote.origin.url", nil, nil, nil
                                          current_uri = data.lines.to_a.last
                                          if !ret
                                            if data =~ /^Interrupted|^Timeout/
                                              [false, data]
                                            else
                                              [false, [data.chomp, "PlugClean required."].join($/)]
                                            end
                                          elsif !compare_git_uri(current_uri, uri)
                                            [false, ["Invalid URI: #{current_uri}",
                                                     "Expected:    #{uri}",
                                                     "PlugClean required."].join($/)]
                                          else
                                            if pull
                                              log.call name, 'Updating ...', :update
                                              fetch_opt = (tag && File.exist?(File.join(dir, '.git/shallow'))) ? '--depth 99999999' : ''
                                              bt.call "#{chdir} && git fetch #{fetch_opt} #{progress} 2>&1", name, :update, nil
                                            else
                                              [true, skip]
                                            end
                                          end
                                        else
                                          d = esc dir.sub(%r{[\\/]+$}, '')
                                          log.call name, 'Installing ...', :install
                                          bt.call "git clone #{clone_opt unless tag} #{progress} #{uri} #{d} 2>&1", name, :install, proc {
                                            FileUtils.rm_rf dir
                                          }
                                        end
                                      mtx.synchronize { VIM::command("let s:update.new['#{name}'] = 1") } if !exists && ok
                                      log.call name, result, ok
                                    end
                                  } if running
                                end
                              end
                              threads.each { |t| t.join rescue nil }
                              logh.call
                              refresh.kill if refresh
                              watcher.kill
                            EOF
                            endfunction
                            
    1              0.000003 function! s:shellesc(arg)
                              return '"'.escape(a:arg, '"').'"'
                            endfunction
                            
    1              0.000001 function! s:glob_dir(path)
                              return map(filter(s:glob(a:path, '**'), 'isdirectory(v:val)'), 's:dirpath(v:val)')
                            endfunction
                            
    1              0.000003 function! s:progress_bar(line, bar, total)
                              call setline(a:line, '[' . s:lpad(a:bar, a:total) . ']')
                            endfunction
                            
    1              0.000002 function! s:compare_git_uri(a, b)
                              " See `git help clone'
                              " https:// [user@] github.com[:port] / junegunn/vim-plug [.git]
                              "          [git@]  github.com[:port] : junegunn/vim-plug [.git]
                              " file://                            / junegunn/vim-plug        [/]
                              "                                    / junegunn/vim-plug        [/]
                              let pat = '^\%(\w\+://\)\='.'\%([^@/]*@\)\='.'\([^:/]*\%(:[0-9]*\)\=\)'.'[:/]'.'\(.\{-}\)'.'\%(\.git\)\=/\?$'
                              let ma = matchlist(a:a, pat)
                              let mb = matchlist(a:b, pat)
                              return ma[1:2] ==# mb[1:2]
                            endfunction
                            
    1              0.000003 function! s:format_message(bullet, name, message)
                              if a:bullet != 'x'
                                return [printf('%s %s: %s', a:bullet, a:name, s:lastline(a:message))]
                              else
                                let lines = map(s:lines(a:message), '"    ".v:val')
                                return extend([printf('x %s:', a:name)], lines)
                              endif
                            endfunction
                            
    1              0.000002 function! s:with_cd(cmd, dir)
                              return printf('cd%s %s && %s', s:is_win ? ' /d' : '', s:shellesc(a:dir), a:cmd)
                            endfunction
                            
    1              0.000002 function! s:system(cmd, ...)
                              try
                                let [sh, shrd] = s:chsh(1)
                                let cmd = a:0 > 0 ? s:with_cd(a:cmd, a:1) : a:cmd
                                return system(s:is_win ? '('.cmd.')' : cmd)
                              finally
                                let [&shell, &shellredir] = [sh, shrd]
                              endtry
                            endfunction
                            
    1              0.000002 function! s:system_chomp(...)
                              let ret = call('s:system', a:000)
                              return v:shell_error ? '' : substitute(ret, '\n$', '', '')
                            endfunction
                            
    1              0.000002 function! s:git_validate(spec, check_branch)
                              let err = ''
                              if isdirectory(a:spec.dir)
                                let result = s:lines(s:system('git rev-parse --abbrev-ref HEAD 2>&1 && git config -f .git/config remote.origin.url', a:spec.dir))
                                let remote = result[-1]
                                if v:shell_error
                                  let err = join([remote, 'PlugClean required.'], "\n")
                                elseif !s:compare_git_uri(remote, a:spec.uri)
                                  let err = join(['Invalid URI: '.remote,
                                                \ 'Expected:    '.a:spec.uri,
                                                \ 'PlugClean required.'], "\n")
                                elseif a:check_branch && has_key(a:spec, 'commit')
                                  let result = s:lines(s:system('git rev-parse HEAD 2>&1', a:spec.dir))
                                  let sha = result[-1]
                                  if v:shell_error
                                    let err = join(add(result, 'PlugClean required.'), "\n")
                                  elseif !s:hash_match(sha, a:spec.commit)
                                    let err = join([printf('Invalid HEAD (expected: %s, actual: %s)',
                                                          \ a:spec.commit[:6], sha[:6]),
                                                  \ 'PlugUpdate required.'], "\n")
                                  endif
                                elseif a:check_branch
                                  let branch = result[0]
                                  " Check tag
                                  if has_key(a:spec, 'tag')
                                    let tag = s:system_chomp('git describe --exact-match --tags HEAD 2>&1', a:spec.dir)
                                    if a:spec.tag !=# tag && a:spec.tag !~ '\*'
                                      let err = printf('Invalid tag: %s (expected: %s). Try PlugUpdate.',
                                            \ (empty(tag) ? 'N/A' : tag), a:spec.tag)
                                    endif
                                  " Check branch
                                  elseif a:spec.branch !=# branch
                                    let err = printf('Invalid branch: %s (expected: %s). Try PlugUpdate.',
                                          \ branch, a:spec.branch)
                                  endif
                                  if empty(err)
                                    let [ahead, behind] = split(s:lastline(s:system(printf(
                                          \ 'git rev-list --count --left-right HEAD...origin/%s',
                                          \ a:spec.branch), a:spec.dir)), '\t')
                                    if !v:shell_error && ahead
                                      if behind
                                        " Only mention PlugClean if diverged, otherwise it's likely to be
                                        " pushable (and probably not that messed up).
                                        let err = printf(
                                              \ "Diverged from origin/%s (%d commit(s) ahead and %d commit(s) behind!\n"
                                              \ .'Backup local changes and run PlugClean and PlugUpdate to reinstall it.', a:spec.branch, ahead, behind)
                                      else
                                        let err = printf("Ahead of origin/%s by %d commit(s).\n"
                                              \ .'Cannot update until local changes are pushed.',
                                              \ a:spec.branch, ahead)
                                      endif
                                    endif
                                  endif
                                endif
                              else
                                let err = 'Not found'
                              endif
                              return [err, err =~# 'PlugClean']
                            endfunction
                            
    1              0.000002 function! s:rm_rf(dir)
                              if isdirectory(a:dir)
                                call s:system((s:is_win ? 'rmdir /S /Q ' : 'rm -rf ') . s:shellesc(a:dir))
                              endif
                            endfunction
                            
    1              0.000002 function! s:clean(force)
                              call s:prepare()
                              call append(0, 'Searching for invalid plugins in '.g:plug_home)
                              call append(1, '')
                            
                              " List of valid directories
                              let dirs = []
                              let errs = {}
                              let [cnt, total] = [0, len(g:plugs)]
                              for [name, spec] in items(g:plugs)
                                if !s:is_managed(name)
                                  call add(dirs, spec.dir)
                                else
                                  let [err, clean] = s:git_validate(spec, 1)
                                  if clean
                                    let errs[spec.dir] = s:lines(err)[0]
                                  else
                                    call add(dirs, spec.dir)
                                  endif
                                endif
                                let cnt += 1
                                call s:progress_bar(2, repeat('=', cnt), total)
                                normal! 2G
                                redraw
                              endfor
                            
                              let allowed = {}
                              for dir in dirs
                                let allowed[s:dirpath(fnamemodify(dir, ':h:h'))] = 1
                                let allowed[dir] = 1
                                for child in s:glob_dir(dir)
                                  let allowed[child] = 1
                                endfor
                              endfor
                            
                              let todo = []
                              let found = sort(s:glob_dir(g:plug_home))
                              while !empty(found)
                                let f = remove(found, 0)
                                if !has_key(allowed, f) && isdirectory(f)
                                  call add(todo, f)
                                  call append(line('$'), '- ' . f)
                                  if has_key(errs, f)
                                    call append(line('$'), '    ' . errs[f])
                                  endif
                                  let found = filter(found, 'stridx(v:val, f) != 0')
                                end
                              endwhile
                            
                              4
                              redraw
                              if empty(todo)
                                call append(line('$'), 'Already clean.')
                              else
                                let s:clean_count = 0
                                call append(3, ['Directories to delete:', ''])
                                redraw!
                                if a:force || s:ask_no_interrupt('Delete all directories?')
                                  call s:delete([6, line('$')], 1)
                                else
                                  call setline(4, 'Cancelled.')
                                  nnoremap <silent> <buffer> d :set opfunc=<sid>delete_op<cr>g@
                                  nmap     <silent> <buffer> dd d_
                                  xnoremap <silent> <buffer> d :<c-u>call <sid>delete_op(visualmode(), 1)<cr>
                                  echo 'Delete the lines (d{motion}) to delete the corresponding directories'
                                endif
                              endif
                              4
                              setlocal nomodifiable
                            endfunction
                            
    1              0.000002 function! s:delete_op(type, ...)
                              call s:delete(a:0 ? [line("'<"), line("'>")] : [line("'["), line("']")], 0)
                            endfunction
                            
    1              0.000002 function! s:delete(range, force)
                              let [l1, l2] = a:range
                              let force = a:force
                              while l1 <= l2
                                let line = getline(l1)
                                if line =~ '^- ' && isdirectory(line[2:])
                                  execute l1
                                  redraw!
                                  let answer = force ? 1 : s:ask('Delete '.line[2:].'?', 1)
                                  let force = force || answer > 1
                                  if answer
                                    call s:rm_rf(line[2:])
                                    setlocal modifiable
                                    call setline(l1, '~'.line[1:])
                                    let s:clean_count += 1
                                    call setline(4, printf('Removed %d directories.', s:clean_count))
                                    setlocal nomodifiable
                                  endif
                                endif
                                let l1 += 1
                              endwhile
                            endfunction
                            
    1              0.000002 function! s:upgrade()
                              echo 'Downloading the latest version of vim-plug'
                              redraw
                              let tmp = tempname()
                              let new = tmp . '/plug.vim'
                            
                              try
                                let out = s:system(printf('git clone --depth 1 %s %s', s:plug_src, tmp))
                                if v:shell_error
                                  return s:err('Error upgrading vim-plug: '. out)
                                endif
                            
                                if readfile(s:me) ==# readfile(new)
                                  echo 'vim-plug is already up-to-date'
                                  return 0
                                else
                                  call rename(s:me, s:me . '.old')
                                  call rename(new, s:me)
                                  unlet g:loaded_plug
                                  echo 'vim-plug has been upgraded'
                                  return 1
                                endif
                              finally
                                silent! call s:rm_rf(tmp)
                              endtry
                            endfunction
                            
    1              0.000002 function! s:upgrade_specs()
                              for spec in values(g:plugs)
                                let spec.frozen = get(spec, 'frozen', 0)
                              endfor
                            endfunction
                            
    1              0.000002 function! s:status()
                              call s:prepare()
                              call append(0, 'Checking plugins')
                              call append(1, '')
                            
                              let ecnt = 0
                              let unloaded = 0
                              let [cnt, total] = [0, len(g:plugs)]
                              for [name, spec] in items(g:plugs)
                                if has_key(spec, 'uri')
                                  if isdirectory(spec.dir)
                                    let [err, _] = s:git_validate(spec, 1)
                                    let [valid, msg] = [empty(err), empty(err) ? 'OK' : err]
                                  else
                                    let [valid, msg] = [0, 'Not found. Try PlugInstall.']
                                  endif
                                else
                                  if isdirectory(spec.dir)
                                    let [valid, msg] = [1, 'OK']
                                  else
                                    let [valid, msg] = [0, 'Not found.']
                                  endif
                                endif
                                let cnt += 1
                                let ecnt += !valid
                                " `s:loaded` entry can be missing if PlugUpgraded
                                if valid && get(s:loaded, name, -1) == 0
                                  let unloaded = 1
                                  let msg .= ' (not loaded)'
                                endif
                                call s:progress_bar(2, repeat('=', cnt), total)
                                call append(3, s:format_message(valid ? '-' : 'x', name, msg))
                                normal! 2G
                                redraw
                              endfor
                              call setline(1, 'Finished. '.ecnt.' error(s).')
                              normal! gg
                              setlocal nomodifiable
                              if unloaded
                                echo "Press 'L' on each line to load plugin, or 'U' to update"
                                nnoremap <silent> <buffer> L :call <SID>status_load(line('.'))<cr>
                                xnoremap <silent> <buffer> L :call <SID>status_load(line('.'))<cr>
                              end
                            endfunction
                            
    1              0.000002 function! s:extract_name(str, prefix, suffix)
                              return matchstr(a:str, '^'.a:prefix.' \zs[^:]\+\ze:.*'.a:suffix.'$')
                            endfunction
                            
    1              0.000002 function! s:status_load(lnum)
                              let line = getline(a:lnum)
                              let name = s:extract_name(line, '-', '(not loaded)')
                              if !empty(name)
                                call plug#load(name)
                                setlocal modifiable
                                call setline(a:lnum, substitute(line, ' (not loaded)$', '', ''))
                                setlocal nomodifiable
                              endif
                            endfunction
                            
    1              0.000002 function! s:status_update() range
                              let lines = getline(a:firstline, a:lastline)
                              let names = filter(map(lines, 's:extract_name(v:val, "[x-]", "")'), '!empty(v:val)')
                              if !empty(names)
                                echo
                                execute 'PlugUpdate' join(names)
                              endif
                            endfunction
                            
    1              0.000002 function! s:is_preview_window_open()
                              silent! wincmd P
                              if &previewwindow
                                wincmd p
                                return 1
                              endif
                            endfunction
                            
    1              0.000001 function! s:find_name(lnum)
                              for lnum in reverse(range(1, a:lnum))
                                let line = getline(lnum)
                                if empty(line)
                                  return ''
                                endif
                                let name = s:extract_name(line, '-', '')
                                if !empty(name)
                                  return name
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000002 function! s:preview_commit()
                              if b:plug_preview < 0
                                let b:plug_preview = !s:is_preview_window_open()
                              endif
                            
                              let sha = matchstr(getline('.'), '^  \X*\zs[0-9a-f]\{7,9}')
                              if empty(sha)
                                return
                              endif
                            
                              let name = s:find_name(line('.'))
                              if empty(name) || !has_key(g:plugs, name) || !isdirectory(g:plugs[name].dir)
                                return
                              endif
                            
                              if exists('g:plug_pwindow') && !s:is_preview_window_open()
                                execute g:plug_pwindow
                                execute 'e' sha
                              else
                                execute 'pedit' sha
                                wincmd P
                              endif
                              setlocal previewwindow filetype=git buftype=nofile nobuflisted modifiable
                              try
                                let [sh, shrd] = s:chsh(1)
                                execute 'silent %!cd' s:shellesc(g:plugs[name].dir) '&& git show --no-color --pretty=medium' sha
                              finally
                                let [&shell, &shellredir] = [sh, shrd]
                              endtry
                              setlocal nomodifiable
                              nnoremap <silent> <buffer> q :q<cr>
                              wincmd p
                            endfunction
                            
    1              0.000002 function! s:section(flags)
                              call search('\(^[x-] \)\@<=[^:]\+:', a:flags)
                            endfunction
                            
    1              0.000002 function! s:format_git_log(line)
                              let indent = '  '
                              let tokens = split(a:line, nr2char(1))
                              if len(tokens) != 5
                                return indent.substitute(a:line, '\s*$', '', '')
                              endif
                              let [graph, sha, refs, subject, date] = tokens
                              let tag = matchstr(refs, 'tag: [^,)]\+')
                              let tag = empty(tag) ? ' ' : ' ('.tag.') '
                              return printf('%s%s%s%s%s (%s)', indent, graph, sha, tag, subject, date)
                            endfunction
                            
    1              0.000002 function! s:append_ul(lnum, text)
                              call append(a:lnum, ['', a:text, repeat('-', len(a:text))])
                            endfunction
                            
    1              0.000001 function! s:diff()
                              call s:prepare()
                              call append(0, ['Collecting changes ...', ''])
                              let cnts = [0, 0]
                              let bar = ''
                              let total = filter(copy(g:plugs), 's:is_managed(v:key) && isdirectory(v:val.dir)')
                              call s:progress_bar(2, bar, len(total))
                              for origin in [1, 0]
                                let plugs = reverse(sort(items(filter(copy(total), (origin ? '' : '!').'(has_key(v:val, "commit") || has_key(v:val, "tag"))'))))
                                if empty(plugs)
                                  continue
                                endif
                                call s:append_ul(2, origin ? 'Pending updates:' : 'Last update:')
                                for [k, v] in plugs
                                  let range = origin ? '..origin/'.v.branch : 'HEAD@{1}..'
                                  let diff = s:system_chomp('git log --graph --color=never --pretty=format:"%x01%h%x01%d%x01%s%x01%cr" '.s:shellesc(range), v.dir)
                                  if !empty(diff)
                                    let ref = has_key(v, 'tag') ? (' (tag: '.v.tag.')') : has_key(v, 'commit') ? (' '.v.commit) : ''
                                    call append(5, extend(['', '- '.k.':'.ref], map(s:lines(diff), 's:format_git_log(v:val)')))
                                    let cnts[origin] += 1
                                  endif
                                  let bar .= '='
                                  call s:progress_bar(2, bar, len(total))
                                  normal! 2G
                                  redraw
                                endfor
                                if !cnts[origin]
                                  call append(5, ['', 'N/A'])
                                endif
                              endfor
                              call setline(1, printf('%d plugin(s) updated.', cnts[0])
                                    \ . (cnts[1] ? printf(' %d plugin(s) have pending updates.', cnts[1]) : ''))
                            
                              if cnts[0] || cnts[1]
                                nnoremap <silent> <buffer> <cr> :silent! call <SID>preview_commit()<cr>
                                nnoremap <silent> <buffer> o    :silent! call <SID>preview_commit()<cr>
                              endif
                              if cnts[0]
                                nnoremap <silent> <buffer> X :call <SID>revert()<cr>
                                echo "Press 'X' on each block to revert the update"
                              endif
                              normal! gg
                              setlocal nomodifiable
                            endfunction
                            
    1              0.000002 function! s:revert()
                              if search('^Pending updates', 'bnW')
                                return
                              endif
                            
                              let name = s:find_name(line('.'))
                              if empty(name) || !has_key(g:plugs, name) ||
                                \ input(printf('Revert the update of %s? (y/N) ', name)) !~? '^y'
                                return
                              endif
                            
                              call s:system('git reset --hard HEAD@{1} && git checkout '.s:esc(g:plugs[name].branch).' --', g:plugs[name].dir)
                              setlocal modifiable
                              normal! "_dap
                              setlocal nomodifiable
                              echo 'Reverted'
                            endfunction
                            
    1              0.000003 function! s:snapshot(force, ...) abort
                              call s:prepare()
                              setf vim
                              call append(0, ['" Generated by vim-plug',
                                            \ '" '.strftime("%c"),
                                            \ '" :source this file in vim to restore the snapshot',
                                            \ '" or execute: vim -S snapshot.vim',
                                            \ '', '', 'PlugUpdate!'])
                              1
                              let anchor = line('$') - 3
                              let names = sort(keys(filter(copy(g:plugs),
                                    \'has_key(v:val, "uri") && !has_key(v:val, "commit") && isdirectory(v:val.dir)')))
                              for name in reverse(names)
                                let sha = s:system_chomp('git rev-parse --short HEAD', g:plugs[name].dir)
                                if !empty(sha)
                                  call append(anchor, printf("silent! let g:plugs['%s'].commit = '%s'", name, sha))
                                  redraw
                                endif
                              endfor
                            
                              if a:0 > 0
                                let fn = expand(a:1)
                                if filereadable(fn) && !(a:force || s:ask(a:1.' already exists. Overwrite?'))
                                  return
                                endif
                                call writefile(getline(1, '$'), fn)
                                echo 'Saved as '.a:1
                                silent execute 'e' s:esc(fn)
                                setf vim
                              endif
                            endfunction
                            
    1              0.000002 function! s:split_rtp()
                              return split(&rtp, '\\\@<!,')
                            endfunction
                            
    1   0.000078   0.000028 let s:first_rtp = s:escrtp(get(s:split_rtp(), 0, ''))
    1   0.000048   0.000015 let s:last_rtp  = s:escrtp(get(s:split_rtp(), -1, ''))
                            
    1              0.000003 if exists('g:plugs')
                              let g:plugs_order = get(g:, 'plugs_order', keys(g:plugs))
                              call s:upgrade_specs()
                              call s:define_commands()
                            endif
                            
    1              0.000008 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/ftoff.vim
Sourced 1 time
Total time:   0.000653
 Self time:   0.000653

count  total (s)   self (s)
                            " Vim support file to switch off detection of file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2001 Jun 11
                            
    1              0.000007 if exists("did_load_filetypes")
    1              0.000003   unlet did_load_filetypes
    1              0.000001 endif
                            
                            " Remove all autocommands in the filetypedetect group
    1              0.000635 silent! au! filetypedetect *

SCRIPT  /home/user/fbarotjr/.vim/plugged/vim-perl/ftdetect/mason-in-html.vim
Sourced 1 time
Total time:   0.000201
 Self time:   0.000201

count  total (s)   self (s)
                            " Highlight .html files as Mason if they start with Mason tags
    1              0.000125 autocmd BufRead *.html

SCRIPT  /home/user/fbarotjr/.vim/plugged/vim-perl/ftdetect/perl11.vim
Sourced 1 time
Total time:   0.000214
 Self time:   0.000214

count  total (s)   self (s)
                            function! s:DetectPerl6()
                              let line_no = 1
                              let eof     = line('$')
                              let in_pod  = 0
                            
                              while line_no <= eof
                                let line    = getline(line_no)
                                let line_no = line_no + 1
                            
                                if line =~ '^=\w'
                                  let in_pod = 1
                                elseif line =~ '^=\%(end\|cut\)'
                                  let in_pod = 0
                                elseif !in_pod
                                  let line = substitute(line, '#.*', '', '')
                            
                                  if line =~ '^\s*$'
                                    continue
                                  endif
                            
                                  if line =~ '^\s*\%(use\s\+\)\=v6\%(\.\d\%(\.\d\)\=\)\=;'
                                    set filetype=perl6 " we matched a 'use v6' declaration
                                  elseif line =~ '^\s*\%(\%(my\|our\)\s\+\)\=\%(unit\s\+\)\=\(module\|class\|role\|enum\|grammar\)'
                                    set filetype=perl6 " we found a class, role, module, enum, or grammar declaration
                                  endif
                            
                                  break " we either found what we needed, or we found a non-POD, non-comment,
                                        " non-Perl 6 indicating line, so bail out
                                endif
                              endwhile
                            endfunction
                            
    1              0.000060 autocmd BufReadPost *.pl,*.pm,*.t call s:DetectPerl6()
    1              0.000115 autocmd BufNew,BufNewFile,BufRead *.nqp setf perl6

SCRIPT  /home/user/fbarotjr/.vim/plugged/gruvbox/colors/gruvbox.vim
Sourced 2 times
Total time:   0.037555
 Self time:   0.026393

count  total (s)   self (s)
                            " -----------------------------------------------------------------------------
                            " File: gruvbox.vim
                            " Description: Retro groove color scheme for Vim
                            " Author: morhetz <morhetz@gmail.com>
                            " Source: https://github.com/morhetz/gruvbox
                            " Last Modified: 04 Sep 2015
                            " -----------------------------------------------------------------------------
                            
                            " Supporting code -------------------------------------------------------------
                            " Initialisation: {{{
                            "
                            
    2              0.000022 if version > 580
    2              0.004167   hi clear
    2              0.000015   if exists("syntax_on")
    2              0.015325     syntax reset
    2              0.000004   endif
    2              0.000002 endif
                            
    2              0.000011 let g:colors_name='gruvbox'
                            
    2              0.000020 if !has('gui_running') && &t_Co != 256
                              finish
                            endif
                            
                            " }}}
                            " Global Settings: {{{
                            
    2              0.000005 if !exists('g:gruvbox_bold')
    1              0.000002   let g:gruvbox_bold=1
    1              0.000001 endif
    2              0.000005 if !exists('g:gruvbox_italic')
    1              0.000008   if has('gui_running') || $TERM_ITALICS == 'true'
                                let g:gruvbox_italic=1
                              else
    1              0.000002     let g:gruvbox_italic=0
    1              0.000001   endif
    1              0.000001 endif
    2              0.000004 if !exists('g:gruvbox_undercurl')
    1              0.000001   let g:gruvbox_undercurl=1
    1              0.000001 endif
    2              0.000006 if !exists('g:gruvbox_underline')
    1              0.000002   let g:gruvbox_underline=1
    1              0.000001 endif
    2              0.000004 if !exists('g:gruvbox_inverse')
    1              0.000002   let g:gruvbox_inverse=1
    1              0.000001 endif
                            
    2              0.000016 if !exists('g:gruvbox_guisp_fallback') || index(['fg', 'bg'], g:gruvbox_guisp_fallback) == -1
    2              0.000005   let g:gruvbox_guisp_fallback='NONE'
    2              0.000002 endif
                            
    2              0.000006 if !exists('g:gruvbox_improved_strings')
    1              0.000002   let g:gruvbox_improved_strings=0
    1              0.000001 endif
                            
    2              0.000005 if !exists('g:gruvbox_improved_warnings')
    1              0.000002   let g:gruvbox_improved_warnings=0
    1              0.000001 endif
                            
    2              0.000005 if !exists('g:gruvbox_termcolors')
    1              0.000002   let g:gruvbox_termcolors=256
    1              0.000001 endif
                            
    2              0.000007 if !exists('g:gruvbox_invert_indent_guides')
    1              0.000004   let g:gruvbox_invert_indent_guides=0
    1              0.000001 endif
                            
    2              0.000006 if exists('g:gruvbox_contrast')
                              echo 'g:gruvbox_contrast is deprecated; use g:gruvbox_contrast_light and g:gruvbox_contrast_dark instead'
                            endif
                            
    2              0.000005 if !exists('g:gruvbox_contrast_dark')
    1              0.000003   let g:gruvbox_contrast_dark='medium'
    1              0.000000 endif
                            
    2              0.000005 if !exists('g:gruvbox_contrast_light')
    1              0.000003   let g:gruvbox_contrast_light='medium'
    1              0.000000 endif
                            
    2              0.000006 let s:is_dark=(&background == 'dark')
                            
                            " }}}
                            " Palette: {{{
                            
                            " setup palette dictionary
    2              0.000021 let s:gb = {}
                            
                            " fill it with absolute colors
    2              0.000011 let s:gb.dark0_hard  = ['#1d2021', 234]     " 29-32-33
    2              0.000006 let s:gb.dark0       = ['#282828', 235]     " 40-40-40
    2              0.000007 let s:gb.dark0_soft  = ['#32302f', 236]     " 50-48-47
    2              0.000005 let s:gb.dark1       = ['#3c3836', 237]     " 60-56-54
    2              0.000005 let s:gb.dark2       = ['#504945', 239]     " 80-73-69
    2              0.000004 let s:gb.dark3       = ['#665c54', 241]     " 102-92-84
    2              0.000004 let s:gb.dark4       = ['#7c6f64', 243]     " 124-111-100
    2              0.000004 let s:gb.dark4_256   = ['#7c6f64', 243]     " 124-111-100
                            
    2              0.000004 let s:gb.gray_245    = ['#928374', 245]     " 146-131-116
    2              0.000004 let s:gb.gray_244    = ['#928374', 244]     " 146-131-116
                            
    2              0.000005 let s:gb.light0_hard = ['#f9f5d7', 230]     " 249-245-215
    2              0.000005 let s:gb.light0      = ['#fbf1c7', 229]     " 253-244-193
    2              0.000004 let s:gb.light0_soft = ['#f2e5bc', 228]     " 242-229-188
    2              0.000004 let s:gb.light1      = ['#ebdbb2', 223]     " 235-219-178
    2              0.000008 let s:gb.light2      = ['#d5c4a1', 250]     " 213-196-161
    2              0.000004 let s:gb.light3      = ['#bdae93', 248]     " 189-174-147
    2              0.000004 let s:gb.light4      = ['#a89984', 246]     " 168-153-132
    2              0.000005 let s:gb.light4_256  = ['#a89984', 246]     " 168-153-132
                            
    2              0.000004 let s:gb.bright_red     = ['#fb4934', 167]     " 251-73-52
    2              0.000004 let s:gb.bright_green   = ['#b8bb26', 142]     " 184-187-38
    2              0.000004 let s:gb.bright_yellow  = ['#fabd2f', 214]     " 250-189-47
    2              0.000005 let s:gb.bright_blue    = ['#83a598', 109]     " 131-165-152
    2              0.000004 let s:gb.bright_purple  = ['#d3869b', 175]     " 211-134-155
    2              0.000004 let s:gb.bright_aqua    = ['#8ec07c', 108]     " 142-192-124
    2              0.000005 let s:gb.bright_orange  = ['#fe8019', 208]     " 254-128-25
                            
    2              0.000005 let s:gb.neutral_red    = ['#cc241d', 124]     " 204-36-29
    2              0.000005 let s:gb.neutral_green  = ['#98971a', 106]     " 152-151-26
    2              0.000004 let s:gb.neutral_yellow = ['#d79921', 172]     " 215-153-33
    2              0.000004 let s:gb.neutral_blue   = ['#458588', 66]      " 69-133-136
    2              0.000005 let s:gb.neutral_purple = ['#b16286', 132]     " 177-98-134
    2              0.000004 let s:gb.neutral_aqua   = ['#689d6a', 72]      " 104-157-106
    2              0.000005 let s:gb.neutral_orange = ['#d65d0e', 166]     " 214-93-14
                            
    2              0.000004 let s:gb.faded_red      = ['#9d0006', 88]      " 157-0-6
    2              0.000006 let s:gb.faded_green    = ['#79740e', 100]     " 121-116-14
    2              0.000005 let s:gb.faded_yellow   = ['#b57614', 136]     " 181-118-20
    2              0.000005 let s:gb.faded_blue     = ['#076678', 24]      " 7-102-120
    2              0.000004 let s:gb.faded_purple   = ['#8f3f71', 96]      " 143-63-113
    2              0.000004 let s:gb.faded_aqua     = ['#427b58', 66]      " 66-123-88
    2              0.000005 let s:gb.faded_orange   = ['#af3a03', 130]     " 175-58-3
                            
                            " }}}
                            " Setup Emphasis: {{{
                            
    2              0.000004 let s:bold = 'bold,'
    2              0.000004 if g:gruvbox_bold == 0
    1              0.000002   let s:bold = ''
    1              0.000001 endif
                            
    2              0.000004 let s:italic = 'italic,'
    2              0.000004 if g:gruvbox_italic == 0
    2              0.000002   let s:italic = ''
    2              0.000002 endif
                            
    2              0.000004 let s:underline = 'underline,'
    2              0.000003 if g:gruvbox_underline == 0
                              let s:underline = ''
                            endif
                            
    2              0.000004 let s:undercurl = 'undercurl,'
    2              0.000004 if g:gruvbox_undercurl == 0
                              let s:undercurl = ''
                            endif
                            
    2              0.000004 let s:inverse = 'inverse,'
    2              0.000002 if g:gruvbox_inverse == 0
                              let s:inverse = ''
                            endif
                            
                            " }}}
                            " Setup Colors: {{{
                            
    2              0.000004 let s:vim_bg = ['bg', 'bg']
    2              0.000004 let s:vim_fg = ['fg', 'fg']
    2              0.000004 let s:none = ['NONE', 'NONE']
                            
                            " determine relative colors
    2              0.000002 if s:is_dark
    2              0.000005   let s:bg0  = s:gb.dark0
    2              0.000005   if g:gruvbox_contrast_dark == 'soft'
                                let s:bg0  = s:gb.dark0_soft
                              elseif g:gruvbox_contrast_dark == 'hard'
                                let s:bg0  = s:gb.dark0_hard
                              endif
                            
    2              0.000005   let s:bg1  = s:gb.dark1
    2              0.000004   let s:bg2  = s:gb.dark2
    2              0.000003   let s:bg3  = s:gb.dark3
    2              0.000003   let s:bg4  = s:gb.dark4
                            
    2              0.000004   let s:gray = s:gb.gray_245
                            
    2              0.000004   let s:fg0 = s:gb.light0
    2              0.000004   let s:fg1 = s:gb.light1
    2              0.000003   let s:fg2 = s:gb.light2
    2              0.000002   let s:fg3 = s:gb.light3
    2              0.000003   let s:fg4 = s:gb.light4
                            
    2              0.000004   let s:fg4_256 = s:gb.light4_256
                            
    2              0.000003   let s:red    = s:gb.bright_red
    2              0.000004   let s:green  = s:gb.bright_green
    2              0.000004   let s:yellow = s:gb.bright_yellow
    2              0.000003   let s:blue   = s:gb.bright_blue
    2              0.000004   let s:purple = s:gb.bright_purple
    2              0.000004   let s:aqua   = s:gb.bright_aqua
    2              0.000004   let s:orange = s:gb.bright_orange
    2              0.000002 else
                              let s:bg0  = s:gb.light0
                              if g:gruvbox_contrast_light == 'soft'
                                let s:bg0  = s:gb.light0_soft
                              elseif g:gruvbox_contrast_light == 'hard'
                                let s:bg0  = s:gb.light0_hard
                              endif
                            
                              let s:bg1  = s:gb.light1
                              let s:bg2  = s:gb.light2
                              let s:bg3  = s:gb.light3
                              let s:bg4  = s:gb.light4
                            
                              let s:gray = s:gb.gray_244
                            
                              let s:fg0 = s:gb.dark0
                              let s:fg1 = s:gb.dark1
                              let s:fg2 = s:gb.dark2
                              let s:fg3 = s:gb.dark3
                              let s:fg4 = s:gb.dark4
                            
                              let s:fg4_256 = s:gb.dark4_256
                            
                              let s:red    = s:gb.faded_red
                              let s:green  = s:gb.faded_green
                              let s:yellow = s:gb.faded_yellow
                              let s:blue   = s:gb.faded_blue
                              let s:purple = s:gb.faded_purple
                              let s:aqua   = s:gb.faded_aqua
                              let s:orange = s:gb.faded_orange
                            endif
                            
                            " reset to 16 colors fallback
    2              0.000005 if g:gruvbox_termcolors == 16
                              let s:bg0[1]    = 0
                              let s:fg4[1]    = 7
                              let s:gray[1]   = 8
                              let s:red[1]    = 9
                              let s:green[1]  = 10
                              let s:yellow[1] = 11
                              let s:blue[1]   = 12
                              let s:purple[1] = 13
                              let s:aqua[1]   = 14
                              let s:fg1[1]    = 15
                            endif
                            
                            " save current relative colors back to palette dictionary
    2              0.000004 let s:gb.bg0 = s:bg0
    2              0.000004 let s:gb.bg1 = s:bg1
    2              0.000004 let s:gb.bg2 = s:bg2
    2              0.000006 let s:gb.bg3 = s:bg3
    2              0.000006 let s:gb.bg4 = s:bg4
                            
    2              0.000006 let s:gb.gray = s:gray
                            
    2              0.000006 let s:gb.fg0 = s:fg0
    2              0.000004 let s:gb.fg1 = s:fg1
    2              0.000005 let s:gb.fg2 = s:fg2
    2              0.000006 let s:gb.fg3 = s:fg3
    2              0.000004 let s:gb.fg4 = s:fg4
                            
    2              0.000006 let s:gb.fg4_256 = s:fg4_256
                            
    2              0.000004 let s:gb.red    = s:red
    2              0.000004 let s:gb.green  = s:green
    2              0.000004 let s:gb.yellow = s:yellow
    2              0.000004 let s:gb.blue   = s:blue
    2              0.000003 let s:gb.purple = s:purple
    2              0.000004 let s:gb.aqua   = s:aqua
    2              0.000004 let s:gb.orange = s:orange
                            
                            " }}}
                            
                            " Overload Setting: {{{
                            
    2              0.000004 let s:hls_cursor = s:orange
    2              0.000007 if exists('g:gruvbox_hls_cursor')
                              let s:hls_cursor = get(s:gb, g:gruvbox_hls_cursor)
                            endif
                            
    2              0.000005 let s:number_column = s:none
    2              0.000005 if exists('g:gruvbox_number_column')
                              let s:number_column = get(s:gb, g:gruvbox_number_column)
                            endif
                            
    2              0.000004 let s:sign_column = s:bg1
                            
    2              0.000010 if exists('g:gitgutter_override_sign_column_highlight') &&
                                  \ g:gitgutter_override_sign_column_highlight == 1
                              let s:sign_column = s:number_column
                            else
    2              0.000006   let g:gitgutter_override_sign_column_highlight = 0
                            
    2              0.000006   if exists('g:gruvbox_sign_column')
                                let s:sign_column = get(s:gb, g:gruvbox_sign_column)
                              endif
    2              0.000002 endif
                            
    2              0.000004 let s:color_column = s:bg1
    2              0.000005 if exists('g:gruvbox_color_column')
                              let s:color_column = get(s:gb, g:gruvbox_color_column)
                            endif
                            
    2              0.000004 let s:vert_split = s:bg2
    2              0.000005 if exists('g:gruvbox_vert_split')
                              let s:vert_split = get(s:gb, g:gruvbox_vert_split)
                            endif
                            
    2              0.000004 let s:invert_signs = ''
    2              0.000005 if exists('g:gruvbox_invert_signs')
                              if g:gruvbox_invert_signs == 1
                                let s:invert_signs = s:inverse
                              endif
                            endif
                            
    2              0.000005 let s:invert_selection = s:inverse
    2              0.000005 if exists('g:gruvbox_invert_selection')
                              if g:gruvbox_invert_selection == 0
                                let s:invert_selection = ''
                              endif
                            endif
                            
    2              0.000004 let s:invert_tabline = ''
    2              0.000006 if exists('g:gruvbox_invert_tabline')
                              if g:gruvbox_invert_tabline == 1
                                let s:invert_tabline = s:inverse
                              endif
                            endif
                            
    2              0.000005 let s:italicize_comments = s:italic
    2              0.000009 if exists('g:gruvbox_italicize_comments')
                              if g:gruvbox_italicize_comments == 0
                                let s:italicize_comments = ''
                              endif
                            endif
                            
    2              0.000004 let s:italicize_strings = ''
    2              0.000006 if exists('g:gruvbox_italicize_strings')
                              if g:gruvbox_italicize_strings == 1
                                let s:italicize_strings = s:italic
                              endif
                            endif
                            
                            " }}}
                            " Highlighting Function: {{{
                            
    2              0.000013 function! s:HL(group, fg, ...)
                              " Arguments: group, guifg, guibg, gui, guisp
                            
                              " foreground
                              let fg = a:fg
                            
                              " background
                              if a:0 >= 1
                                let bg = a:1
                              else
                                let bg = s:none
                              endif
                            
                              " emphasis
                              if a:0 >= 2 && strlen(a:2)
                                let emstr = a:2
                              else
                                let emstr = 'NONE,'
                              endif
                            
                              " special fallback
                              if a:0 >= 3
                                if g:gruvbox_guisp_fallback != 'NONE'
                                  let fg = a:3
                                endif
                            
                                " bg fallback mode should invert higlighting
                                if g:gruvbox_guisp_fallback == 'bg'
                                  let emstr .= 'inverse,'
                                endif
                              endif
                            
                              let histring = [ 'hi', a:group,
                                    \ 'guifg=' . fg[0], 'ctermfg=' . fg[1],
                                    \ 'guibg=' . bg[0], 'ctermbg=' . bg[1],
                                    \ 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2]
                                    \ ]
                            
                              " special
                              if a:0 >= 3
                                call add(histring, 'guisp=' . a:3[0])
                              endif
                            
                              execute join(histring, ' ')
                            endfunction
                            
                            " }}}
                            " Gruvbox Hi Groups: {{{
                            
                            " memoize common hi groups
    2   0.000167   0.000043 call s:HL('GruvboxFg0', s:fg0)
    2   0.000114   0.000015 call s:HL('GruvboxFg1', s:fg1)
    2   0.000119   0.000013 call s:HL('GruvboxFg2', s:fg2)
    2   0.000110   0.000013 call s:HL('GruvboxFg3', s:fg3)
    2   0.000111   0.000012 call s:HL('GruvboxFg4', s:fg4)
    2   0.000110   0.000012 call s:HL('GruvboxGray', s:gray)
    2   0.000109   0.000012 call s:HL('GruvboxBg0', s:bg0)
    2   0.000110   0.000012 call s:HL('GruvboxBg1', s:bg1)
    2   0.000109   0.000012 call s:HL('GruvboxBg2', s:bg2)
    2   0.000118   0.000013 call s:HL('GruvboxBg3', s:bg3)
    2   0.000110   0.000012 call s:HL('GruvboxBg4', s:bg4)
                            
    2   0.000108   0.000012 call s:HL('GruvboxRed', s:red)
    2   0.000119   0.000016 call s:HL('GruvboxRedBold', s:red, s:none, s:bold)
    2   0.000109   0.000013 call s:HL('GruvboxGreen', s:green)
    2   0.000114   0.000016 call s:HL('GruvboxGreenBold', s:green, s:none, s:bold)
    2   0.000109   0.000013 call s:HL('GruvboxYellow', s:yellow)
    2   0.000130   0.000015 call s:HL('GruvboxYellowBold', s:yellow, s:none, s:bold)
    2   0.000112   0.000014 call s:HL('GruvboxBlue', s:blue)
    2   0.000113   0.000017 call s:HL('GruvboxBlueBold', s:blue, s:none, s:bold)
    2   0.000116   0.000013 call s:HL('GruvboxPurple', s:purple)
    2   0.000122   0.000015 call s:HL('GruvboxPurpleBold', s:purple, s:none, s:bold)
    2   0.000109   0.000012 call s:HL('GruvboxAqua', s:aqua)
    2   0.000112   0.000014 call s:HL('GruvboxAquaBold', s:aqua, s:none, s:bold)
    2   0.000108   0.000013 call s:HL('GruvboxOrange', s:orange)
    2   0.000112   0.000015 call s:HL('GruvboxOrangeBold', s:orange, s:none, s:bold)
                            
    2   0.000112   0.000015 call s:HL('GruvboxRedSign', s:red, s:sign_column, s:invert_signs)
    2   0.000114   0.000016 call s:HL('GruvboxGreenSign', s:green, s:sign_column, s:invert_signs)
    2   0.000121   0.000016 call s:HL('GruvboxYellowSign', s:yellow, s:sign_column, s:invert_signs)
    2   0.000115   0.000016 call s:HL('GruvboxBlueSign', s:blue, s:sign_column, s:invert_signs)
    2   0.000113   0.000015 call s:HL('GruvboxPurpleSign', s:purple, s:sign_column, s:invert_signs)
    2   0.000124   0.000016 call s:HL('GruvboxAquaSign', s:aqua, s:sign_column, s:invert_signs)
                            
                            " }}}
                            
                            " Vanilla colorscheme ---------------------------------------------------------
                            " General UI: {{{
                            
                            " Normal text
    2   0.000477   0.000016 call s:HL('Normal', s:fg1, s:bg0)
                            
                            " Correct background (see issue #7):
                            " --- Problem with changing between dark and light on 256 color terminal
                            " --- https://github.com/morhetz/gruvbox/issues/7
    2              0.000009 if s:is_dark
    2              0.000021   set background=dark
    2              0.000002 else
                              set background=light
                            endif
                            
    2              0.000004 if version >= 700
                              " Screen line that the cursor is
    2   0.000116   0.000014   call s:HL('CursorLine',   s:none, s:bg1)
                              " Screen column that the cursor is
    2              0.000009   hi! link CursorColumn CursorLine
                            
                              " Tab pages line filler
    2   0.000116   0.000016   call s:HL('TabLineFill', s:bg4, s:vim_bg, s:invert_tabline)
                              " Active tab page label
    2   0.000113   0.000015   call s:HL('TabLineSel', s:vim_bg, s:bg4, s:bold . s:invert_tabline)
                              " Not active tab page label
    2              0.000008   hi! link TabLine TabLineFill
                            
                              " Match paired bracket under the cursor
    2   0.000112   0.000014   call s:HL('MatchParen', s:none, s:bg3, s:bold)
    2              0.000004 endif
                            
    2              0.000004 if version >= 703
                              " Highlighted screen columns
    2   0.000138   0.000014   call s:HL('ColorColumn',  s:none, s:color_column)
                            
                              " Concealed element: \lambda → λ
    2   0.000112   0.000014   call s:HL('Conceal', s:blue, s:none)
                            
                              " Line number of CursorLine
    2   0.000110   0.000013   call s:HL('CursorLineNr', s:yellow, s:bg1)
    2              0.000003 endif
                            
    2              0.000008 hi! link NonText GruvboxBg2
    2              0.000006 hi! link SpecialKey GruvboxBg2
                            
    2   0.000112   0.000017 call s:HL('Visual',    s:none,  s:bg3, s:invert_selection)
    2              0.000008 hi! link VisualNOS Visual
                            
    2   0.000111   0.000013 call s:HL('Search',    s:yellow, s:bg0, s:inverse)
    2   0.000112   0.000014 call s:HL('IncSearch', s:hls_cursor, s:bg0, s:inverse)
                            
    2   0.000122   0.000014 call s:HL('Underlined', s:blue, s:none, s:underline)
                            
    2   0.000116   0.000016 call s:HL('StatusLine',   s:bg4, s:bg0, s:bold . s:inverse)
    2   0.000125   0.000017 call s:HL('StatusLineNC', s:bg2, s:fg4, s:bold . s:inverse)
                            
                            " The column separating vertically split windows
    2   0.000120   0.000014 call s:HL('VertSplit', s:fg4, s:vert_split)
                            
                            " Current match in wildmenu completion
    2   0.000113   0.000014 call s:HL('WildMenu', s:blue, s:bg2, s:bold)
                            
                            " Directory names, special names in listing
    2              0.000007 hi! link Directory GruvboxGreenBold
                            
                            " Titles for output from :set all, :autocmd, etc.
    2              0.000008 hi! link Title GruvboxGreenBold
                            
                            " Error messages on the command line
    2   0.000116   0.000016 call s:HL('ErrorMsg',   s:bg0, s:red, s:bold)
                            " More prompt: -- More --
    2              0.000009 hi! link MoreMsg GruvboxYellowBold
                            " Current mode message: -- INSERT --
    2              0.000007 hi! link ModeMsg GruvboxYellowBold
                            " 'Press enter' prompt and yes/no questions
    2              0.000007 hi! link Question GruvboxOrangeBold
                            " Warning messages
    2              0.000005 hi! link WarningMsg GruvboxRedBold
                            
                            " }}}
                            " Gutter: {{{
                            
                            " Line number for :number and :# commands
    2   0.000111   0.000014 call s:HL('LineNr', s:bg4, s:number_column)
                            
                            " Column where signs are displayed
    2   0.000110   0.000013 call s:HL('SignColumn', s:none, s:sign_column)
                            
                            " Line used for closed folds
    2   0.000112   0.000014 call s:HL('Folded', s:gray, s:bg1, s:italic)
                            " Column where folds are displayed
    2   0.000110   0.000013 call s:HL('FoldColumn', s:gray, s:bg1)
                            
                            " }}}
                            " Cursor: {{{
                            
                            " Character under cursor
    2   0.000107   0.000013 call s:HL('Cursor', s:none, s:none, s:inverse)
                            " Visual mode cursor, selection
    2              0.000009 hi! link vCursor Cursor
                            " Input moder cursor
    2              0.000006 hi! link iCursor Cursor
                            " Language mapping cursor
    2              0.000005 hi! link lCursor Cursor
                            
                            " }}}
                            " Syntax Highlighting: {{{
                            
    2              0.000004 if g:gruvbox_improved_strings == 0
    2              0.000007   hi! link Special GruvboxOrange
    2              0.000002 else
                              call s:HL('Special', s:bg1, s:orange, s:italic)
                            endif
                            
    2   0.000109   0.000013 call s:HL('Comment', s:gray, s:none, s:italicize_comments)
    2   0.000111   0.000015 call s:HL('Todo', s:vim_fg, s:vim_bg, s:bold . s:italic)
    2   0.000111   0.000015 call s:HL('Error', s:red, s:vim_bg, s:bold . s:inverse)
                            
                            " Generic statement
    2              0.000007 hi! link Statement GruvboxRed
                            " if, then, else, endif, swicth, etc.
    2              0.000006 hi! link Conditional GruvboxRed
                            " for, do, while, etc.
    2              0.000006 hi! link Repeat GruvboxRed
                            " case, default, etc.
    2              0.000006 hi! link Label GruvboxRed
                            " try, catch, throw
    2              0.000007 hi! link Exception GruvboxRed
                            " sizeof, "+", "*", etc.
    2              0.000007 hi! link Operator Normal
                            " Any other keyword
    2              0.000006 hi! link Keyword GruvboxRed
                            
                            " Variable name
    2              0.000007 hi! link Identifier GruvboxBlue
                            " Function name
    2              0.000006 hi! link Function GruvboxGreenBold
                            
                            " Generic preprocessor
    2              0.000007 hi! link PreProc GruvboxAqua
                            " Preprocessor #include
    2              0.000007 hi! link Include GruvboxAqua
                            " Preprocessor #define
    2              0.000005 hi! link Define GruvboxAqua
                            " Same as Define
    2              0.000005 hi! link Macro GruvboxAqua
                            " Preprocessor #if, #else, #endif, etc.
    2              0.000006 hi! link PreCondit GruvboxAqua
                            
                            " Generic constant
    2              0.000007 hi! link Constant GruvboxPurple
                            " Character constant: 'c', '/n'
    2              0.000007 hi! link Character GruvboxPurple
                            " String constant: "this is a string"
    2              0.000004 if g:gruvbox_improved_strings == 0
    2   0.000112   0.000015   call s:HL('String',  s:green, s:none, s:italicize_strings)
    2              0.000003 else
                              call s:HL('String',  s:bg1, s:fg1, s:italicize_strings)
                            endif
                            " Boolean constant: TRUE, false
    2              0.000007 hi! link Boolean GruvboxPurple
                            " Number constant: 234, 0xff
    2              0.000007 hi! link Number GruvboxPurple
                            " Floating point constant: 2.3e10
    2              0.000006 hi! link Float GruvboxPurple
                            
                            " Generic type
    2              0.000007 hi! link Type GruvboxYellow
                            " static, register, volatile, etc
    2              0.000006 hi! link StorageClass GruvboxOrange
                            " struct, union, enum, etc.
    2              0.000005 hi! link Structure GruvboxAqua
                            " typedef
    2              0.000005 hi! link Typedef GruvboxYellow
                            
                            " }}}
                            " Completion Menu: {{{
                            
    2              0.000003 if version >= 700
                              " Popup menu: normal item
    2   0.000118   0.000012   call s:HL('Pmenu', s:fg1, s:bg2)
                              " Popup menu: selected item
    2   0.000126   0.000015   call s:HL('PmenuSel', s:bg2, s:blue, s:bold)
                              " Popup menu: scrollbar
    2   0.000112   0.000014   call s:HL('PmenuSbar', s:none, s:bg2)
                              " Popup menu: scrollbar thumb
    2   0.000116   0.000013   call s:HL('PmenuThumb', s:none, s:bg4)
    2              0.000003 endif
                            
                            " }}}
                            " Diffs: {{{
                            
    2   0.000118   0.000014 call s:HL('DiffDelete', s:red, s:bg0, s:inverse)
    2   0.000112   0.000015 call s:HL('DiffAdd',    s:green, s:bg0, s:inverse)
                            "call s:HL('DiffChange', s:bg0, s:blue)
                            "call s:HL('DiffText',   s:bg0, s:yellow)
                            
                            " Alternative setting
    2   0.000112   0.000015 call s:HL('DiffChange', s:aqua, s:bg0, s:inverse)
    2   0.000111   0.000014 call s:HL('DiffText',   s:yellow, s:bg0, s:inverse)
                            
                            " }}}
                            " Spelling: {{{
                            
    2              0.000011 if has("spell")
                              " Not capitalised word, or compile warnings
    2              0.000003   if g:gruvbox_improved_warnings == 0
    2   0.000122   0.000016     call s:HL('SpellCap',   s:none, s:none, s:undercurl, s:red)
    2              0.000003   else
                                call s:HL('SpellCap',   s:green, s:none, s:bold . s:italic)
                              endif
                              " Not recognized word
    2   0.000125   0.000016   call s:HL('SpellBad',   s:none, s:none, s:undercurl, s:blue)
                              " Wrong spelling for selected region
    2   0.000116   0.000014   call s:HL('SpellLocal', s:none, s:none, s:undercurl, s:aqua)
                              " Rare word
    2   0.000117   0.000016   call s:HL('SpellRare',  s:none, s:none, s:undercurl, s:purple)
    2              0.000002 endif
                            
                            " }}}
                            
                            " Plugin specific -------------------------------------------------------------
                            " EasyMotion: {{{
                            
    2              0.000008 hi! link EasyMotionTarget Search
    2              0.000007 hi! link EasyMotionShade Comment
                            
                            " }}}
                            " Sneak: {{{
                            
    2              0.000007 hi! link SneakPluginTarget Search
    2              0.000007 hi! link SneakStreakTarget Search
    2   0.000113   0.000014 call s:HL('SneakStreakMask', s:yellow, s:yellow)
    2              0.000010 hi! link SneakStreakStatusLine Search
                            
                            " }}}
                            " Indent Guides: {{{
                            
    2              0.000008 if !exists('g:indent_guides_auto_colors')
    1              0.000002   let g:indent_guides_auto_colors = 0
    1              0.000000 endif
                            
    2              0.000004 if g:indent_guides_auto_colors == 0
    2              0.000003   if g:gruvbox_invert_indent_guides == 0
    2   0.000119   0.000015     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2)
    2   0.000144   0.000019     call s:HL('IndentGuidesEven', s:vim_bg, s:bg1)
    2              0.000004   else
                                call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2, s:inverse)
                                call s:HL('IndentGuidesEven', s:vim_bg, s:bg3, s:inverse)
                              endif
    2              0.000003 endif
                            
                            " }}}
                            " IndentLine: {{{
                            
    2              0.000009 if !exists('g:indentLine_color_term')
    1              0.000003   let g:indentLine_color_term = s:bg2[1]
    1              0.000001 endif
    2              0.000008 if !exists('g:indentLine_color_gui')
    1              0.000003   let g:indentLine_color_gui = s:bg2[0]
    1              0.000001 endif
                            
                            " }}}
                            " Rainbow Parentheses: {{{
                            
    2              0.000006 if !exists('g:rbpt_colorpairs')
    1              0.000006   let g:rbpt_colorpairs =
                                \ [
                                  \ ['blue', '#458588'], ['magenta', '#b16286'],
                                  \ ['red',  '#cc241d'], ['166',     '#d65d0e']
                                \ ]
    1              0.000001 endif
                            
    2              0.000008 let g:rainbow_guifgs = [ '#d65d0e', '#cc241d', '#b16286', '#458588' ]
    2              0.000008 let g:rainbow_ctermfgs = [ '166', 'red', 'magenta', 'blue' ]
                            
    2              0.000007 if !exists('g:rainbow_conf')
    1              0.000002    let g:rainbow_conf = {}
    1              0.000001 endif
    2              0.000008 if !has_key(g:rainbow_conf, 'guifgs')
    1              0.000003    let g:rainbow_conf['guifgs'] = g:rainbow_guifgs
    1              0.000001 endif
    2              0.000006 if !has_key(g:rainbow_conf, 'ctermfgs')
    1              0.000002    let g:rainbow_conf['ctermfgs'] = g:rainbow_ctermfgs
    1              0.000001 endif
                            
    2              0.000005 let g:niji_dark_colours = g:rbpt_colorpairs
    2              0.000004 let g:niji_light_colours = g:rbpt_colorpairs
                            
                            "}}}
                            " GitGutter: {{{
                            
    2              0.000023 hi! link GitGutterAdd GruvboxGreenSign
    2              0.000011 hi! link GitGutterChange GruvboxAquaSign
    2              0.000008 hi! link GitGutterDelete GruvboxRedSign
    2              0.000010 hi! link GitGutterChangeDelete GruvboxAquaSign
                            
                            " }}}
                            " GitCommit: "{{{
                            
    2              0.000010 hi! link gitcommitSelectedFile GruvboxGreen
    2              0.000009 hi! link gitcommitDiscardedFile GruvboxRed
                            
                            " }}}
                            " Signify: {{{
                            
    2              0.000009 hi! link SignifySignAdd GruvboxGreenSign
    2              0.000009 hi! link SignifySignChange GruvboxAquaSign
    2              0.000009 hi! link SignifySignDelete GruvboxRedSign
                            
                            " }}}
                            " Syntastic: {{{
                            
    2   0.000176   0.000022 call s:HL('SyntasticError', s:none, s:none, s:undercurl, s:red)
    2   0.000178   0.000023 call s:HL('SyntasticWarning', s:none, s:none, s:undercurl, s:yellow)
                            
    2              0.000012 hi! link SyntasticErrorSign GruvboxRedSign
    2              0.000010 hi! link SyntasticWarningSign GruvboxYellowSign
                            
                            " }}}
                            " Signature: {{{
    2              0.000010 hi! link SignatureMarkText   GruvboxBlueSign
    2              0.000009 hi! link SignatureMarkerText GruvboxPurpleSign
                            
                            " }}}
                            " ShowMarks: {{{
                            
    2              0.000010 hi! link ShowMarksHLl GruvboxBlueSign
    2              0.000008 hi! link ShowMarksHLu GruvboxBlueSign
    2              0.000008 hi! link ShowMarksHLo GruvboxBlueSign
    2              0.000008 hi! link ShowMarksHLm GruvboxBlueSign
                            
                            " }}}
                            " CtrlP: {{{
                            
    2              0.000008 hi! link CtrlPMatch GruvboxYellow
    2              0.000010 hi! link CtrlPNoEntries GruvboxRed
    2              0.000008 hi! link CtrlPPrtBase GruvboxBg2
    2              0.000009 hi! link CtrlPPrtCursor GruvboxBlue
    2              0.000009 hi! link CtrlPLinePre GruvboxBg2
                            
    2   0.000157   0.000023 call s:HL('CtrlPMode1', s:blue, s:bg2, s:bold)
    2   0.000140   0.000023 call s:HL('CtrlPMode2', s:bg0, s:blue, s:bold)
    2   0.000116   0.000015 call s:HL('CtrlPStats', s:fg4, s:bg2, s:bold)
                            
                            " }}}
                            " Startify: {{{
                            
    2              0.000008 hi! link StartifyBracket GruvboxFg3
    2              0.000008 hi! link StartifyFile GruvboxFg0
    2              0.000006 hi! link StartifyNumber GruvboxBlue
    2              0.000008 hi! link StartifyPath GruvboxGray
    2              0.000009 hi! link StartifySlash GruvboxGray
    2              0.000010 hi! link StartifySection GruvboxYellow
    2              0.000008 hi! link StartifySpecial GruvboxBg2
    2              0.000010 hi! link StartifyHeader GruvboxOrange
    2              0.000008 hi! link StartifyFooter GruvboxBg2
                            
                            " }}}
                            " Vimshell: {{{
                            
    2              0.000042 let g:vimshell_escape_colors = [
                              \ s:bg4[0], s:red[0], s:green[0], s:yellow[0],
                              \ s:blue[0], s:purple[0], s:aqua[0], s:fg4[0],
                              \ s:bg0[0], s:red[0], s:green[0], s:orange[0],
                              \ s:blue[0], s:purple[0], s:aqua[0], s:fg0[0]
                              \ ]
                            
                            " }}}
                            " BufTabLine: {{{
                            
    2   0.000119   0.000015 call s:HL('BufTabLineCurrent', s:bg0, s:fg4)
    2   0.000113   0.000014 call s:HL('BufTabLineActive', s:fg4, s:bg2)
    2   0.000112   0.000014 call s:HL('BufTabLineHidden', s:bg4, s:bg1)
    2   0.000132   0.000014 call s:HL('BufTabLineFill', s:bg0, s:bg0)
                            
                            " }}}
                            
                            " Filetype specific -----------------------------------------------------------
                            " Diff: {{{
                            
    2              0.000012 hi! link diffAdded GruvboxGreen
    2              0.000006 hi! link diffRemoved GruvboxRed
    2              0.000007 hi! link diffChanged GruvboxAqua
                            
    2              0.000006 hi! link diffFile GruvboxOrange
    2              0.000007 hi! link diffNewFile GruvboxYellow
                            
    2              0.000006 hi! link diffLine GruvboxBlue
                            
                            " }}}
                            " Html: {{{
                            
    2              0.000006 hi! link htmlTag GruvboxBlue
    2              0.000006 hi! link htmlEndTag GruvboxBlue
                            
    2              0.000006 hi! link htmlTagName GruvboxAquaBold
    2              0.000005 hi! link htmlArg GruvboxAqua
                            
    2              0.000007 hi! link htmlScriptTag GruvboxPurple
    2              0.000006 hi! link htmlTagN GruvboxFg1
    2              0.000007 hi! link htmlSpecialTagName GruvboxAquaBold
                            
    2   0.000157   0.000020 call s:HL('htmlLink', s:fg4, s:none, s:underline)
                            
    2              0.000012 hi! link htmlSpecialChar GruvboxOrange
                            
    2   0.000126   0.000021 call s:HL('htmlBold', s:vim_fg, s:vim_bg, s:bold)
    2   0.000115   0.000017 call s:HL('htmlBoldUnderline', s:vim_fg, s:vim_bg, s:bold . s:underline)
    2   0.000113   0.000016 call s:HL('htmlBoldItalic', s:vim_fg, s:vim_bg, s:bold . s:italic)
    2   0.000113   0.000017 call s:HL('htmlBoldUnderlineItalic', s:vim_fg, s:vim_bg, s:bold . s:underline . s:italic)
                            
    2   0.000112   0.000015 call s:HL('htmlUnderline', s:vim_fg, s:vim_bg, s:underline)
    2   0.000124   0.000016 call s:HL('htmlUnderlineItalic', s:vim_fg, s:vim_bg, s:underline . s:italic)
    2   0.000116   0.000016 call s:HL('htmlItalic', s:vim_fg, s:vim_bg, s:italic)
                            
                            " }}}
                            " Xml: {{{
                            
    2              0.000008 hi! link xmlTag GruvboxBlue
    2              0.000006 hi! link xmlEndTag GruvboxBlue
    2              0.000007 hi! link xmlTagName GruvboxBlue
    2              0.000006 hi! link xmlEqual GruvboxBlue
    2              0.000006 hi! link docbkKeyword GruvboxAquaBold
                            
    2              0.000006 hi! link xmlDocTypeDecl GruvboxGray
    2              0.000007 hi! link xmlDocTypeKeyword GruvboxPurple
    2              0.000007 hi! link xmlCdataStart GruvboxGray
    2              0.000006 hi! link xmlCdataCdata GruvboxPurple
    2              0.000007 hi! link dtdFunction GruvboxGray
    2              0.000007 hi! link dtdTagName GruvboxPurple
                            
    2              0.000007 hi! link xmlAttrib GruvboxAqua
    2              0.000007 hi! link xmlProcessingDelim GruvboxGray
    2              0.000007 hi! link dtdParamEntityPunct GruvboxGray
    2              0.000007 hi! link dtdParamEntityDPunct GruvboxGray
    2              0.000006 hi! link xmlAttribPunct GruvboxGray
                            
    2              0.000006 hi! link xmlEntity GruvboxOrange
    2              0.000007 hi! link xmlEntityPunct GruvboxOrange
                            " }}}
                            " Vim: {{{
                            
    2   0.000136   0.000018 call s:HL('vimCommentTitle', s:fg4_256, s:none, s:bold . s:italicize_comments)
                            
    2              0.000012 hi! link vimNotation GruvboxOrange
    2              0.000008 hi! link vimBracket GruvboxOrange
    2              0.000007 hi! link vimMapModKey GruvboxOrange
    2              0.000007 hi! link vimFuncSID GruvboxFg3
    2              0.000007 hi! link vimSetSep GruvboxFg3
    2              0.000006 hi! link vimSep GruvboxFg3
    2              0.000006 hi! link vimContinue GruvboxFg3
                            
                            " }}}
                            " Clojure: {{{
                            
    2              0.000007 hi! link clojureKeyword GruvboxBlue
    2              0.000006 hi! link clojureCond GruvboxOrange
    2              0.000007 hi! link clojureSpecial GruvboxOrange
    2              0.000006 hi! link clojureDefine GruvboxOrange
                            
    2              0.000007 hi! link clojureFunc GruvboxYellow
    2              0.000008 hi! link clojureRepeat GruvboxYellow
    2              0.000007 hi! link clojureCharacter GruvboxAqua
    2              0.000007 hi! link clojureStringEscape GruvboxAqua
    2              0.000006 hi! link clojureException GruvboxRed
                            
    2              0.000006 hi! link clojureRegexp GruvboxAqua
    2              0.000007 hi! link clojureRegexpEscape GruvboxAqua
    2   0.000144   0.000021 call s:HL('clojureRegexpCharClass', s:fg3, s:none, s:bold)
    2              0.000014 hi! link clojureRegexpMod clojureRegexpCharClass
    2              0.000010 hi! link clojureRegexpQuantifier clojureRegexpCharClass
                            
    2              0.000011 hi! link clojureParen GruvboxFg3
    2              0.000011 hi! link clojureAnonArg GruvboxYellow
    2              0.000009 hi! link clojureVariable GruvboxBlue
    2              0.000009 hi! link clojureMacro GruvboxOrange
                            
    2              0.000009 hi! link clojureMeta GruvboxYellow
    2              0.000009 hi! link clojureDeref GruvboxYellow
    2              0.000010 hi! link clojureQuote GruvboxYellow
    2              0.000010 hi! link clojureUnquote GruvboxYellow
                            
                            " }}}
                            " C: {{{
                            
    2              0.000010 hi! link cOperator GruvboxPurple
    2              0.000009 hi! link cStructure GruvboxOrange
                            
                            " }}}
                            " Python: {{{
                            
    2              0.000010 hi! link pythonBuiltin GruvboxOrange
    2              0.000009 hi! link pythonBuiltinObj GruvboxOrange
    2              0.000010 hi! link pythonBuiltinFunc GruvboxOrange
    2              0.000009 hi! link pythonFunction GruvboxAqua
    2              0.000010 hi! link pythonDecorator GruvboxRed
    2              0.000010 hi! link pythonInclude GruvboxBlue
    2              0.000008 hi! link pythonImport GruvboxBlue
    2              0.000008 hi! link pythonRun GruvboxBlue
    2              0.000010 hi! link pythonCoding GruvboxBlue
    2              0.000009 hi! link pythonOperator GruvboxRed
    2              0.000009 hi! link pythonExceptions GruvboxPurple
    2              0.000009 hi! link pythonBoolean GruvboxPurple
    2              0.000009 hi! link pythonDot GruvboxFg3
                            
                            " }}}
                            " CSS: {{{
                            
    2              0.000009 hi! link cssBraces GruvboxBlue
    2              0.000009 hi! link cssFunctionName GruvboxYellow
    2              0.000011 hi! link cssIdentifier GruvboxOrange
    2              0.000009 hi! link cssClassName GruvboxGreen
    2              0.000009 hi! link cssColor GruvboxBlue
    2              0.000009 hi! link cssSelectorOp GruvboxBlue
    2              0.000010 hi! link cssSelectorOp2 GruvboxBlue
    2              0.000009 hi! link cssImportant GruvboxGreen
    2              0.000011 hi! link cssVendor GruvboxFg1
                            
    2              0.000007 hi! link cssTextProp GruvboxAqua
    2              0.000006 hi! link cssAnimationProp GruvboxAqua
    2              0.000007 hi! link cssUIProp GruvboxYellow
    2              0.000007 hi! link cssTransformProp GruvboxAqua
    2              0.000011 hi! link cssTransitionProp GruvboxAqua
    2              0.000010 hi! link cssPrintProp GruvboxAqua
    2              0.000008 hi! link cssPositioningProp GruvboxYellow
    2              0.000007 hi! link cssBoxProp GruvboxAqua
    2              0.000007 hi! link cssFontDescriptorProp GruvboxAqua
    2              0.000007 hi! link cssFlexibleBoxProp GruvboxAqua
    2              0.000006 hi! link cssBorderOutlineProp GruvboxAqua
    2              0.000008 hi! link cssBackgroundProp GruvboxAqua
    2              0.000006 hi! link cssMarginProp GruvboxAqua
    2              0.000006 hi! link cssListProp GruvboxAqua
    2              0.000008 hi! link cssTableProp GruvboxAqua
    2              0.000006 hi! link cssFontProp GruvboxAqua
    2              0.000007 hi! link cssPaddingProp GruvboxAqua
    2              0.000007 hi! link cssDimensionProp GruvboxAqua
    2              0.000006 hi! link cssRenderProp GruvboxAqua
    2              0.000006 hi! link cssColorProp GruvboxAqua
    2              0.000006 hi! link cssGeneratedContentProp GruvboxAqua
                            
                            " }}}
                            " JavaScript: {{{
                            
    2              0.000007 hi! link javaScriptBraces GruvboxFg1
    2              0.000007 hi! link javaScriptFunction GruvboxAqua
    2              0.000007 hi! link javaScriptIdentifier GruvboxRed
    2              0.000007 hi! link javaScriptMember GruvboxBlue
    2              0.000007 hi! link javaScriptNumber GruvboxPurple
    2              0.000007 hi! link javaScriptNull GruvboxPurple
    2              0.000007 hi! link javaScriptParens GruvboxFg3
                            
                            " }}}
                            " YAJS: {{{
                            
    2              0.000007 hi! link javascriptImport GruvboxAqua
    2              0.000007 hi! link javascriptExport GruvboxAqua
    2              0.000006 hi! link javascriptClassKeyword GruvboxAqua
    2              0.000007 hi! link javascriptClassExtends GruvboxAqua
    2              0.000007 hi! link javascriptDefault GruvboxAqua
                            
    2              0.000007 hi! link javascriptClassName GruvboxYellow
    2              0.000009 hi! link javascriptClassSuperName GruvboxYellow
    2              0.000007 hi! link javascriptGlobal GruvboxYellow
                            
    2              0.000009 hi! link javascriptEndColons GruvboxFg1
    2              0.000011 hi! link javascriptFuncArg GruvboxFg1
    2              0.000010 hi! link javascriptGlobalMethod GruvboxFg1
    2              0.000008 hi! link javascriptNodeGlobal GruvboxFg1
                            
                            " hi! link javascriptVariable GruvboxOrange
    2              0.000009 hi! link javascriptVariable GruvboxRed
                            " hi! link javascriptIdentifier GruvboxOrange
                            " hi! link javascriptClassSuper GruvboxOrange
    2              0.000008 hi! link javascriptIdentifier GruvboxOrange
    2              0.000009 hi! link javascriptClassSuper GruvboxOrange
                            
                            " hi! link javascriptFuncKeyword GruvboxOrange
                            " hi! link javascriptAsyncFunc GruvboxOrange
    2              0.000010 hi! link javascriptFuncKeyword GruvboxAqua
    2              0.000010 hi! link javascriptAsyncFunc GruvboxAqua
    2              0.000010 hi! link javascriptClassStatic GruvboxOrange
                            
    2              0.000008 hi! link javascriptOperator GruvboxRed
    2              0.000009 hi! link javascriptForOperator GruvboxRed
    2              0.000009 hi! link javascriptYield GruvboxRed
    2              0.000009 hi! link javascriptExceptions GruvboxRed
    2              0.000010 hi! link javascriptMessage GruvboxRed
                            
    2              0.000010 hi! link javascriptTemplateSB GruvboxAqua
    2              0.000009 hi! link javascriptTemplateSubstitution GruvboxFg1
                            
                            " hi! link javascriptLabel GruvboxBlue
                            " hi! link javascriptObjectLabel GruvboxBlue
                            " hi! link javascriptPropertyName GruvboxBlue
    2              0.000009 hi! link javascriptLabel GruvboxFg1
    2              0.000008 hi! link javascriptObjectLabel GruvboxFg1
    2              0.000010 hi! link javascriptPropertyName GruvboxFg1
                            
    2              0.000010 hi! link javascriptLogicSymbols GruvboxFg1
    2              0.000010 hi! link javascriptArrowFunc GruvboxFg1
                            
    2              0.000009 hi! link javascriptDocParamName GruvboxFg4
    2              0.000010 hi! link javascriptDocTags GruvboxFg4
    2              0.000010 hi! link javascriptDocNotation GruvboxFg4
    2              0.000010 hi! link javascriptDocParamType GruvboxFg4
    2              0.000009 hi! link javascriptDocNamedParamType GruvboxFg4
                            
                            " }}}
                            " TypeScript: {{{
                            
    2              0.000009 hi! link typeScriptReserved GruvboxAqua
    2              0.000009 hi! link typeScriptLabel GruvboxAqua
    2              0.000010 hi! link typeScriptIdentifier GruvboxOrange
    2              0.000010 hi! link typeScriptBraces GruvboxFg1
    2              0.000017 hi! link typeScriptEndColons GruvboxFg1
    2              0.000018 hi! link typeScriptDOMObjects GruvboxFg1
    2              0.000021 hi! link typeScriptAjaxMethods GruvboxFg1
    2              0.000013 hi! link typeScriptLogicSymbols GruvboxFg1
    2              0.000014 hi! link typeScriptDocSeeTag Comment
    2              0.000013 hi! link typeScriptDocParam Comment
    2              0.000009 hi! link typeScriptDocTags vimCommentTitle
                            
                            " }}}
                            " CoffeeScript: {{{
                            
    2              0.000010 hi! link coffeeExtendedOp GruvboxFg3
    2              0.000014 hi! link coffeeSpecialOp GruvboxFg3
    2              0.000012 hi! link coffeeCurly GruvboxOrange
    2              0.000012 hi! link coffeeParen GruvboxFg3
    2              0.000011 hi! link coffeeBracket GruvboxOrange
                            
                            " }}}
                            " Ruby: {{{
                            
    2              0.000012 hi! link rubyStringDelimiter GruvboxGreen
    2              0.000012 hi! link rubyInterpolationDelimiter GruvboxAqua
                            
                            " }}}
                            " ObjectiveC: {{{
                            
    2              0.000012 hi! link objcTypeModifier GruvboxRed
    2              0.000009 hi! link objcDirective GruvboxBlue
                            
                            " }}}
                            " Go: {{{
                            
    2              0.000010 hi! link goDirective GruvboxAqua
    2              0.000010 hi! link goConstants GruvboxPurple
    2              0.000009 hi! link goDeclaration GruvboxRed
    2              0.000011 hi! link goDeclType GruvboxBlue
    2              0.000009 hi! link goBuiltins GruvboxOrange
                            
                            " }}}
                            " Lua: {{{
                            
    2              0.000009 hi! link luaIn GruvboxRed
    2              0.000010 hi! link luaFunction GruvboxAqua
    2              0.000010 hi! link luaTable GruvboxOrange
                            
                            " }}}
                            " MoonScript: {{{
                            
    2              0.000013 hi! link moonSpecialOp GruvboxFg3
    2              0.000011 hi! link moonExtendedOp GruvboxFg3
    2              0.000009 hi! link moonFunction GruvboxFg3
    2              0.000008 hi! link moonObject GruvboxYellow
                            
                            " }}}
                            " Java: {{{
                            
    2              0.000007 hi! link javaAnnotation GruvboxBlue
    2              0.000008 hi! link javaDocTags GruvboxAqua
    2              0.000006 hi! link javaCommentTitle vimCommentTitle
    2              0.000007 hi! link javaParen GruvboxFg3
    2              0.000007 hi! link javaParen1 GruvboxFg3
    2              0.000007 hi! link javaParen2 GruvboxFg3
    2              0.000007 hi! link javaParen3 GruvboxFg3
    2              0.000007 hi! link javaParen4 GruvboxFg3
    2              0.000007 hi! link javaParen5 GruvboxFg3
    2              0.000007 hi! link javaOperator GruvboxOrange
                            
    2              0.000007 hi! link javaVarArg GruvboxGreen
                            
                            " }}}
                            " Elixir: {{{
                            
    2              0.000008 hi! link elixirDocString Comment
                            
    2              0.000008 hi! link elixirStringDelimiter GruvboxGreen
    2              0.000008 hi! link elixirInterpolationDelimiter GruvboxAqua
                            
    2              0.000007 hi! link elixirModuleDeclaration GruvboxYellow
                            
                            " }}}
                            " Scala: {{{
                            
                            " NB: scala vim syntax file is kinda horrible
    2              0.000007 hi! link scalaNameDefinition GruvboxFg1
    2              0.000007 hi! link scalaCaseFollowing GruvboxFg1
    2              0.000008 hi! link scalaCapitalWord GruvboxFg1
    2              0.000007 hi! link scalaTypeExtension GruvboxFg1
                            
    2              0.000007 hi! link scalaKeyword GruvboxRed
    2              0.000007 hi! link scalaKeywordModifier GruvboxRed
                            
    2              0.000007 hi! link scalaSpecial GruvboxAqua
    2              0.000008 hi! link scalaOperator GruvboxFg1
                            
    2              0.000008 hi! link scalaTypeDeclaration GruvboxYellow
    2              0.000007 hi! link scalaTypeTypePostDeclaration GruvboxYellow
                            
    2              0.000008 hi! link scalaInstanceDeclaration GruvboxFg1
    2              0.000008 hi! link scalaInterpolation GruvboxAqua
                            
                            " }}}
                            " Markdown: {{{
                            
    2   0.000151   0.000025 call s:HL('markdownItalic', s:fg3, s:none, s:italic)
                            
    2              0.000013 hi! link markdownH1 GruvboxGreenBold
    2              0.000007 hi! link markdownH2 GruvboxGreenBold
    2              0.000008 hi! link markdownH3 GruvboxYellowBold
    2              0.000008 hi! link markdownH4 GruvboxYellowBold
    2              0.000007 hi! link markdownH5 GruvboxYellow
    2              0.000008 hi! link markdownH6 GruvboxYellow
                            
    2              0.000008 hi! link markdownCode GruvboxAqua
    2              0.000007 hi! link markdownCodeBlock GruvboxAqua
    2              0.000008 hi! link markdownCodeDelimiter GruvboxAqua
                            
    2              0.000008 hi! link markdownBlockquote GruvboxGray
    2              0.000007 hi! link markdownListMarker GruvboxGray
    2              0.000007 hi! link markdownOrderedListMarker GruvboxGray
    2              0.000008 hi! link markdownRule GruvboxGray
    2              0.000008 hi! link markdownHeadingRule GruvboxGray
                            
    2              0.000008 hi! link markdownUrlDelimiter GruvboxFg3
    2              0.000008 hi! link markdownLinkDelimiter GruvboxFg3
    2              0.000007 hi! link markdownLinkTextDelimiter GruvboxFg3
                            
    2              0.000008 hi! link markdownHeadingDelimiter GruvboxOrange
    2              0.000007 hi! link markdownUrl GruvboxPurple
    2              0.000008 hi! link markdownUrlTitleDelimiter GruvboxGreen
                            
    2   0.000145   0.000020 call s:HL('markdownLinkText', s:gray, s:none, s:underline)
    2              0.000007 hi! link markdownIdDeclaration markdownLinkText
                            
                            " }}}
                            " Haskell: {{{
                            
                            " hi! link haskellType GruvboxYellow
                            " hi! link haskellOperators GruvboxOrange
                            " hi! link haskellConditional GruvboxAqua
                            " hi! link haskellLet GruvboxOrange
                            "
    2              0.000009 hi! link haskellType GruvboxFg1
    2              0.000008 hi! link haskellIdentifier GruvboxFg1
    2              0.000043 hi! link haskellSeparator GruvboxFg1
    2              0.000009 hi! link haskellDelimiter GruvboxFg4
    2              0.000008 hi! link haskellOperators GruvboxBlue
                            "
    2              0.000009 hi! link haskellBacktick GruvboxOrange
    2              0.000007 hi! link haskellStatement GruvboxOrange
    2              0.000008 hi! link haskellConditional GruvboxOrange
                            
    2              0.000008 hi! link haskellLet GruvboxAqua
    2              0.000008 hi! link haskellDefault GruvboxAqua
    2              0.000006 hi! link haskellWhere GruvboxAqua
    2              0.000006 hi! link haskellBottom GruvboxAqua
    2              0.000011 hi! link haskellBlockKeywords GruvboxAqua
    2              0.000008 hi! link haskellImportKeywords GruvboxAqua
    2              0.000008 hi! link haskellDeclKeyword GruvboxAqua
    2              0.000008 hi! link haskellDeriving GruvboxAqua
    2              0.000008 hi! link haskellAssocType GruvboxAqua
                            
    2              0.000008 hi! link haskellNumber GruvboxPurple
    2              0.000008 hi! link haskellPragma GruvboxPurple
                            
    2              0.000008 hi! link haskellString GruvboxGreen
    2              0.000008 hi! link haskellChar GruvboxGreen
                            
                            " }}}
                            " Json: {{{
                            
    2              0.000008 hi! link jsonKeyword GruvboxGreen
    2              0.000007 hi! link jsonQuote GruvboxGreen
    2              0.000008 hi! link jsonBraces GruvboxFg1
    2              0.000008 hi! link jsonString GruvboxFg1
                            
                            " }}}
                            
                            
                            " Functions -------------------------------------------------------------------
                            " Search Highlighting Cursor {{{
                            
    2              0.000006 function! GruvboxHlsShowCursor()
                              call s:HL('Cursor', s:bg0, s:hls_cursor)
                            endfunction
                            
    2              0.000003 function! GruvboxHlsHideCursor()
                              call s:HL('Cursor', s:none, s:none, s:inverse)
                            endfunction
                            
                            " }}}
                            
                            " vim: set sw=2 ts=2 sts=2 et tw=80 ft=vim fdm=marker:

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/syntax/nosyntax.vim
Sourced 1 time
Total time:   0.000420
 Self time:   0.000420

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2006 Apr 16
                            
                            " This file is used for ":syntax off".
                            " It removes the autocommands and stops highlighting for all buffers.
                            
    1              0.000027 if !has("syntax")
                              finish
                            endif
                            
                            " Remove all autocommands for the Syntax event.  This also avoids that
                            " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.
    1              0.000186 au! Syntax
                            
                            " remove all syntax autocommands and remove the syntax for each buffer
    1              0.000002 augroup syntaxset
    1              0.000067   au!
    1              0.000013   au BufEnter * syn clear
    1              0.000004   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif
    1              0.000003   doautoall syntaxset BufEnter *
    1              0.000077   au!
    1              0.000001 augroup END
                            
    1              0.000006 if exists("syntax_on")
    1              0.000006   unlet syntax_on
    1              0.000001 endif
    1              0.000002 if exists("syntax_manual")
                              unlet syntax_manual
                            endif

SCRIPT  /home/user/fbarotjr/.vim/plugged/auto-pairs/plugin/auto-pairs.vim
Sourced 1 time
Total time:   0.000646
 Self time:   0.000646

count  total (s)   self (s)
                            " Insert or delete brackets, parens, quotes in pairs.
                            " Maintainer:	JiangMiao <jiangfriend@gmail.com>
                            " Contributor: camthompson
                            " Last Change:  2017-06-17
                            " Version: 1.3.3
                            " Homepage: http://www.vim.org/scripts/script.php?script_id=3599
                            " Repository: https://github.com/jiangmiao/auto-pairs
                            " License: MIT
                            
    1              0.000033 if exists('g:AutoPairsLoaded') || &cp
                              finish
                            end
    1              0.000006 let g:AutoPairsLoaded = 1
                            
    1              0.000004 if !exists('g:AutoPairs')
    1              0.000006   let g:AutoPairs = {'(':')', '[':']', '{':'}',"'":"'",'"':'"', '`':'`'}
    1              0.000001 end
                            
    1              0.000003 if !exists('g:AutoPairsParens')
    1              0.000004   let g:AutoPairsParens = {'(':')', '[':']', '{':'}'}
    1              0.000000 end
                            
    1              0.000002 if !exists('g:AutoPairsMapBS')
    1              0.000002   let g:AutoPairsMapBS = 1
    1              0.000001 end
                            
                            " Map <C-h> as the same BS
    1              0.000002 if !exists('g:AutoPairsMapCh')
    1              0.000002   let g:AutoPairsMapCh = 1
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsMapCR')
    1              0.000003   let g:AutoPairsMapCR = 1
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsMapSpace')
    1              0.000003   let g:AutoPairsMapSpace = 1
    1              0.000000 end
                            
    1              0.000003 if !exists('g:AutoPairsCenterLine')
                              let g:AutoPairsCenterLine = 1
                            end
                            
    1              0.000003 if !exists('g:AutoPairsShortcutToggle')
    1              0.000003   let g:AutoPairsShortcutToggle = '<M-p>'
    1              0.000000 end
                            
    1              0.000003 if !exists('g:AutoPairsShortcutFastWrap')
    1              0.000003   let g:AutoPairsShortcutFastWrap = '<M-e>'
    1              0.000001 end
                            
    1              0.000003 if !exists('g:AutoPairsMoveCharacter')
    1              0.000003   let g:AutoPairsMoveCharacter = "()[]{}\"'"
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsShortcutJump')
    1              0.000003   let g:AutoPairsShortcutJump = '<M-n>'
    1              0.000001 endif
                            
                            " Fly mode will for closed pair to jump to closed pair instead of insert.
                            " also support AutoPairsBackInsert to insert pairs where jumped.
    1              0.000002 if !exists('g:AutoPairsFlyMode')
    1              0.000003   let g:AutoPairsFlyMode = 0
    1              0.000001 endif
                            
                            " When skipping the closed pair, look at the current and
                            " next line as well.
    1              0.000003 if !exists('g:AutoPairsMultilineClose')
    1              0.000003   let g:AutoPairsMultilineClose = 1
    1              0.000001 endif
                            
                            " Work with Fly Mode, insert pair where jumped
    1              0.000003 if !exists('g:AutoPairsShortcutBackInsert')
    1              0.000003   let g:AutoPairsShortcutBackInsert = '<M-b>'
    1              0.000001 endif
                            
    1              0.000003 if !exists('g:AutoPairsSmartQuotes')
    1              0.000002   let g:AutoPairsSmartQuotes = 1
    1              0.000001 endif
                            
                            " 7.4.849 support <C-G>U to avoid breaking '.'
                            " Issue talk: https://github.com/jiangmiao/auto-pairs/issues/3
                            " Vim note: https://github.com/vim/vim/releases/tag/v7.4.849
    1              0.000004 if v:version > 704 || v:version == 704 && has("patch849")
    1              0.000004   let s:Go = "\<C-G>U"
    1              0.000001 else
                              let s:Go = ""
                            endif
                            
    1              0.000004 let s:Left = s:Go."\<LEFT>"
    1              0.000003 let s:Right = s:Go."\<RIGHT>"
                            
                            
                            " Will auto generated {']' => '[', ..., '}' => '{'}in initialize.
    1              0.000002 let g:AutoPairsClosedPairs = {}
                            
                            
    1              0.000004 function! AutoPairsInsert(key)
                              if !b:autopairs_enabled
                                return a:key
                              end
                            
                              let line = getline('.')
                              let pos = col('.') - 1
                              let before = strpart(line, 0, pos)
                              let after = strpart(line, pos)
                              let next_chars = split(after, '\zs')
                              let current_char = get(next_chars, 0, '')
                              let next_char = get(next_chars, 1, '')
                              let prev_chars = split(before, '\zs')
                              let prev_char = get(prev_chars, -1, '')
                            
                              let eol = 0
                              if col('$') -  col('.') <= 1
                                let eol = 1
                              end
                            
                              " Ignore auto close if prev character is \
                              if prev_char == '\'
                                return a:key
                              end
                            
                              " The key is difference open-pair, then it means only for ) ] } by default
                              if !has_key(b:AutoPairs, a:key)
                                let b:autopairs_saved_pair = [a:key, getpos('.')]
                            
                                " Skip the character if current character is the same as input
                                if current_char == a:key
                                  return s:Right
                                end
                            
                                if !g:AutoPairsFlyMode
                                  " Skip the character if next character is space
                                  if current_char == ' ' && next_char == a:key
                                    return s:Right.s:Right
                                  end
                            
                                  " Skip the character if closed pair is next character
                                  if current_char == ''
                                    if g:AutoPairsMultilineClose
                                      let next_lineno = line('.')+1
                                      let next_line = getline(nextnonblank(next_lineno))
                                      let next_char = matchstr(next_line, '\s*\zs.')
                                    else
                                      let next_char = matchstr(line, '\s*\zs.')
                                    end
                                    if next_char == a:key
                                      return "\<ESC>e^a"
                                    endif
                                  endif
                                endif
                            
                                " Fly Mode, and the key is closed-pairs, search closed-pair and jump
                                if g:AutoPairsFlyMode && has_key(b:AutoPairsClosedPairs, a:key)
                                  let n = stridx(after, a:key)
                                  if n != -1
                                    return repeat(s:Right, n+1)
                                  end
                                  if search(a:key, 'W')
                                    " force break the '.' when jump to different line
                                    return "\<Right>"
                                  endif
                                endif
                            
                                " Insert directly if the key is not an open key
                                return a:key
                              end
                            
                              let open = a:key
                              let close = b:AutoPairs[open]
                            
                              if current_char == close && open == close
                                return s:Right
                              end
                            
                              " Ignore auto close ' if follows a word
                              " MUST after closed check. 'hello|'
                              if a:key == "'" && prev_char =~ '\v\w'
                                return a:key
                              end
                            
                              " support for ''' ``` and """
                              if open == close
                                " The key must be ' " `
                                let pprev_char = line[col('.')-3]
                                if pprev_char == open && prev_char == open
                                  " Double pair found
                                  return repeat(a:key, 4) . repeat(s:Left, 3)
                                end
                              end
                            
                              let quotes_num = 0
                              " Ignore comment line for vim file
                              if &filetype == 'vim' && a:key == '"'
                                if before =~ '^\s*$'
                                  return a:key
                                end
                                if before =~ '^\s*"'
                                  let quotes_num = -1
                                end
                              end
                            
                              " Keep quote number is odd.
                              " Because quotes should be matched in the same line in most of situation
                              if g:AutoPairsSmartQuotes && open == close
                                " Remove \\ \" \'
                                let cleaned_line = substitute(line, '\v(\\.)', '', 'g')
                                let n = quotes_num
                                let pos = 0
                                while 1
                                  let pos = stridx(cleaned_line, open, pos)
                                  if pos == -1
                                    break
                                  end
                                  let n = n + 1
                                  let pos = pos + 1
                                endwhile
                                if n % 2 == 1
                                  return a:key
                                endif
                              endif
                            
                              return open.close.s:Left
                            endfunction
                            
    1              0.000003 function! AutoPairsDelete()
                              if !b:autopairs_enabled
                                return "\<BS>"
                              end
                            
                              let line = getline('.')
                              let pos = col('.') - 1
                              let current_char = get(split(strpart(line, pos), '\zs'), 0, '')
                              let prev_chars = split(strpart(line, 0, pos), '\zs')
                              let prev_char = get(prev_chars, -1, '')
                              let pprev_char = get(prev_chars, -2, '')
                            
                              if pprev_char == '\'
                                return "\<BS>"
                              end
                            
                              " Delete last two spaces in parens, work with MapSpace
                              if has_key(b:AutoPairs, pprev_char) && prev_char == ' ' && current_char == ' '
                                return "\<BS>\<DEL>"
                              endif
                            
                              " Delete Repeated Pair eg: '''|''' [[|]] {{|}}
                              if has_key(b:AutoPairs, prev_char)
                                let times = 0
                                let p = -1
                                while get(prev_chars, p, '') == prev_char
                                  let p = p - 1
                                  let times = times + 1
                                endwhile
                            
                                let close = b:AutoPairs[prev_char]
                                let left = repeat(prev_char, times)
                                let right = repeat(close, times)
                            
                                let before = strpart(line, pos-times, times)
                                let after  = strpart(line, pos, times)
                                if left == before && right == after
                                  return repeat("\<BS>\<DEL>", times)
                                end
                              end
                            
                            
                              if has_key(b:AutoPairs, prev_char)
                                let close = b:AutoPairs[prev_char]
                                if match(line,'^\s*'.close, col('.')-1) != -1
                                  " Delete (|___)
                                  let space = matchstr(line, '^\s*', col('.')-1)
                                  return "\<BS>". repeat("\<DEL>", len(space)+1)
                                elseif match(line, '^\s*$', col('.')-1) != -1
                                  " Delete (|__\n___)
                                  let nline = getline(line('.')+1)
                                  if nline =~ '^\s*'.close
                                    if &filetype == 'vim' && prev_char == '"'
                                      " Keep next line's comment
                                      return "\<BS>"
                                    end
                            
                                    let space = matchstr(nline, '^\s*')
                                    return "\<BS>\<DEL>". repeat("\<DEL>", len(space)+1)
                                  end
                                end
                              end
                            
                              return "\<BS>"
                            endfunction
                            
    1              0.000002 function! AutoPairsJump()
                              call search('["\]'')}]','W')
                            endfunction
                            " string_chunk cannot use standalone
    1              0.000004 let s:string_chunk = '\v%(\\\_.|[^\1]|[\r\n]){-}'
    1              0.000006 let s:ss_pattern = '\v''' . s:string_chunk . ''''
    1              0.000003 let s:ds_pattern = '\v"'  . s:string_chunk . '"'
                            
    1              0.000004 func! s:RegexpQuote(str)
                              return substitute(a:str, '\v[\[\{\(\<\>\)\}\]]', '\\&', 'g')
                            endf
                            
    1              0.000004 func! s:RegexpQuoteInSquare(str)
                              return substitute(a:str, '\v[\[\]]', '\\&', 'g')
                            endf
                            
                            " Search next open or close pair
    1              0.000003 func! s:FormatChunk(open, close)
                              let open = s:RegexpQuote(a:open)
                              let close = s:RegexpQuote(a:close)
                              let open2 = s:RegexpQuoteInSquare(a:open)
                              let close2 = s:RegexpQuoteInSquare(a:close)
                              if open == close
                                return '\v'.open.s:string_chunk.close
                              else
                                return '\v%(' . s:ss_pattern . '|' . s:ds_pattern . '|' . '[^'.open2.close2.']|[\r\n]' . '){-}(['.open2.close2.'])'
                              end
                            endf
                            
                            " Fast wrap the word in brackets
    1              0.000002 function! AutoPairsFastWrap()
                              let line = getline('.')
                              let current_char = line[col('.')-1]
                              let next_char = line[col('.')]
                              let open_pair_pattern = '\v[({\[''"]'
                              let at_end = col('.') >= col('$') - 1
                              normal! x
                              " Skip blank
                              if next_char =~ '\v\s' || at_end
                                call search('\v\S', 'W')
                                let line = getline('.')
                                let next_char = line[col('.')-1]
                              end
                            
                              if has_key(b:AutoPairs, next_char)
                                let followed_open_pair = next_char
                                let inputed_close_pair = current_char
                                let followed_close_pair = b:AutoPairs[next_char]
                                if followed_close_pair != followed_open_pair
                                  " TODO replace system searchpair to skip string and nested pair.
                                  " eg: (|){"hello}world"} will transform to ({"hello})world"}
                                  call searchpair('\V'.followed_open_pair, '', '\V'.followed_close_pair, 'W')
                                else
                                  call search(s:FormatChunk(followed_open_pair, followed_close_pair), 'We')
                                end
                                return s:Right.inputed_close_pair.s:Left
                              else
                                normal! he
                                return s:Right.current_char.s:Left
                              end
                            endfunction
                            
    1              0.000001 function! AutoPairsMap(key)
                              " | is special key which separate map command from text
                              let key = a:key
                              if key == '|'
                                let key = '<BAR>'
                              end
                              let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
                              execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
                            
                            endfunction
                            
    1              0.000001 function! AutoPairsToggle()
                              if b:autopairs_enabled
                                let b:autopairs_enabled = 0
                                echo 'AutoPairs Disabled.'
                              else
                                let b:autopairs_enabled = 1
                                echo 'AutoPairs Enabled.'
                              end
                              return ''
                            endfunction
                            
    1              0.000002 function! AutoPairsMoveCharacter(key)
                              let c = getline(".")[col(".")-1]
                              let escaped_key = substitute(a:key, "'", "''", 'g')
                              return "\<DEL>\<ESC>:call search("."'".escaped_key."'".")\<CR>a".c."\<LEFT>"
                            endfunction
                            
    1              0.000002 function! AutoPairsReturn()
                              if b:autopairs_enabled == 0
                                return ''
                              end
                              let line = getline('.')
                              let pline = getline(line('.')-1)
                              let prev_char = pline[strlen(pline)-1]
                              let cmd = ''
                              let cur_char = line[col('.')-1]
                              if has_key(b:AutoPairs, prev_char) && b:AutoPairs[prev_char] == cur_char
                                if g:AutoPairsCenterLine && winline() * 3 >= winheight(0) * 2
                                  " Recenter before adding new line to avoid replacing line content
                                  let cmd = "zz"
                                end
                            
                                " If equalprg has been set, then avoid call =
                                " https://github.com/jiangmiao/auto-pairs/issues/24
                                if &equalprg != ''
                                  return "\<ESC>".cmd."O"
                                endif
                            
                                " conflict with javascript and coffee
                                " javascript   need   indent new line
                                " coffeescript forbid indent new line
                                if &filetype == 'coffeescript' || &filetype == 'coffee'
                                  return "\<ESC>".cmd."k==o"
                                else
                                  return "\<ESC>".cmd."=ko"
                                endif
                              end
                              return ''
                            endfunction
                            
    1              0.000002 function! AutoPairsSpace()
                              let line = getline('.')
                              let prev_char = line[col('.')-2]
                              let cmd = ''
                              let cur_char =line[col('.')-1]
                              if has_key(g:AutoPairsParens, prev_char) && g:AutoPairsParens[prev_char] == cur_char
                                let cmd = "\<SPACE>".s:Left
                              endif
                              return "\<SPACE>".cmd
                            endfunction
                            
    1              0.000002 function! AutoPairsBackInsert()
                              if exists('b:autopairs_saved_pair')
                                let pair = b:autopairs_saved_pair[0]
                                let pos  = b:autopairs_saved_pair[1]
                                call setpos('.', pos)
                                return pair
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! AutoPairsInit()
                              let b:autopairs_loaded  = 1
                              if !exists('b:autopairs_enabled')
                                let b:autopairs_enabled = 1
                              end
                              let b:AutoPairsClosedPairs = {}
                            
                              if !exists('b:AutoPairs')
                                let b:AutoPairs = g:AutoPairs
                              end
                            
                              if !exists('b:AutoPairsMoveCharacter')
                                let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
                              end
                            
                              " buffer level map pairs keys
                              for [open, close] in items(b:AutoPairs)
                                call AutoPairsMap(open)
                                if open != close
                                  call AutoPairsMap(close)
                                end
                                let b:AutoPairsClosedPairs[close] = open
                              endfor
                            
                              for key in split(b:AutoPairsMoveCharacter, '\s*')
                                let escaped_key = substitute(key, "'", "''", 'g')
                                execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
                              endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
                              if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
                                execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
                              end
                            
                              if g:AutoPairsMapCh
                                execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
                              endif
                            
                              if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
                                let do_abbrev = ""
                                if v:version == 703 && has("patch489") || v:version > 703
                                  let do_abbrev = "<C-]>"
                                endif
                                execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
                              end
                            
                              if g:AutoPairsShortcutFastWrap != ''
                                execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
                              end
                            
                              if g:AutoPairsShortcutBackInsert != ''
                                execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
                              end
                            
                              if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
                                execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
                                execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
                              end
                            
                              if g:AutoPairsShortcutJump != ''
                                execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
                                execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
                              end
                            
                            endfunction
                            
    1              0.000003 function! s:ExpandMap(map)
                              let map = a:map
                              let map = substitute(map, '\(<Plug>\w\+\)', '\=maparg(submatch(1), "i")', 'g')
                              return map
                            endfunction
                            
    1              0.000002 function! AutoPairsTryInit()
                              if exists('b:autopairs_loaded')
                                return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
                              if g:AutoPairsMapCR
                                if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
                                  let info = maparg('<CR>', 'i', 0, 1)
                                  if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
                                  endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
                                if old_cr !~ 'AutoPairsReturn'
                                  if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
                                  execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
                                end
                              endif
                              call AutoPairsInit()
                            endfunction
                            
                            " Always silent the command
    1              0.000018 inoremap <silent> <SID>AutoPairsReturn <C-R>=AutoPairsReturn()<CR>
    1              0.000011 imap <script> <Plug>AutoPairsReturn <SID>AutoPairsReturn
                            
                            
    1              0.000010 au BufEnter * :call AutoPairsTryInit()

SCRIPT  /home/user/fbarotjr/.vim/plugged/vim-easycomment/plugin/easycomment.vim
Sourced 1 time
Total time:   0.000184
 Self time:   0.000184

count  total (s)   self (s)
                            function! s:IsLineCommented(l)
                                return getline(a:l) =~ '\v^\s*'.escape(b:comment_opener, "\/*")
                            endfunction
                            
    1              0.000003 function! ToggleCommentVisual() range
                                if exists("b:comment_style")
                                    let fl = getpos("'<")[1]
                                    let ll = getpos("'>")[1]
                            
                                    if s:IsLineCommented(fl)
                                        call s:Uncomment(fl, ll)
                                    else
                                        call s:Comment(fl, ll)
                                    endif
                                endif
                            endfunction
                            
    1              0.000002 function! ToggleCommentLine()
                                if exists("b:comment_style")
                                    let l = getpos(".")[1]
                            
                                    if s:IsLineCommented(l)
                                        call s:Uncomment(l, l)
                                    else
                                        call s:Comment(l, l)
                                    endif
                                endif
                            endfunction
                            
    1              0.000003 function! s:Comment(fl, ll)
                                if b:comment_style == "inline"
                                    call s:InlineComment(a:fl, a:ll)
                                elseif b:comment_style == "block"
                                    call s:BlockComment(a:fl, a:ll)
                                endif
                            endfunction
                            
    1              0.000003 function! s:Uncomment(fl, ll)
                                if b:comment_style == "inline"
                                    call s:InlineUncomment(a:fl, a:ll)
                                elseif b:comment_style == "block"
                                    call s:BlockUncomment(a:fl, a:ll)
                                endif
                            endfunction
                            
    1              0.000003 function! s:BlockComment(fl, ll)
                                call setline(a:fl, b:comment_opener.getline(a:fl))
                                call setline(a:ll, getline(a:ll).b:comment_closer)
                            
                                let padding = repeat(" ", strlen(b:comment_opener))
                                let i = a:fl+1
                                while i <= (a:ll - 1)
                                    call setline(i, padding.getline(i))
                                    let i = i + 1
                                endwhile
                            endfunction
                            
    1              0.000003 function! s:InlineComment(fl, ll)
                                let i = a:fl
                                while i <= a:ll
                                    if !s:IsLineCommented(i)
                                        let cl = getline(i)
                                        let cl2 = b:comment_opener.cl
                                        call setline(i, cl2)
                                    endif
                                    let i = i + 1
                                endwhile
                            endfunction
                            
    1              0.000002 function! s:BlockUncomment(fl, ll)
                                let i = a:fl
                                call setline(a:fl, substitute(getline(a:fl), '\v^(\s*)'.escape(b:comment_opener, "\/*"), '\1', ""))
                                call setline(a:ll, substitute(getline(a:ll), '\v(\s*)'.escape(b:comment_closer, "\/*")."$", '\1', ""))
                            
                                let padding = repeat(" ", strlen(b:comment_opener))
                                let i = a:fl+1
                                while i <= (a:ll - 1)
                                    call setline(i, substitute(getline(i), "^".padding, "", ""))
                                    let i = i + 1
                                endwhile
                            endfunction
                            
    1              0.000002 function! s:InlineUncomment(fl, ll)
                                let i = a:fl
                                while i <= a:ll
                                    let cl = getline(i)
                                    let cl2 = substitute(cl, '\v^(\s*)'.escape(b:comment_opener, "\/*"), '\1', "")
                                    call setline(i, cl2)
                                    let i = i + 1
                                endwhile
                            endfunction
                            
                            " comment style definitions
    1              0.000015 au FileType vim,javascript,python,ruby let b:comment_style="inline"
    1              0.000007 au FileType html,css,c let b:comment_style="block"
                            
    1              0.000004 au FileType vim let b:comment_opener='"'
    1              0.000005 au FileType javascript let b:comment_opener='//'
    1              0.000005 au FileType python,ruby let b:comment_opener='#'
                            
    1              0.000005 au FileType c,css let b:comment_opener='/*'
    1              0.000006 au FileType c,css let b:comment_closer='*/'
                            
    1              0.000004 au FileType html let b:comment_opener='<!--'
    1              0.000005 au FileType html let b:comment_closer='-->'

SCRIPT  /home/user/fbarotjr/.vim/plugged/vim-easy-align/plugin/easy_align.vim
Sourced 1 time
Total time:   0.000455
 Self time:   0.000455

count  total (s)   self (s)
                            " Copyright (c) 2014 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000011 if exists("g:loaded_easy_align_plugin")
                              finish
                            endif
    1              0.000005 let g:loaded_easy_align_plugin = 1
                            
    1              0.000027 command! -nargs=* -range -bang EasyAlign <line1>,<line2>call easy_align#align(<bang>0, 0, 'command', <q-args>)
    1              0.000021 command! -nargs=* -range -bang LiveEasyAlign <line1>,<line2>call easy_align#align(<bang>0, 1, 'command', <q-args>)
                            
    1              0.000005 let s:last_command = 'EasyAlign'
                            
    1              0.000005 function! s:abs(v)
                              return a:v >= 0 ? a:v : - a:v
                            endfunction
                            
    1              0.000005 function! s:remember_visual(mode)
                              let s:last_visual = [a:mode, s:abs(line("'>") - line("'<")), s:abs(col("'>") - col("'<"))]
                            endfunction
                            
    1              0.000003 function! s:repeat_visual()
                              let [mode, ldiff, cdiff] = s:last_visual
                              let cmd = 'normal! '.mode
                              if ldiff > 0
                                let cmd .= ldiff . 'j'
                              endif
                            
                              let ve_save = &virtualedit
                              try
                                if mode == "\<C-V>"
                                  if cdiff > 0
                                    let cmd .= cdiff . 'l'
                                  endif
                                  set virtualedit+=block
                                endif
                                execute cmd.":\<C-r>=g:easy_align_last_command\<Enter>\<Enter>"
                                call s:set_repeat()
                              finally
                                if ve_save != &virtualedit
                                  let &virtualedit = ve_save
                                endif
                              endtry
                            endfunction
                            
    1              0.000004 function! s:repeat_in_visual()
                              if exists('g:easy_align_last_command')
                                call s:remember_visual(visualmode())
                                call s:repeat_visual()
                              endif
                            endfunction
                            
    1              0.000006 function! s:set_repeat()
                              silent! call repeat#set("\<Plug>(EasyAlignRepeat)")
                            endfunction
                            
    1              0.000005 function! s:generic_easy_align_op(type, vmode, live)
                              if !&modifiable
                                if a:vmode
                                  normal! gv
                                endif
                                return
                              endif
                              let sel_save = &selection
                              let &selection = "inclusive"
                            
                              if a:vmode
                                let vmode = a:type
                                let [l1, l2] = ["'<", "'>"]
                                call s:remember_visual(vmode)
                              else
                                let vmode = ''
                                let [l1, l2] = [line("'["), line("']")]
                                unlet! s:last_visual
                              endif
                            
                              try
                                let range = l1.','.l2
                                if get(g:, 'easy_align_need_repeat', 0)
                                  execute range . g:easy_align_last_command
                                else
                                  execute range . "call easy_align#align(0, a:live, vmode, '')"
                                end
                                call s:set_repeat()
                              finally
                                let &selection = sel_save
                              endtry
                            endfunction
                            
    1              0.000004 function! s:easy_align_op(type, ...)
                              call s:generic_easy_align_op(a:type, a:0, 0)
                            endfunction
                            
    1              0.000004 function! s:live_easy_align_op(type, ...)
                              call s:generic_easy_align_op(a:type, a:0, 1)
                            endfunction
                            
    1              0.000004 function! s:easy_align_repeat()
                              if exists('s:last_visual')
                                call s:repeat_visual()
                              else
                                try
                                  let g:easy_align_need_repeat = 1
                                  normal! .
                                finally
                                  unlet! g:easy_align_need_repeat
                                endtry
                              endif
                            endfunction
                            
    1              0.000023 nnoremap <silent> <Plug>(EasyAlign) :set opfunc=<SID>easy_align_op<Enter>g@
    1              0.000019 vnoremap <silent> <Plug>(EasyAlign) :<C-U>call <SID>easy_align_op(visualmode(), 1)<Enter>
    1              0.000019 nnoremap <silent> <Plug>(LiveEasyAlign) :set opfunc=<SID>live_easy_align_op<Enter>g@
    1              0.000020 vnoremap <silent> <Plug>(LiveEasyAlign) :<C-U>call <SID>live_easy_align_op(visualmode(), 1)<Enter>
                            
                            " vim-repeat support
    1              0.000018 nnoremap <silent> <Plug>(EasyAlignRepeat) :call <SID>easy_align_repeat()<Enter>
    1              0.000017 vnoremap <silent> <Plug>(EasyAlignRepeat) :<C-U>call <SID>repeat_in_visual()<Enter>
                            
                            " Backward-compatibility (deprecated)
    1              0.000018 nnoremap <silent> <Plug>(EasyAlignOperator) :set opfunc=<SID>easy_align_op<Enter>g@
                            

SCRIPT  /home/user/fbarotjr/.vim/plugged/vim-autoswap/plugin/autoswap.vim
Sourced 1 time
Total time:   0.000407
 Self time:   0.000407

count  total (s)   self (s)
                            " Vim global plugin for automating response to swapfiles
                            " Maintainer: Gioele Barabucci
                            " Author:     Damian Conway
                            " License:    This is free software released into the public domain (CC0 license).
                            
                            "#############################################################
                            "##                                                         ##
                            "##  Note that this plugin only works if your Vim           ##
                            "##  configuration includes:                                ##
                            "##                                                         ##
                            "##     set title titlestring=                              ##
                            "##                                                         ##
                            "##  On MacOS X this plugin works only for Vim sessions     ##
                            "##  running in Terminal.                                   ##
                            "##                                                         ##
                            "##  On Linux this plugin requires the external program     ##
                            "##  wmctrl, packaged for most distributions.               ##
                            "##                                                         ##
                            "##  See below for the two functions that would have to be  ##
                            "##  rewritten to port this plugin to other OS's.           ##
                            "##                                                         ##
                            "#############################################################
                            
                            
                            " If already loaded, we're done...
    1              0.000008 if exists("loaded_autoswap")
                            	finish
                            endif
    1              0.000004 let loaded_autoswap = 1
                            
                            " By default we don't try to detect tmux
    1              0.000005 if !exists("g:autoswap_detect_tmux")
                            	let g:autoswap_detect_tmux = 0
                            endif
                            
                            " Preserve external compatibility options, then enable full vim compatibility...
    1              0.000013 let s:save_cpo = &cpo
    1              0.000014 set cpo&vim
                            
                            " Invoke the behaviour whenever a swapfile is detected...
                            "
    1              0.000002 augroup AutoSwap
    1              0.000182 	autocmd!
    1              0.000009 	autocmd SwapExists *  call AS_HandleSwapfile(expand('<afile>:p'), v:swapname)
    1              0.000001 augroup END
                            
                            " The automatic behaviour...
                            "
    1              0.000003 function! AS_HandleSwapfile (filename, swapname)
                            
                            	" Is file already open in another Vim session in some other window?
                            	let active_window = AS_DetectActiveWindow(a:filename, a:swapname)
                            
                            	" If so, go there instead and terminate this attempt to open the file...
                            	if (strlen(active_window) > 0)
                            		call AS_DelayedMsg('Switched to existing session in another window')
                            		call AS_SwitchToActiveWindow(active_window)
                            		let v:swapchoice = 'q'
                            
                            	" Otherwise, if swapfile is older than file itself, just get rid of it...
                            	elseif getftime(v:swapname) < getftime(a:filename)
                            		call AS_DelayedMsg('Old swapfile detected... and deleted')
                            		call delete(v:swapname)
                            		let v:swapchoice = 'e'
                            
                            	" Otherwise, open file read-only...
                            	else
                            		call AS_DelayedMsg('Swapfile detected, opening read-only')
                            		let v:swapchoice = 'o'
                            	endif
                            endfunction
                            
                            
                            " Print a message after the autocommand completes
                            " (so you can see it, but don't have to hit <ENTER> to continue)...
                            "
    1              0.000002 function! AS_DelayedMsg (msg)
                            	" A sneaky way of injecting a message when swapping into the new buffer...
                            	augroup AutoSwap_Msg
                            		autocmd!
                            		" Print the message on finally entering the buffer...
                            		autocmd BufWinEnter *  echohl WarningMsg
                              exec 'autocmd BufWinEnter *  echon "\r'.printf("%-60s", a:msg).'"'
                            		autocmd BufWinEnter *  echohl NONE
                            
                            		" And then remove these autocmds, so it's a "one-shot" deal...
                            		autocmd BufWinEnter *  augroup AutoSwap_Msg
                            		autocmd BufWinEnter *  autocmd!
                            		autocmd BufWinEnter *  augroup END
                            	augroup END
                            endfunction
                            
                            
                            "#################################################################
                            "##                                                             ##
                            "##  To port this plugin to other operating systems             ##
                            "##                                                             ##
                            "##    1. Rewrite the Detect and the Switch function            ##
                            "##    2. Add a new elseif case to the list of OS               ##
                            "##                                                             ##
                            "#################################################################
                            
    1              0.000001 function! AS_RunningTmux ()
                            	if $TMUX != ""
                            		return 1
                            	endif
                            	return 0
                            endfunction
                            
                            " Return an identifier for a terminal window already editing the named file
                            " (Should either return a string identifying the active window,
                            "  or else return an empty string to indicate "no active window")...
                            "
    1              0.000002 function! AS_DetectActiveWindow (filename, swapname)
                            	if g:autoswap_detect_tmux && AS_RunningTmux()
                            		let active_window = AS_DetectActiveWindow_Tmux(a:swapname)
                            	elseif has('macunix')
                            		let active_window = AS_DetectActiveWindow_Mac(a:filename)
                            	elseif has('unix')
                            		let active_window = AS_DetectActiveWindow_Linux(a:filename)
                            	endif
                            	return active_window
                            endfunction
                            
                            " TMUX: Detection function for tmux, uses tmux
    1              0.000003 function! AS_DetectActiveWindow_Tmux (swapname)
                            	let pid = systemlist('fuser '.a:swapname.' 2>/dev/null | grep -o "[0-9]*"')
                            	if (len(pid) == 0)
                            		return ''
                            	endif
                            	let tty = systemlist('ps h '.pid[0].' 2>/dev/null | sed -rn "s/^ *[0-9]+ +([^ ]+).*/\1/p" 2>/dev/null')
                            	if (len(tty) == 0)
                            		return ''
                            	endif
                            	let window = systemlist('tmux list-panes -aF "#{pane_tty} #{window_index} #{pane_index}" | grep -F "'.tty[0].'" 2>/dev/null')
                            	if (len(window) == 0)
                            		return ''
                            	endif
                            	return window[0]
                            endfunction
                            
                            " LINUX: Detection function for Linux, uses mwctrl
    1              0.000003 function! AS_DetectActiveWindow_Linux (filename)
                            	let shortname = fnamemodify(a:filename,":t")
                            	let find_win_cmd = 'wmctrl -l | grep -i " '.shortname.' .*vim" | tail -n1 | cut -d" " -f1'
                            	let active_window = system(find_win_cmd)
                            	return (active_window =~ '0x' ? active_window : "")
                            endfunction
                            
                            " MAC: Detection function for Mac OSX, uses osascript
    1              0.000002 function! AS_DetectActiveWindow_Mac (filename)
                            	let shortname = fnamemodify(a:filename,":t")
                            	let active_window = system('osascript -e ''tell application "Terminal" to every window whose (name begins with "'.shortname.' " and name ends with "VIM")''')
                            	let active_window = substitute(active_window, '^window id \d\+\zs\_.*', '', '')
                            	return (active_window =~ 'window' ? active_window : "")
                            endfunction
                            
                            
                            " Switch to terminal window specified...
                            "
    1              0.000002 function! AS_SwitchToActiveWindow (active_window)
                            	if g:autoswap_detect_tmux && AS_RunningTmux()
                            		call AS_SwitchToActiveWindow_Tmux(a:active_window)
                            	elseif has('macunix')
                            		call AS_SwitchToActiveWindow_Mac(a:active_window)
                            	elseif has('unix')
                            		call AS_SwitchToActiveWindow_Linux(a:active_window)
                            	endif
                            endfunction
                            
                            " TMUX: Switch function for Tmux
    1              0.000002 function! AS_SwitchToActiveWindow_Tmux (active_window)
                            	let pane_info = split(a:active_window)
                            	call system('tmux select-window -t '.pane_info[1].'; tmux select-pane -t '.pane_info[2])
                            endfunction
                            
                            " LINUX: Switch function for Linux, uses wmctrl
    1              0.000002 function! AS_SwitchToActiveWindow_Linux (active_window)
                            	call system('wmctrl -i -a "'.a:active_window.'"')
                            endfunction
                            
                            " MAC: Switch function for Mac, uses osascript
    1              0.000002 function! AS_SwitchToActiveWindow_Mac (active_window)
                            	call system('osascript -e ''tell application "Terminal" to set frontmost of '.a:active_window.' to true''')
                            endfunction
                            
                            
                            " Restore previous external compatibility options
    1              0.000012 let &cpo = s:save_cpo

SCRIPT  /home/user/fbarotjr/.vim/plugged/vim-surround/plugin/surround.vim
Sourced 1 time
Total time:   0.000665
 Self time:   0.000665

count  total (s)   self (s)
                            " surround.vim - Surroundings
                            " Author:       Tim Pope <http://tpo.pe/>
                            " Version:      2.1
                            " GetLatestVimScripts: 1697 1 :AutoInstall: surround.vim
                            
    1              0.000014 if exists("g:loaded_surround") || &cp || v:version < 700
                              finish
                            endif
    1              0.000003 let g:loaded_surround = 1
                            
                            " Input functions {{{1
                            
    1              0.000004 function! s:getchar()
                              let c = getchar()
                              if c =~ '^\d\+$'
                                let c = nr2char(c)
                              endif
                              return c
                            endfunction
                            
    1              0.000002 function! s:inputtarget()
                              let c = s:getchar()
                              while c =~ '^\d\+$'
                                let c .= s:getchar()
                              endwhile
                              if c == " "
                                let c .= s:getchar()
                              endif
                              if c =~ "\<Esc>\|\<C-C>\|\0"
                                return ""
                              else
                                return c
                              endif
                            endfunction
                            
    1              0.000002 function! s:inputreplacement()
                              let c = s:getchar()
                              if c == " "
                                let c .= s:getchar()
                              endif
                              if c =~ "\<Esc>" || c =~ "\<C-C>"
                                return ""
                              else
                                return c
                              endif
                            endfunction
                            
    1              0.000001 function! s:beep()
                              exe "norm! \<Esc>"
                              return ""
                            endfunction
                            
    1              0.000001 function! s:redraw()
                              redraw
                              return ""
                            endfunction
                            
                            " }}}1
                            
                            " Wrapping functions {{{1
                            
    1              0.000002 function! s:extractbefore(str)
                              if a:str =~ '\r'
                                return matchstr(a:str,'.*\ze\r')
                              else
                                return matchstr(a:str,'.*\ze\n')
                              endif
                            endfunction
                            
    1              0.000002 function! s:extractafter(str)
                              if a:str =~ '\r'
                                return matchstr(a:str,'\r\zs.*')
                              else
                                return matchstr(a:str,'\n\zs.*')
                              endif
                            endfunction
                            
    1              0.000002 function! s:fixindent(str,spc)
                              let str = substitute(a:str,'\t',repeat(' ',&sw),'g')
                              let spc = substitute(a:spc,'\t',repeat(' ',&sw),'g')
                              let str = substitute(str,'\(\n\|\%^\).\@=','\1'.spc,'g')
                              if ! &et
                                let str = substitute(str,'\s\{'.&ts.'\}',"\t",'g')
                              endif
                              return str
                            endfunction
                            
    1              0.000002 function! s:process(string)
                              let i = 0
                              for i in range(7)
                                let repl_{i} = ''
                                let m = matchstr(a:string,nr2char(i).'.\{-\}\ze'.nr2char(i))
                                if m != ''
                                  let m = substitute(strpart(m,1),'\r.*','','')
                                  let repl_{i} = input(match(m,'\w\+$') >= 0 ? m.': ' : m)
                                endif
                              endfor
                              let s = ""
                              let i = 0
                              while i < strlen(a:string)
                                let char = strpart(a:string,i,1)
                                if char2nr(char) < 8
                                  let next = stridx(a:string,char,i+1)
                                  if next == -1
                                    let s .= char
                                  else
                                    let insertion = repl_{char2nr(char)}
                                    let subs = strpart(a:string,i+1,next-i-1)
                                    let subs = matchstr(subs,'\r.*')
                                    while subs =~ '^\r.*\r'
                                      let sub = matchstr(subs,"^\r\\zs[^\r]*\r[^\r]*")
                                      let subs = strpart(subs,strlen(sub)+1)
                                      let r = stridx(sub,"\r")
                                      let insertion = substitute(insertion,strpart(sub,0,r),strpart(sub,r+1),'')
                                    endwhile
                                    let s .= insertion
                                    let i = next
                                  endif
                                else
                                  let s .= char
                                endif
                                let i += 1
                              endwhile
                              return s
                            endfunction
                            
    1              0.000003 function! s:wrap(string,char,type,removed,special)
                              let keeper = a:string
                              let newchar = a:char
                              let s:input = ""
                              let type = a:type
                              let linemode = type ==# 'V' ? 1 : 0
                              let before = ""
                              let after  = ""
                              if type ==# "V"
                                let initspaces = matchstr(keeper,'\%^\s*')
                              else
                                let initspaces = matchstr(getline('.'),'\%^\s*')
                              endif
                              let pairs = "b()B{}r[]a<>"
                              let extraspace = ""
                              if newchar =~ '^ '
                                let newchar = strpart(newchar,1)
                                let extraspace = ' '
                              endif
                              let idx = stridx(pairs,newchar)
                              if newchar == ' '
                                let before = ''
                                let after  = ''
                              elseif exists("b:surround_".char2nr(newchar))
                                let all    = s:process(b:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif exists("g:surround_".char2nr(newchar))
                                let all    = s:process(g:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif newchar ==# "p"
                                let before = "\n"
                                let after  = "\n\n"
                              elseif newchar ==# 's'
                                let before = ' '
                                let after  = ''
                              elseif newchar ==# ':'
                                let before = ':'
                                let after = ''
                              elseif newchar =~# "[tT\<C-T><]"
                                let dounmapp = 0
                                let dounmapb = 0
                                if !maparg(">","c")
                                  let dounmapb = 1
                                  " Hide from AsNeeded
                                  exe "cn"."oremap > ><CR>"
                                endif
                                let default = ""
                                if newchar ==# "T"
                                  if !exists("s:lastdel")
                                    let s:lastdel = ""
                                  endif
                                  let default = matchstr(s:lastdel,'<\zs.\{-\}\ze>')
                                endif
                                let tag = input("<",default)
                                if dounmapb
                                  silent! cunmap >
                                endif
                                let s:input = tag
                                if tag != ""
                                  let keepAttributes = ( match(tag, ">$") == -1 )
                                  let tag = substitute(tag,'>*$','','')
                                  let attributes = ""
                                  if keepAttributes
                                    let attributes = matchstr(a:removed, '<[^ \t\n]\+\zs\_.\{-\}\ze>')
                                  endif
                                  let s:input = tag . '>'
                                  if tag =~ '/$'
                                    let tag = substitute(tag, '/$', '', '')
                                    let before = '<'.tag.attributes.' />'
                                    let after = ''
                                  else
                                    let before = '<'.tag.attributes.'>'
                                    let after  = '</'.substitute(tag,' .*','','').'>'
                                  endif
                                  if newchar == "\<C-T>"
                                    if type ==# "v" || type ==# "V"
                                      let before .= "\n\t"
                                    endif
                                    if type ==# "v"
                                      let after  = "\n". after
                                    endif
                                  endif
                                endif
                              elseif newchar ==# 'l' || newchar == '\'
                                " LaTeX
                                let env = input('\begin{')
                                if env != ""
                                  let s:input = env."\<CR>"
                                  let env = '{' . env
                                  let env .= s:closematch(env)
                                  echo '\begin'.env
                                  let before = '\begin'.env
                                  let after  = '\end'.matchstr(env,'[^}]*').'}'
                                endif
                              elseif newchar ==# 'f' || newchar ==# 'F'
                                let fnc = input('function: ')
                                if fnc != ""
                                  let s:input = fnc."\<CR>"
                                  let before = substitute(fnc,'($','','').'('
                                  let after  = ')'
                                  if newchar ==# 'F'
                                    let before .= ' '
                                    let after = ' ' . after
                                  endif
                                endif
                              elseif newchar ==# "\<C-F>"
                                let fnc = input('function: ')
                                let s:input = fnc."\<CR>"
                                let before = '('.fnc.' '
                                let after = ')'
                              elseif idx >= 0
                                let spc = (idx % 3) == 1 ? " " : ""
                                let idx = idx / 3 * 3
                                let before = strpart(pairs,idx+1,1) . spc
                                let after  = spc . strpart(pairs,idx+2,1)
                              elseif newchar == "\<C-[>" || newchar == "\<C-]>"
                                let before = "{\n\t"
                                let after  = "\n}"
                              elseif newchar !~ '\a'
                                let before = newchar
                                let after  = newchar
                              else
                                let before = ''
                                let after  = ''
                              endif
                              let after  = substitute(after ,'\n','\n'.initspaces,'g')
                              if type ==# 'V' || (a:special && type ==# "v")
                                let before = substitute(before,' \+$','','')
                                let after  = substitute(after ,'^ \+','','')
                                if after !~ '^\n'
                                  let after  = initspaces.after
                                endif
                                if keeper !~ '\n$' && after !~ '^\n'
                                  let keeper .= "\n"
                                elseif keeper =~ '\n$' && after =~ '^\n'
                                  let after = strpart(after,1)
                                endif
                                if before !~ '\n\s*$'
                                  let before .= "\n"
                                  if a:special
                                    let before .= "\t"
                                  endif
                                endif
                              endif
                              if type ==# 'V'
                                let before = initspaces.before
                              endif
                              if before =~ '\n\s*\%$'
                                if type ==# 'v'
                                  let keeper = initspaces.keeper
                                endif
                                let padding = matchstr(before,'\n\zs\s\+\%$')
                                let before  = substitute(before,'\n\s\+\%$','\n','')
                                let keeper = s:fixindent(keeper,padding)
                              endif
                              if type ==# 'V'
                                let keeper = before.keeper.after
                              elseif type =~ "^\<C-V>"
                                " Really we should be iterating over the buffer
                                let repl = substitute(before,'[\\~]','\\&','g').'\1'.substitute(after,'[\\~]','\\&','g')
                                let repl = substitute(repl,'\n',' ','g')
                                let keeper = substitute(keeper."\n",'\(.\{-\}\)\(\n\)',repl.'\n','g')
                                let keeper = substitute(keeper,'\n\%$','','')
                              else
                                let keeper = before.extraspace.keeper.extraspace.after
                              endif
                              return keeper
                            endfunction
                            
    1              0.000002 function! s:wrapreg(reg,char,removed,special)
                              let orig = getreg(a:reg)
                              let type = substitute(getregtype(a:reg),'\d\+$','','')
                              let new = s:wrap(orig,a:char,type,a:removed,a:special)
                              call setreg(a:reg,new,type)
                            endfunction
                            " }}}1
                            
    1              0.000002 function! s:insert(...) " {{{1
                              " Optional argument causes the result to appear on 3 lines, not 1
                              let linemode = a:0 ? a:1 : 0
                              let char = s:inputreplacement()
                              while char == "\<CR>" || char == "\<C-S>"
                                " TODO: use total count for additional blank lines
                                let linemode += 1
                                let char = s:inputreplacement()
                              endwhile
                              if char == ""
                                return ""
                              endif
                              let cb_save = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let reg_save = @@
                              call setreg('"',"\r",'v')
                              call s:wrapreg('"',char,"",linemode)
                              " If line mode is used and the surrounding consists solely of a suffix,
                              " remove the initial newline.  This fits a use case of mine but is a
                              " little inconsistent.  Is there anyone that would prefer the simpler
                              " behavior of just inserting the newline?
                              if linemode && match(getreg('"'),'^\n\s*\zs.*') == 0
                                call setreg('"',matchstr(getreg('"'),'^\n\s*\zs.*'),getregtype('"'))
                              endif
                              " This can be used to append a placeholder to the end
                              if exists("g:surround_insert_tail")
                                call setreg('"',g:surround_insert_tail,"a".getregtype('"'))
                              endif
                              if col('.') >= col('$')
                                norm! ""p
                              else
                                norm! ""P
                              endif
                              if linemode
                                call s:reindent()
                              endif
                              norm! `]
                              call search('\r','bW')
                              let @@ = reg_save
                              let &clipboard = cb_save
                              return "\<Del>"
                            endfunction " }}}1
                            
    1              0.000002 function! s:reindent() " {{{1
                              if exists("b:surround_indent") ? b:surround_indent : (!exists("g:surround_indent") || g:surround_indent)
                                silent norm! '[=']
                              endif
                            endfunction " }}}1
                            
    1              0.000001 function! s:dosurround(...) " {{{1
                              let scount = v:count1
                              let char = (a:0 ? a:1 : s:inputtarget())
                              let spc = ""
                              if char =~ '^\d\+'
                                let scount = scount * matchstr(char,'^\d\+')
                                let char = substitute(char,'^\d\+','','')
                              endif
                              if char =~ '^ '
                                let char = strpart(char,1)
                                let spc = 1
                              endif
                              if char == 'a'
                                let char = '>'
                              endif
                              if char == 'r'
                                let char = ']'
                              endif
                              let newchar = ""
                              if a:0 > 1
                                let newchar = a:2
                                if newchar == "\<Esc>" || newchar == "\<C-C>" || newchar == ""
                                  return s:beep()
                                endif
                              endif
                              let cb_save = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let append = ""
                              let original = getreg('"')
                              let otype = getregtype('"')
                              call setreg('"',"")
                              let strcount = (scount == 1 ? "" : scount)
                              if char == '/'
                                exe 'norm! '.strcount.'[/d'.strcount.']/'
                              elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>"''`]'
                                exe 'norm! T'.char
                                if getline('.')[col('.')-1] == char
                                  exe 'norm! l'
                                endif
                                exe 'norm! dt'.char
                              else
                                exe 'norm! d'.strcount.'i'.char
                              endif
                              let keeper = getreg('"')
                              let okeeper = keeper " for reindent below
                              if keeper == ""
                                call setreg('"',original,otype)
                                let &clipboard = cb_save
                                return ""
                              endif
                              let oldline = getline('.')
                              let oldlnum = line('.')
                              if char ==# "p"
                                call setreg('"','','V')
                              elseif char ==# "s" || char ==# "w" || char ==# "W"
                                " Do nothing
                                call setreg('"','')
                              elseif char =~ "[\"'`]"
                                exe "norm! i \<Esc>d2i".char
                                call setreg('"',substitute(getreg('"'),' ','',''))
                              elseif char == '/'
                                norm! "_x
                                call setreg('"','/**/',"c")
                                let keeper = substitute(substitute(keeper,'^/\*\s\=','',''),'\s\=\*$','','')
                              elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>]'
                                exe 'norm! F'.char
                                exe 'norm! df'.char
                              else
                                " One character backwards
                                call search('\m.', 'bW')
                                exe "norm! da".char
                              endif
                              let removed = getreg('"')
                              let rem2 = substitute(removed,'\n.*','','')
                              let oldhead = strpart(oldline,0,strlen(oldline)-strlen(rem2))
                              let oldtail = strpart(oldline,  strlen(oldline)-strlen(rem2))
                              let regtype = getregtype('"')
                              if char =~# '[\[({<T]' || spc
                                let keeper = substitute(keeper,'^\s\+','','')
                                let keeper = substitute(keeper,'\s\+$','','')
                              endif
                              if col("']") == col("$") && col('.') + 1 == col('$')
                                if oldhead =~# '^\s*$' && a:0 < 2
                                  let keeper = substitute(keeper,'\%^\n'.oldhead.'\(\s*.\{-\}\)\n\s*\%$','\1','')
                                endif
                                let pcmd = "p"
                              else
                                let pcmd = "P"
                              endif
                              if line('.') + 1 < oldlnum && regtype ==# "V"
                                let pcmd = "p"
                              endif
                              call setreg('"',keeper,regtype)
                              if newchar != ""
                                let special = a:0 > 2 ? a:3 : 0
                                call s:wrapreg('"',newchar,removed,special)
                              endif
                              silent exe 'norm! ""'.pcmd.'`['
                              if removed =~ '\n' || okeeper =~ '\n' || getreg('"') =~ '\n'
                                call s:reindent()
                              endif
                              if getline('.') =~ '^\s\+$' && keeper =~ '^\s*\n'
                                silent norm! cc
                              endif
                              call setreg('"',original,otype)
                              let s:lastdel = removed
                              let &clipboard = cb_save
                              if newchar == ""
                                silent! call repeat#set("\<Plug>Dsurround".char,scount)
                              else
                                silent! call repeat#set("\<Plug>C".(a:0 > 2 && a:3 ? "S" : "s")."urround".char.newchar.s:input,scount)
                              endif
                            endfunction " }}}1
                            
    1              0.000002 function! s:changesurround(...) " {{{1
                              let a = s:inputtarget()
                              if a == ""
                                return s:beep()
                              endif
                              let b = s:inputreplacement()
                              if b == ""
                                return s:beep()
                              endif
                              call s:dosurround(a,b,a:0 && a:1)
                            endfunction " }}}1
                            
    1              0.000002 function! s:opfunc(type,...) " {{{1
                              let char = s:inputreplacement()
                              if char == ""
                                return s:beep()
                              endif
                              let reg = '"'
                              let sel_save = &selection
                              let &selection = "inclusive"
                              let cb_save  = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let reg_save = getreg(reg)
                              let reg_type = getregtype(reg)
                              let type = a:type
                              if a:type == "char"
                                silent exe 'norm! v`[o`]"'.reg.'y'
                                let type = 'v'
                              elseif a:type == "line"
                                silent exe 'norm! `[V`]"'.reg.'y'
                                let type = 'V'
                              elseif a:type ==# "v" || a:type ==# "V" || a:type ==# "\<C-V>"
                                let &selection = sel_save
                                let ve = &virtualedit
                                if !(a:0 && a:1)
                                  set virtualedit=
                                endif
                                silent exe 'norm! gv"'.reg.'y'
                                let &virtualedit = ve
                              elseif a:type =~ '^\d\+$'
                                let type = 'v'
                                silent exe 'norm! ^v'.a:type.'$h"'.reg.'y'
                                if mode() ==# 'v'
                                  norm! v
                                  return s:beep()
                                endif
                              else
                                let &selection = sel_save
                                let &clipboard = cb_save
                                return s:beep()
                              endif
                              let keeper = getreg(reg)
                              if type ==# "v" && a:type !=# "v"
                                let append = matchstr(keeper,'\_s\@<!\s*$')
                                let keeper = substitute(keeper,'\_s\@<!\s*$','','')
                              endif
                              call setreg(reg,keeper,type)
                              call s:wrapreg(reg,char,"",a:0 && a:1)
                              if type ==# "v" && a:type !=# "v" && append != ""
                                call setreg(reg,append,"ac")
                              endif
                              silent exe 'norm! gv'.(reg == '"' ? '' : '"' . reg).'p`['
                              if type ==# 'V' || (getreg(reg) =~ '\n' && type ==# 'v')
                                call s:reindent()
                              endif
                              call setreg(reg,reg_save,reg_type)
                              let &selection = sel_save
                              let &clipboard = cb_save
                              if a:type =~ '^\d\+$'
                                silent! call repeat#set("\<Plug>Y".(a:0 && a:1 ? "S" : "s")."surround".char.s:input,a:type)
                              else
                                silent! call repeat#set("\<Plug>SurroundRepeat".char.s:input)
                              endif
                            endfunction
                            
    1              0.000002 function! s:opfunc2(arg)
                              call s:opfunc(a:arg,1)
                            endfunction " }}}1
                            
    1              0.000002 function! s:closematch(str) " {{{1
                              " Close an open (, {, [, or < on the command line.
                              let tail = matchstr(a:str,'.[^\[\](){}<>]*$')
                              if tail =~ '^\[.\+'
                                return "]"
                              elseif tail =~ '^(.\+'
                                return ")"
                              elseif tail =~ '^{.\+'
                                return "}"
                              elseif tail =~ '^<.+'
                                return ">"
                              else
                                return ""
                              endif
                            endfunction " }}}1
                            
    1              0.000015 nnoremap <silent> <Plug>SurroundRepeat .
    1              0.000017 nnoremap <silent> <Plug>Dsurround  :<C-U>call <SID>dosurround(<SID>inputtarget())<CR>
    1              0.000016 nnoremap <silent> <Plug>Csurround  :<C-U>call <SID>changesurround()<CR>
    1              0.000014 nnoremap <silent> <Plug>CSurround  :<C-U>call <SID>changesurround(1)<CR>
    1              0.000012 nnoremap <silent> <Plug>Yssurround :<C-U>call <SID>opfunc(v:count1)<CR>
    1              0.000010 nnoremap <silent> <Plug>YSsurround :<C-U>call <SID>opfunc2(v:count1)<CR>
                            " <C-U> discards the numerical argument but there's not much we can do with it
    1              0.000010 nnoremap <silent> <Plug>Ysurround  :<C-U>set opfunc=<SID>opfunc<CR>g@
    1              0.000010 nnoremap <silent> <Plug>YSurround  :<C-U>set opfunc=<SID>opfunc2<CR>g@
    1              0.000013 vnoremap <silent> <Plug>VSurround  :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 1 : 0)<CR>
    1              0.000014 vnoremap <silent> <Plug>VgSurround :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 0 : 1)<CR>
    1              0.000009 inoremap <silent> <Plug>Isurround  <C-R>=<SID>insert()<CR>
    1              0.000009 inoremap <silent> <Plug>ISurround  <C-R>=<SID>insert(1)<CR>
                            
    1              0.000006 if !exists("g:surround_no_mappings") || ! g:surround_no_mappings
    1              0.000006   nmap ds  <Plug>Dsurround
    1              0.000006   nmap cs  <Plug>Csurround
    1              0.000006   nmap cS  <Plug>CSurround
    1              0.000006   nmap ys  <Plug>Ysurround
    1              0.000006   nmap yS  <Plug>YSurround
    1              0.000010   nmap yss <Plug>Yssurround
    1              0.000010   nmap ySs <Plug>YSsurround
    1              0.000008   nmap ySS <Plug>YSsurround
    1              0.000006   xmap S   <Plug>VSurround
    1              0.000007   xmap gS  <Plug>VgSurround
    1              0.000004   if !exists("g:surround_no_insert_mappings") || ! g:surround_no_insert_mappings
    1              0.000029     if !hasmapto("<Plug>Isurround","i") && "" == mapcheck("<C-S>","i")
    1              0.000009       imap    <C-S> <Plug>Isurround
    1              0.000001     endif
    1              0.000005     imap      <C-G>s <Plug>Isurround
    1              0.000007     imap      <C-G>S <Plug>ISurround
    1              0.000001   endif
    1              0.000001 endif
                            
                            " vim:set ft=vim sw=2 sts=2 et:

SCRIPT  /home/user/fbarotjr/.vim/plugged/VimCompletesMe/plugin/VimCompletesMe.vim
Sourced 1 time
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
                            " VimCompletesMe.vim - Super simple tab completion
                            " Maintainer:          Akshay Hegde <http://github.com/ajh17>
                            " Version:             1.4
                            " Website:             <http://github.com/ajh17/VimCompletesMe>
                            
                            " Vimscript Setup: {{{1
    1              0.000010 if exists("g:loaded_VimCompletesMe") || v:version < 703 || &compatible
                              finish
                            endif
    1              0.000003 let g:loaded_VimCompletesMe = 1
                            
                            " Options: {{{1
    1              0.000003 if !exists('g:vcm_s_tab_behavior')
    1              0.000002   let g:vcm_s_tab_behavior = 0
    1              0.000001 endif
    1              0.000003 if !exists('g:vcm_direction')
    1              0.000002   let g:vcm_direction = 'n'
    1              0.000000 endif
    1              0.000003 if !exists('g:vcm_default_maps')
    1              0.000002   let g:vcm_default_maps = 1
    1              0.000001 endif
    1              0.000002 if !exists('g:vcm_omni_pattern')
    1              0.000002   let g:vcm_omni_pattern = '\k\+\(\.\|->\|::\)\k*$'
    1              0.000000 endif
                            
                            " Functions: {{{1
    1              0.000005 function! s:vim_completes_me(shift_tab)
                              let dirs = ["\<c-p>", "\<c-n>"]
                              let dir = g:vcm_direction =~? '[nf]'
                              let map = exists('b:vcm_tab_complete') ? b:vcm_tab_complete : ''
                            
                              if pumvisible()
                                return a:shift_tab ? dirs[!dir] : dirs[dir]
                              endif
                            
                              " Figure out whether we should indent/de-indent.
                              let pos = getpos('.')
                              let substr = matchstr(strpart(getline(pos[1]), 0, pos[2]-1), "[^ \t]*$")
                              if empty(substr)
                                  let s_tab_deindent = pos[2] > 1 ? "\<C-h>" : ""
                                  return (a:shift_tab && !g:vcm_s_tab_behavior) ? l:s_tab_deindent : "\<Tab>"
                              endif
                            
                              if a:shift_tab && exists('g:vcm_s_tab_mapping')
                                  return g:vcm_s_tab_mapping
                              endif
                            
                              let omni_pattern = get(b:, 'vcm_omni_pattern', get(g:, 'vcm_omni_pattern'))
                              let is_omni_pattern = match(substr, omni_pattern) != -1
                              let file_pattern = (has('win32') || has('win64')) ? '\\\|\/' : '\/'
                              let is_file_pattern = match(substr, file_pattern) != -1
                            
                              if is_omni_pattern && (!empty(&omnifunc))
                                " Check position so that we can fallback if at the same pos.
                                if get(b:, 'tab_complete_pos', []) == pos && b:completion_tried
                                  let exp = "\<C-x>" . dirs[!dir]
                                else
                                  echo "Looking for members..."
                                  let exp = (!empty(&completefunc) && map ==? "user") ? "\<C-x>\<C-u>" : "\<C-x>\<C-o>"
                                  let b:completion_tried = 1
                                endif
                                let b:tab_complete_pos = pos
                                return exp
                              elseif is_file_pattern
                                return "\<C-x>\<C-f>"
                              endif
                            
                              " First fallback to keyword completion if special completion was already tried.
                              if exists('b:completion_tried') && b:completion_tried
                                let b:completion_tried = 0
                                return "\<C-e>" . dirs[!dir]
                              endif
                            
                              " Fallback
                              let b:completion_tried = 1
                              if map ==? "user"
                                return "\<C-x>\<C-u>"
                              elseif map ==? "omni"
                                echo "Looking for members..."
                                return "\<C-x>\<C-o>"
                              elseif map ==? "vim"
                                return "\<C-x>\<C-v>"
                              else
                                return dirs[!dir]
                              endif
                            endfunction
                            
    1              0.000016 inoremap <expr> <plug>vim_completes_me_forward  <sid>vim_completes_me(0)
    1              0.000011 inoremap <expr> <plug>vim_completes_me_backward <sid>vim_completes_me(1)
                            
                            " Maps: {{{1
    1              0.000002 if g:vcm_default_maps
    1              0.000008   imap <Tab>   <plug>vim_completes_me_forward
    1              0.000008   imap <S-Tab> <plug>vim_completes_me_backward
    1              0.000001 endif
                            
                            " Autocmds {{{1
    1              0.000002 augroup VCM
    1              0.000089   autocmd!
    1              0.000008   autocmd InsertEnter * let b:completion_tried = 0
    1              0.000005   if v:version > 703 || v:version == 703 && has('patch598')
    1              0.000006     autocmd CompleteDone * let b:completion_tried = 0
    1              0.000001   endif
    1              0.000002 augroup END

SCRIPT  /home/user/fbarotjr/.vim/plugged/vim-diff-enhanced/plugin/EnhancedDiff.vim
Sourced 1 time
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
                            " EnhancedDiff.vim - Enhanced Diff functions for Vim
                            " -------------------------------------------------------------
                            " Version: 0.3
                            " Maintainer:  Christian Brabandt <cb@256bit.org>
                            " Last Change: Thu, 05 Mar 2015 08:11:46 +0100
                            " Script: http://www.vim.org/scripts/script.php?script_id=5121
                            " Copyright:   (c) 2009-2015 by Christian Brabandt
                            "          The VIM LICENSE applies to EnhancedDifff.vim
                            "          (see |copyright|) except use "EnhancedDiff.vim"
                            "          instead of "Vim".
                            "          No warranty, express or implied.
                            "    *** ***   Use At-Your-Own-Risk!   *** ***
                            " GetLatestVimScripts: 5121 3 :AutoInstall: EnhancedDiff.vim
                            "
                            " Init: {{{1
    1              0.000013 let s:cpo= &cpo
    1              0.000009 if exists("g:loaded_enhanced_diff") || &cp
                                finish
                            endif
    1              0.000010 set cpo&vim
    1              0.000003 let g:loaded_enhanced_diff = 1
                            
                            " Functions {{{1
    1              0.000005 function! s:CustomDiffAlgComplete(A,L,P) "{{{2
                                return "myers\nminimal\ndefault\npatience\nhistogram"
                            endfu
    1              0.000004 function! s:CustomIgnorePat(bang, ...) "{{{2
                                if a:bang || !exists("g:enhanced_diff_ignore_pat")
                                    let g:enhanced_diff_ignore_pat=[]
                                endif
                                if a:0
                                    let pat = a:1
                                    let replace = a:0 == 2 ? a:2 : 'XXX'
                                    call add(g:enhanced_diff_ignore_pat, [pat, replace])
                                endif
                            endfu
                            " public interface {{{1
    1              0.000020 com! -nargs=1 -complete=custom,s:CustomDiffAlgComplete EnhancedDiff :let &diffexpr='EnhancedDiff#Diff("git diff", "--diff-algorithm=<args>")'|:diffupdate
    1              0.000006 com! PatienceDiff :EnhancedDiff patience
    1              0.000004 com! EnhancedDiffDisable  :set diffexpr=
                            "com! -nargs=1 -bang EnhancedDiffIgnorePat if <q-bang> | :let g:enhanced_diff_ignore_pat = [<q-args>] | else | :let g:enhanced_diff_ignore_pat=get(g:, 'enhanced_diff_ignore_pat', []) + [<q-args>] |endif
    1              0.000007 com! -nargs=* -bang EnhancedDiffIgnorePat call s:CustomIgnorePat(<q-bang>, <f-args>)
                            
                            " Restore: "{{{1
    1              0.000009 let &cpo=s:cpo
    1              0.000004 unlet s:cpo
                            " vim: ts=4 sts=4 sw=4 et fdm=marker com+=l\:\"

SCRIPT  /home/user/fbarotjr/.vim/plugged/lightline.vim/plugin/lightline.vim
Sourced 1 time
Total time:   0.000191
 Self time:   0.000191

count  total (s)   self (s)
                            " =============================================================================
                            " Filename: plugin/lightline.vim
                            " Author: itchyny
                            " License: MIT License
                            " Last Change: 2016/03/14 03:31:58.
                            " =============================================================================
                            
    1              0.000010 if exists('g:loaded_lightline') || v:version < 700
                              finish
                            endif
    1              0.000002 let g:loaded_lightline = 1
                            
    1              0.000008 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000003 augroup lightline
    1              0.000086   autocmd!
    1              0.000025   autocmd WinEnter,BufWinEnter,FileType,ColorScheme,SessionLoadPost * call lightline#update()
    1              0.000006   autocmd ColorScheme,SessionLoadPost * call lightline#highlight()
    1              0.000009   autocmd CursorMoved,BufUnload * call lightline#update_once()
    1              0.000002 augroup END
                            
    1              0.000013 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo

SCRIPT  /home/user/fbarotjr/.fzf/plugin/fzf.vim
Sourced 1 time
Total time:   0.002279
 Self time:   0.002279

count  total (s)   self (s)
                            " Copyright (c) 2017 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000006 if exists('g:loaded_fzf')
                              finish
                            endif
    1              0.000004 let g:loaded_fzf = 1
                            
    1              0.000010 let s:is_win = has('win32') || has('win64')
    1              0.000002 if s:is_win && &shellslash
                              set noshellslash
                              let s:base_dir = expand('<sfile>:h:h')
                              set shellslash
                            else
    1              0.000005   let s:base_dir = expand('<sfile>:h:h')
    1              0.000001 endif
    1              0.000001 if s:is_win
                              function! s:fzf_call(fn, ...)
                                let shellslash = &shellslash
                                try
                                  set noshellslash
                                  return call(a:fn, a:000)
                                finally
                                  let &shellslash = shellslash
                                endtry
                              endfunction
                            
                              " Use utf-8 for fzf.vim commands
                              " Return array of shell commands for cmd.exe
                              function! s:wrap_cmds(cmds)
                                return ['@echo off', 'for /f "tokens=4" %%a in (''chcp'') do set origchcp=%%a', 'chcp 65001 > nul'] +
                                      \ (type(a:cmds) == type([]) ? a:cmds : [a:cmds]) +
                                      \ ['chcp %origchcp% > nul']
                              endfunction
                            else
    1              0.000003   function! s:fzf_call(fn, ...)
                                return call(a:fn, a:000)
                              endfunction
                            
    1              0.000002   function! s:wrap_cmds(cmds)
                                return a:cmds
                              endfunction
    1              0.000001 endif
                            
    1              0.000002 function! s:shellesc_cmd(arg)
                              let escaped = substitute(a:arg, '[&|<>()@^]', '^&', 'g')
                              let escaped = substitute(escaped, '%', '%%', 'g')
                              let escaped = substitute(escaped, '"', '\\^&', 'g')
                              let escaped = substitute(escaped, '\\\+\(\\^\)', '\\\\\1', 'g')
                              return '^"'.substitute(escaped, '[^\\]\zs\\$', '\\\\', '').'^"'
                            endfunction
                            
    1              0.001250 function! fzf#shellescape(arg, ...)
                              let shell = get(a:000, 0, &shell)
                              if shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
                              endif
                              return s:fzf_call('shellescape', a:arg)
                            endfunction
                            
    1              0.000007 function! s:fzf_getcwd()
                              return s:fzf_call('getcwd')
                            endfunction
                            
    1              0.000003 function! s:fzf_fnamemodify(fname, mods)
                              return s:fzf_call('fnamemodify', a:fname, a:mods)
                            endfunction
                            
    1              0.000002 function! s:fzf_expand(fmt)
                              return s:fzf_call('expand', a:fmt, 1)
                            endfunction
                            
    1              0.000002 function! s:fzf_tempname()
                              return s:fzf_call('tempname')
                            endfunction
                            
    1              0.000008 let s:default_layout = { 'down': '~40%' }
    1              0.000004 let s:layout_keys = ['window', 'up', 'down', 'left', 'right']
    1              0.000008 let s:fzf_go = s:base_dir.'/bin/fzf'
    1              0.000003 let s:fzf_tmux = s:base_dir.'/bin/fzf-tmux'
    1              0.000002 let s:install = s:base_dir.'/install'
    1              0.000002 let s:installed = 0
                            
    1              0.000015 let s:cpo_save = &cpo
    1              0.000015 set cpo&vim
                            
    1              0.000004 function! s:fzf_exec()
                              if !exists('s:exec')
                                if executable(s:fzf_go)
                                  let s:exec = s:fzf_go
                                elseif executable('fzf')
                                  let s:exec = 'fzf'
                                elseif s:is_win && !has('win32unix')
                                  call s:warn('fzf executable not found.')
                                  call s:warn('Download fzf binary for Windows from https://github.com/junegunn/fzf-bin/releases/')
                                  call s:warn('and place it as '.s:base_dir.'\bin\fzf.exe')
                                  throw 'fzf executable not found'
                                elseif !s:installed && executable(s:install) &&
                                      \ input('fzf executable not found. Download binary? (y/n) ') =~? '^y'
                                  redraw
                                  echo
                                  call s:warn('Downloading fzf binary. Please wait ...')
                                  let s:installed = 1
                                  call system(s:install.' --bin')
                                  return s:fzf_exec()
                                else
                                  redraw
                                  throw 'fzf executable not found'
                                endif
                              endif
                              return fzf#shellescape(s:exec)
                            endfunction
                            
    1              0.000003 function! s:tmux_enabled()
                              if has('gui_running')
                                return 0
                              endif
                            
                              if exists('s:tmux')
                                return s:tmux
                              endif
                            
                              let s:tmux = 0
                              if exists('$TMUX') && executable(s:fzf_tmux)
                                let output = system('tmux -V')
                                let s:tmux = !v:shell_error && output >= 'tmux 1.7'
                              endif
                              return s:tmux
                            endfunction
                            
    1              0.000002 function! s:escape(path)
                              let path = fnameescape(a:path)
                              return s:is_win ? escape(path, '$') : path
                            endfunction
                            
                            " Upgrade legacy options
    1              0.000002 function! s:upgrade(dict)
                              let copy = copy(a:dict)
                              if has_key(copy, 'tmux')
                                let copy.down = remove(copy, 'tmux')
                              endif
                              if has_key(copy, 'tmux_height')
                                let copy.down = remove(copy, 'tmux_height')
                              endif
                              if has_key(copy, 'tmux_width')
                                let copy.right = remove(copy, 'tmux_width')
                              endif
                              return copy
                            endfunction
                            
    1              0.000001 function! s:error(msg)
                              echohl ErrorMsg
                              echom a:msg
                              echohl None
                            endfunction
                            
    1              0.000001 function! s:warn(msg)
                              echohl WarningMsg
                              echom a:msg
                              echohl None
                            endfunction
                            
    1              0.000002 function! s:has_any(dict, keys)
                              for key in a:keys
                                if has_key(a:dict, key)
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000002 function! s:open(cmd, target)
                              if stridx('edit', a:cmd) == 0 && s:fzf_fnamemodify(a:target, ':p') ==# s:fzf_expand('%:p')
                                return
                              endif
                              execute a:cmd s:escape(a:target)
                            endfunction
                            
    1              0.000004 function! s:common_sink(action, lines) abort
                              if len(a:lines) < 2
                                return
                              endif
                              let key = remove(a:lines, 0)
                              let cmd = get(a:action, key, 'e')
                              if len(a:lines) > 1
                                augroup fzf_swap
                                  autocmd SwapExists * let v:swapchoice='o'
                                        \| call s:warn('fzf: E325: swap file exists: '.s:fzf_expand('<afile>'))
                                augroup END
                              endif
                              try
                                let empty = empty(s:fzf_expand('%')) && line('$') == 1 && empty(getline(1)) && !&modified
                                let autochdir = &autochdir
                                set noautochdir
                                for item in a:lines
                                  if empty
                                    execute 'e' s:escape(item)
                                    let empty = 0
                                  else
                                    call s:open(cmd, item)
                                  endif
                                  if !has('patch-8.0.0177') && !has('nvim-0.2') && exists('#BufEnter')
                                        \ && isdirectory(item)
                                    doautocmd BufEnter
                                  endif
                                endfor
                              finally
                                let &autochdir = autochdir
                                silent! autocmd! fzf_swap
                              endtry
                            endfunction
                            
    1              0.000005 function! s:get_color(attr, ...)
                              let gui = has('termguicolors') && &termguicolors
                              let fam = gui ? 'gui' : 'cterm'
                              let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
                              for group in a:000
                                let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
                                if code =~? pat
                                  return code
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000002 function! s:defaults()
                              let rules = copy(get(g:, 'fzf_colors', {}))
                              let colors = join(map(items(filter(map(rules, 'call("s:get_color", v:val)'), '!empty(v:val)')), 'join(v:val, ":")'), ',')
                              return empty(colors) ? '' : ('--color='.colors)
                            endfunction
                            
    1              0.000002 function! s:validate_layout(layout)
                              for key in keys(a:layout)
                                if index(s:layout_keys, key) < 0
                                  throw printf('Invalid entry in g:fzf_layout: %s (allowed: %s)%s',
                                        \ key, join(s:layout_keys, ', '), key == 'options' ? '. Use $FZF_DEFAULT_OPTS.' : '')
                                endif
                              endfor
                              return a:layout
                            endfunction
                            
    1              0.000002 function! s:evaluate_opts(options)
                              return type(a:options) == type([]) ?
                                    \ join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options
                            endfunction
                            
                            " [name string,] [opts dict,] [fullscreen boolean]
    1              0.000002 function! fzf#wrap(...)
                              let args = ['', {}, 0]
                              let expects = map(copy(args), 'type(v:val)')
                              let tidx = 0
                              for arg in copy(a:000)
                                let tidx = index(expects, type(arg), tidx)
                                if tidx < 0
                                  throw 'Invalid arguments (expected: [name string] [opts dict] [fullscreen boolean])'
                                endif
                                let args[tidx] = arg
                                let tidx += 1
                                unlet arg
                              endfor
                              let [name, opts, bang] = args
                            
                              if len(name)
                                let opts.name = name
                              end
                            
                              " Layout: g:fzf_layout (and deprecated g:fzf_height)
                              if bang
                                for key in s:layout_keys
                                  if has_key(opts, key)
                                    call remove(opts, key)
                                  endif
                                endfor
                              elseif !s:has_any(opts, s:layout_keys)
                                if !exists('g:fzf_layout') && exists('g:fzf_height')
                                  let opts.down = g:fzf_height
                                else
                                  let opts = extend(opts, s:validate_layout(get(g:, 'fzf_layout', s:default_layout)))
                                endif
                              endif
                            
                              " Colors: g:fzf_colors
                              let opts.options = s:defaults() .' '. s:evaluate_opts(get(opts, 'options', ''))
                            
                              " History: g:fzf_history_dir
                              if len(name) && len(get(g:, 'fzf_history_dir', ''))
                                let dir = s:fzf_expand(g:fzf_history_dir)
                                if !isdirectory(dir)
                                  call mkdir(dir, 'p')
                                endif
                                let history = fzf#shellescape(dir.'/'.name)
                                let opts.options = join(['--history', history, opts.options])
                              endif
                            
                              " Action: g:fzf_action
                              if !s:has_any(opts, ['sink', 'sink*'])
                                let opts._action = get(g:, 'fzf_action', s:default_action)
                                let opts.options .= ' --expect='.join(keys(opts._action), ',')
                                function! opts.sink(lines) abort
                                  return s:common_sink(self._action, a:lines)
                                endfunction
                                let opts['sink*'] = remove(opts, 'sink')
                              endif
                            
                              return opts
                            endfunction
                            
    1              0.000003 function! fzf#run(...) abort
                            try
                              let oshell = &shell
                              let useshellslash = &shellslash
                            
                              if s:is_win
                                set shell=cmd.exe
                                set noshellslash
                              else
                                set shell=sh
                              endif
                            
                              if has('nvim')
                                let running = filter(range(1, bufnr('$')), "bufname(v:val) =~# ';#FZF'")
                                if len(running)
                                  call s:warn('FZF is already running (in buffer '.join(running, ', ').')!')
                                  return []
                                endif
                              endif
                              let dict   = exists('a:1') ? s:upgrade(a:1) : {}
                              let temps  = { 'result': s:fzf_tempname() }
                              let optstr = s:evaluate_opts(get(dict, 'options', ''))
                              try
                                let fzf_exec = s:fzf_exec()
                              catch
                                throw v:exception
                              endtry
                            
                              if has('nvim') && !has_key(dict, 'dir')
                                let dict.dir = s:fzf_getcwd()
                              endif
                              if has('win32unix') && has_key(dict, 'dir')
                                let dict.dir = fnamemodify(dict.dir, ':p')
                              endif
                            
                              if !has_key(dict, 'source') && !empty($FZF_DEFAULT_COMMAND) && !s:is_win
                                let temps.source = s:fzf_tempname()
                                call writefile(s:wrap_cmds(split($FZF_DEFAULT_COMMAND, "\n")), temps.source)
                                let dict.source = (empty($SHELL) ? &shell : $SHELL).' '.fzf#shellescape(temps.source)
                              endif
                            
                              if has_key(dict, 'source')
                                let source = dict.source
                                let type = type(source)
                                if type == 1
                                  let prefix = source.'|'
                                elseif type == 3
                                  let temps.input = s:fzf_tempname()
                                  call writefile(source, temps.input)
                                  let prefix = (s:is_win ? 'type ' : 'cat ').fzf#shellescape(temps.input).'|'
                                else
                                  throw 'Invalid source type'
                                endif
                              else
                                let prefix = ''
                              endif
                            
                              let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0)
                              let use_height = has_key(dict, 'down') &&
                                    \ !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right')) &&
                                    \ executable('tput') && filereadable('/dev/tty')
                              let use_term = has('nvim') && !s:is_win
                              let use_tmux = (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:tmux_enabled() && s:splittable(dict)
                              if prefer_tmux && use_tmux
                                let use_height = 0
                                let use_term = 0
                              endif
                              if use_height
                                let height = s:calc_size(&lines, dict.down, dict)
                                let optstr .= ' --height='.height
                              elseif use_term
                                let optstr .= ' --no-height'
                              endif
                              let command = prefix.(use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result
                            
                              if use_term
                                return s:execute_term(dict, command, temps)
                              endif
                            
                              let lines = use_tmux ? s:execute_tmux(dict, command, temps)
                                             \ : s:execute(dict, command, use_height, temps)
                              call s:callback(dict, lines)
                              return lines
                            finally
                              let &shell = oshell
                              let &shellslash = useshellslash
                            endtry
                            endfunction
                            
    1              0.000004 function! s:present(dict, ...)
                              for key in a:000
                                if !empty(get(a:dict, key, ''))
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000004 function! s:fzf_tmux(dict)
                              let size = ''
                              for o in ['up', 'down', 'left', 'right']
                                if s:present(a:dict, o)
                                  let spec = a:dict[o]
                                  if (o == 'up' || o == 'down') && spec[0] == '~'
                                    let size = '-'.o[0].s:calc_size(&lines, spec, a:dict)
                                  else
                                    " Legacy boolean option
                                    let size = '-'.o[0].(spec == 1 ? '' : substitute(spec, '^\~', '', ''))
                                  endif
                                  break
                                endif
                              endfor
                              return printf('LINES=%d COLUMNS=%d %s %s %s --',
                                \ &lines, &columns, fzf#shellescape(s:fzf_tmux), size, (has_key(a:dict, 'source') ? '' : '-'))
                            endfunction
                            
    1              0.000003 function! s:splittable(dict)
                              return s:present(a:dict, 'up', 'down') && &lines > 15 ||
                                    \ s:present(a:dict, 'left', 'right') && &columns > 40
                            endfunction
                            
    1              0.000002 function! s:pushd(dict)
                              if s:present(a:dict, 'dir')
                                let cwd = s:fzf_getcwd()
                                if get(a:dict, 'prev_dir', '') ==# cwd
                                  return 1
                                endif
                                let a:dict.prev_dir = cwd
                                execute 'lcd' s:escape(a:dict.dir)
                                let a:dict.dir = s:fzf_getcwd()
                                return 1
                              endif
                              return 0
                            endfunction
                            
    1              0.000003 augroup fzf_popd
    1              0.000145   autocmd!
    1              0.000014   autocmd WinEnter * call s:dopopd()
    1              0.000001 augroup END
                            
    1              0.000003 function! s:dopopd()
                              if !exists('w:fzf_prev_dir') || exists('*haslocaldir') && !haslocaldir()
                                return
                              endif
                              execute 'lcd' s:escape(w:fzf_prev_dir)
                              unlet w:fzf_prev_dir
                            endfunction
                            
    1              0.000002 function! s:xterm_launcher()
                              let fmt = 'xterm -T "[fzf]" -bg "\%s" -fg "\%s" -geometry %dx%d+%d+%d -e bash -ic %%s'
                              if has('gui_macvim')
                                let fmt .= '&& osascript -e "tell application \"MacVim\" to activate"'
                              endif
                              return printf(fmt,
                                \ synIDattr(hlID("Normal"), "bg"), synIDattr(hlID("Normal"), "fg"),
                                \ &columns, &lines/2, getwinposx(), getwinposy())
                            endfunction
    1              0.000004 unlet! s:launcher
    1              0.000010 if s:is_win || has('win32unix')
                              let s:launcher = '%s'
                            else
    1              0.000008   let s:launcher = function('s:xterm_launcher')
    1              0.000001 endif
                            
    1              0.000002 function! s:exit_handler(code, command, ...)
                              if a:code == 130
                                return 0
                              elseif a:code > 1
                                call s:error('Error running ' . a:command)
                                if !empty(a:000)
                                  sleep
                                endif
                                return 0
                              endif
                              return 1
                            endfunction
                            
    1              0.000003 function! s:execute(dict, command, use_height, temps) abort
                              call s:pushd(a:dict)
                              if has('unix') && !a:use_height
                                silent! !clear 2> /dev/null
                              endif
                              let escaped = (a:use_height || s:is_win) ? a:command : escape(substitute(a:command, '\n', '\\n', 'g'), '%#!')
                              if has('gui_running')
                                let Launcher = get(a:dict, 'launcher', get(g:, 'Fzf_launcher', get(g:, 'fzf_launcher', s:launcher)))
                                let fmt = type(Launcher) == 2 ? call(Launcher, []) : Launcher
                                if has('unix')
                                  let escaped = "'".substitute(escaped, "'", "'\"'\"'", 'g')."'"
                                endif
                                let command = printf(fmt, escaped)
                              else
                                let command = escaped
                              endif
                              if s:is_win
                                let batchfile = s:fzf_tempname().'.bat'
                                call writefile(s:wrap_cmds(command), batchfile)
                                let command = batchfile
                                let a:temps.batchfile = batchfile
                                if has('nvim')
                                  let fzf = {}
                                  let fzf.dict = a:dict
                                  let fzf.temps = a:temps
                                  function! fzf.on_exit(job_id, exit_status, event) dict
                                    if s:present(self.dict, 'dir')
                                      execute 'lcd' s:escape(self.dict.dir)
                                    endif
                                    let lines = s:collect(self.temps)
                                    call s:callback(self.dict, lines)
                                  endfunction
                                  let cmd = 'start /wait cmd /c '.command
                                  call jobstart(cmd, fzf)
                                  return []
                                endif
                              elseif has('win32unix') && $TERM !=# 'cygwin'
                                let shellscript = s:fzf_tempname()
                                call writefile([command], shellscript)
                                let command = 'cmd.exe /C '.fzf#shellescape('set "TERM=" & start /WAIT sh -c '.shellscript)
                                let a:temps.shellscript = shellscript
                              endif
                              if a:use_height
                                let stdin = has_key(a:dict, 'source') ? '' : '< /dev/tty'
                                call system(printf('tput cup %d > /dev/tty; tput cnorm > /dev/tty; %s %s 2> /dev/tty', &lines, command, stdin))
                              else
                                execute 'silent !'.command
                              endif
                              let exit_status = v:shell_error
                              redraw!
                              return s:exit_handler(exit_status, command) ? s:collect(a:temps) : []
                            endfunction
                            
    1              0.000003 function! s:execute_tmux(dict, command, temps) abort
                              let command = a:command
                              if s:pushd(a:dict)
                                " -c '#{pane_current_path}' is only available on tmux 1.9 or above
                                let command = join(['cd', fzf#shellescape(a:dict.dir), '&&', command])
                              endif
                            
                              call system(command)
                              let exit_status = v:shell_error
                              redraw!
                              return s:exit_handler(exit_status, command) ? s:collect(a:temps) : []
                            endfunction
                            
    1              0.000002 function! s:calc_size(max, val, dict)
                              let val = substitute(a:val, '^\~', '', '')
                              if val =~ '%$'
                                let size = a:max * str2nr(val[:-2]) / 100
                              else
                                let size = min([a:max, str2nr(val)])
                              endif
                            
                              let srcsz = -1
                              if type(get(a:dict, 'source', 0)) == type([])
                                let srcsz = len(a:dict.source)
                              endif
                            
                              let opts = get(a:dict, 'options', '').$FZF_DEFAULT_OPTS
                              let margin = stridx(opts, '--inline-info') > stridx(opts, '--no-inline-info') ? 1 : 2
                              let margin += stridx(opts, '--header') > stridx(opts, '--no-header')
                              return srcsz >= 0 ? min([srcsz + margin, size]) : size
                            endfunction
                            
    1              0.000002 function! s:getpos()
                              return {'tab': tabpagenr(), 'win': winnr(), 'cnt': winnr('$'), 'tcnt': tabpagenr('$')}
                            endfunction
                            
    1              0.000002 function! s:split(dict)
                              let directions = {
                              \ 'up':    ['topleft', 'resize', &lines],
                              \ 'down':  ['botright', 'resize', &lines],
                              \ 'left':  ['vertical topleft', 'vertical resize', &columns],
                              \ 'right': ['vertical botright', 'vertical resize', &columns] }
                              let ppos = s:getpos()
                              try
                                if s:present(a:dict, 'window')
                                  execute 'keepalt' a:dict.window
                                elseif !s:splittable(a:dict)
                                  execute (tabpagenr()-1).'tabnew'
                                else
                                  for [dir, triple] in items(directions)
                                    let val = get(a:dict, dir, '')
                                    if !empty(val)
                                      let [cmd, resz, max] = triple
                                      if (dir == 'up' || dir == 'down') && val[0] == '~'
                                        let sz = s:calc_size(max, val, a:dict)
                                      else
                                        let sz = s:calc_size(max, val, {})
                                      endif
                                      execute cmd sz.'new'
                                      execute resz sz
                                      return [ppos, {}]
                                    endif
                                  endfor
                                endif
                                return [ppos, { '&l:wfw': &l:wfw, '&l:wfh': &l:wfh }]
                              finally
                                setlocal winfixwidth winfixheight
                              endtry
                            endfunction
                            
    1              0.000002 function! s:execute_term(dict, command, temps) abort
                              let winrest = winrestcmd()
                              let pbuf = bufnr('')
                              let [ppos, winopts] = s:split(a:dict)
                              let b:fzf = a:dict
                              let fzf = { 'buf': bufnr(''), 'pbuf': pbuf, 'ppos': ppos, 'dict': a:dict, 'temps': a:temps,
                                        \ 'winopts': winopts, 'winrest': winrest, 'lines': &lines,
                                        \ 'columns': &columns, 'command': a:command }
                              function! fzf.switch_back(inplace)
                                if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
                                endif
                              endfunction
                              function! fzf.on_exit(id, code, _event)
                                if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
                                else
                                  if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
                                    close
                                  endif
                                  execute 'tabnext' self.ppos.tab
                                  execute self.ppos.win.'wincmd w'
                                endif
                            
                                if bufexists(self.buf)
                                  execute 'bd!' self.buf
                                endif
                            
                                if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
                                  execute self.winrest
                                endif
                            
                                if !s:exit_handler(a:code, self.command, 1)
                                  return
                                endif
                            
                                call s:pushd(self.dict)
                                let lines = s:collect(self.temps)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)
                              endfunction
                            
                              try
                                if s:present(a:dict, 'dir')
                                  execute 'lcd' s:escape(a:dict.dir)
                                endif
                                call termopen(a:command . ';#FZF', fzf)
                              finally
                                if s:present(a:dict, 'dir')
                                  lcd -
                                endif
                              endtry
                              setlocal nospell bufhidden=wipe nobuflisted
                              setf fzf
                              startinsert
                              return []
                            endfunction
                            
    1              0.000002 function! s:collect(temps) abort
                              try
                                return filereadable(a:temps.result) ? readfile(a:temps.result) : []
                              finally
                                for tf in values(a:temps)
                                  silent! call delete(tf)
                                endfor
                              endtry
                            endfunction
                            
    1              0.000004 function! s:callback(dict, lines) abort
                              " Since anything can be done in the sink function, there is no telling that
                              " the change of the working directory was made by &autochdir setting.
                              "
                              " We use the following heuristic to determine whether to restore CWD:
                              " - Always restore the current directory when &autochdir is disabled.
                              "   FIXME This makes it impossible to change directory from inside the sink
                              "   function when &autochdir is not used.
                              " - In case of an error or an interrupt, a:lines will be empty.
                              "   And it will be an array of a single empty string when fzf was finished
                              "   without a match. In these cases, we presume that the change of the
                              "   directory is not expected and should be undone.
                              let popd = has_key(a:dict, 'prev_dir') &&
                                    \ (!&autochdir || (empty(a:lines) || len(a:lines) == 1 && empty(a:lines[0])))
                              if popd
                                let w:fzf_prev_dir = a:dict.prev_dir
                              endif
                            
                              try
                                if has_key(a:dict, 'sink')
                                  for line in a:lines
                                    if type(a:dict.sink) == 2
                                      call a:dict.sink(line)
                                    else
                                      execute a:dict.sink s:escape(line)
                                    endif
                                  endfor
                                endif
                                if has_key(a:dict, 'sink*')
                                  call a:dict['sink*'](a:lines)
                                endif
                              catch
                                if stridx(v:exception, ':E325:') < 0
                                  echoerr v:exception
                                endif
                              endtry
                            
                              " We may have opened a new window or tab
                              if popd
                                let w:fzf_prev_dir = a:dict.prev_dir
                                call s:dopopd()
                              endif
                            endfunction
                            
    1              0.000007 let s:default_action = {
                              \ 'ctrl-t': 'tab split',
                              \ 'ctrl-x': 'split',
                              \ 'ctrl-v': 'vsplit' }
                            
    1              0.000002 function! s:shortpath()
                              let short = pathshorten(fnamemodify(getcwd(), ':~:.'))
                              let slash = (s:is_win && !&shellslash) ? '\' : '/'
                              return empty(short) ? '~'.slash : short . (short =~ slash.'$' ? '' : slash)
                            endfunction
                            
    1              0.000001 function! s:cmd(bang, ...) abort
                              let args = copy(a:000)
                              let opts = { 'options': ['--multi'] }
                              if len(args) && isdirectory(expand(args[-1]))
                                let opts.dir = substitute(substitute(remove(args, -1), '\\\(["'']\)', '\1', 'g'), '[/\\]*$', '/', '')
                                if s:is_win && !&shellslash
                                  let opts.dir = substitute(opts.dir, '/', '\\', 'g')
                                endif
                                let prompt = opts.dir
                              else
                                let prompt = s:shortpath()
                              endif
                              call extend(opts.options, ['--prompt', prompt])
                              call extend(opts.options, args)
                              call fzf#run(fzf#wrap('FZF', opts, a:bang))
                            endfunction
                            
    1              0.000018 command! -nargs=* -complete=dir -bang FZF call s:cmd(<bang>0, <f-args>)
                            
    1              0.000010 let &cpo = s:cpo_save
    1              0.000007 unlet s:cpo_save

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/plugin/getscriptPlugin.vim
Sourced 1 time
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
                            " ---------------------------------------------------------------------
                            " getscriptPlugin.vim
                            "  Author:	Charles E. Campbell
                            "  Date:	Nov 29, 2013
                            "  Installing:	:help glvs-install
                            "  Usage:	:help glvs
                            "
                            " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
                            "
                            " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
                            " all the peoples praise Him."
                            " ---------------------------------------------------------------------
                            " Initialization:	{{{1
                            " if you're sourcing this file, surely you can't be
                            " expecting vim to be in its vi-compatible mode
    1              0.000024 if exists("g:loaded_getscriptPlugin")
                             finish
                            endif
    1              0.000022 if &cp
                             if &verbose
                              echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
                             endif
                             finish
                            endif
    1              0.000007 let g:loaded_getscriptPlugin = "v36"
    1              0.000010 let s:keepcpo                = &cpo
    1              0.000015 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000019 com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
    1              0.000013 com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
    1              0.000011 silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
                            
                            " ---------------------------------------------------------------------
                            " Restore Options: {{{1
    1              0.000014 let &cpo= s:keepcpo
    1              0.000006 unlet s:keepcpo
                            
                            " ---------------------------------------------------------------------
                            " vim: ts=8 sts=2 fdm=marker nowrap

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/plugin/gzip.vim
Sourced 1 time
Total time:   0.000723
 Self time:   0.000723

count  total (s)   self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer: Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2016 Oct 30
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000023 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
                              finish
                            endif
    1              0.000004 let loaded_gzip = 1
                            
    1              0.000004 augroup gzip
                              " Remove all gzip autocommands
    1              0.000190   au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              " Use "gzip -d", gunzip isn't always available.
    1              0.000052   autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst setlocal bin
    1              0.000036   autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
    1              0.000032   autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
    1              0.000035   autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
    1              0.000036   autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
    1              0.000034   autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
    1              0.000033   autocmd BufReadPost,FileReadPost	*.lz  call gzip#read("lzip -d")
    1              0.000030   autocmd BufReadPost,FileReadPost	*.zst call gzip#read("zstd -d --rm")
    1              0.000015   autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
    1              0.000011   autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
    1              0.000010   autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
    1              0.000009   autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
    1              0.000022   autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
    1              0.000014   autocmd BufWritePost,FileWritePost	*.lz  call gzip#write("lzip")
    1              0.000009   autocmd BufWritePost,FileWritePost	*.zst  call gzip#write("zstd --rm")
    1              0.000006   autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
    1              0.000006   autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
    1              0.000007   autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
    1              0.000007   autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
    1              0.000006   autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
    1              0.000007   autocmd FileAppendPre			*.lz   call gzip#appre("lzip -d")
    1              0.000009   autocmd FileAppendPre			*.zst call gzip#appre("zstd -d --rm")
    1              0.000007   autocmd FileAppendPost		*.gz  call gzip#write("gzip")
    1              0.000006   autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
    1              0.000007   autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
    1              0.000006   autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
    1              0.000007   autocmd FileAppendPost		*.xz call gzip#write("xz -z")
    1              0.000006   autocmd FileAppendPost		*.lz call gzip#write("lzip")
    1              0.000007   autocmd FileAppendPost		*.zst call gzip#write("zstd --rm")
    1              0.000004 augroup END

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/plugin/logiPat.vim
Sourced 1 time
Total time:   0.000460
 Self time:   0.000460

count  total (s)   self (s)
                            " LogiPat: Boolean logical pattern matcher
                            "   Author:  Charles E. Campbell
                            "   Date:    Apr 04, 2016
                            "   Version: 4
                            "   Purpose: to do Boolean-logic based regular expression pattern matching
                            " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like most anything else that's free,
                            "               LogiPat.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            "   Usage: {{{1
                            "       :LogiPat ...
                            "
                            "         Boolean logic supported:
                            "            () grouping operators
                            "            !  not the following pattern
                            "            |  logical or
                            "            &  logical and
                            "            "..pattern.."
                            "	Example: {{{1
                            "		:LogiPat !("january"|"february")
                            "		  would match all strings not containing the strings january
                            "		  or february
                            "	GetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
                            "
                            "  Behold, you will conceive in your womb, and bring forth a son, {{{1
                            "  and will call his name Jesus. He will be great, and will be
                            "  called the Son of the Most High. The Lord God will give him the
                            "  throne of his father, David, and he will reign over the house of
                            "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
                            
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000020 if &cp || exists("loaded_logiPat")
                             finish
                            endif
    1              0.000005 let g:loaded_logiPat = "v4"
    1              0.000011 let s:keepcpo        = &cpo
    1              0.000012 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000013 com!     -nargs=* LogiPat		call   LogiPat(<q-args>,1)
    1              0.000010 sil! com -nargs=* LP			call   LogiPat(<q-args>,1)
    1              0.000008 sil! com -nargs=* LPR			call   LogiPat(<q-args>,1,"r")
    1              0.000008 com!     -nargs=+ LPE			echomsg LogiPat(<q-args>)
    1              0.000012 com!     -nargs=+ LogiPatFlags	let  s:LogiPatFlags="<args>"
    1              0.000010 sil! com -nargs=+ LPF			let  s:LogiPatFlags="<args>"
                            
                            " =====================================================================
                            " Functions: {{{1
                            
                            " ---------------------------------------------------------------------
                            " LogiPat: this function interprets the boolean-logic pattern {{{2
    1              0.000007 fun! LogiPat(pat,...)
                            "  call Dfunc("LogiPat(pat<".a:pat.">)")
                            
                              " LogiPat(pat,dosearch)
                              if a:0 > 0
                               let dosearch= a:1
                              else
                               let dosearch= 0
                              endif
                              if a:0 >= 3
                               let s:LogiPatFlags= a:3
                              endif
                            
                              let s:npatstack = 0
                              let s:nopstack  = 0
                              let s:preclvl   = 0
                              let expr        = a:pat
                            
                              " Lexer/Parser
                              while expr != ""
                            "   call Decho("expr<".expr.">")
                            
                               if expr =~ '^"'
                            	" push a Pattern; accept "" as a single " in the pattern
                                let expr = substitute(expr,'^\s*"','','')
                                let pat  = substitute(expr,'^\(\%([^"]\|\"\"\)\{-}\)"\([^"].*$\|$\)','\1','')
                            	let pat  = substitute(pat,'""','"','g')
                                let expr = substitute(expr,'^\(\%([^"]\|\"\"\)\{-}\)"\([^"].*$\|$\)','\2','')
                                let expr = substitute(expr,'^\s*','','')
                            "    call Decho("pat<".pat."> expr<".expr.">")
                            
                                call s:LP_PatPush('.*'.pat.'.*')
                            
                               elseif expr =~ '^[!()|&]'
                                " push an operator
                                let op   = strpart(expr,0,1)
                                let expr = strpart(expr,strlen(op))
                            	" allow for those who can't resist doubling their and/or operators
                            	if op =~ '[|&]' && expr[0] == op
                                 let expr = strpart(expr,strlen(op))
                            	endif
                                call s:LP_OpPush(op)
                            
                               elseif expr =~ '^\s'
                                " skip whitespace
                                let expr= strpart(expr,1)
                            
                               else
                                echoerr "operator<".strpart(expr,0,1)."> not supported (yet)"
                                let expr= strpart(expr,1)
                               endif
                            
                              endwhile
                            
                              " Final Execution
                              call s:LP_OpPush('Z')
                            
                              let result= s:LP_PatPop(1)
                            "  call Decho("result=".result)
                            
                              " sanity checks and cleanup
                              if s:npatstack > 0
                               echoerr s:npatstack." patterns left on stack!"
                               let s:npatstack= 0
                              endif
                              if s:nopstack > 0
                               echoerr s:nopstack." operators left on stack!"
                               let s:nopstack= 0
                              endif
                            
                              " perform the indicated search
                              if dosearch
                               if exists("s:LogiPatFlags") && s:LogiPatFlags != ""
                            "  call Decho("search(result<".result."> LogiPatFlags<".s:LogiPatFlags.">)")
                                call search(result,s:LogiPatFlags)
                               else
                            "  call Decho("search(result<".result.">)")
                                call search(result)
                               endif
                               let @/= result
                              endif
                            
                            "  call Dret("LogiPat ".result)
                              return result
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:String: Vim6.4 doesn't have string() {{{2
    1              0.000008 func! s:String(str)
                              return "'".escape(a:str, '"')."'"
                            endfunc
                            
                            " ---------------------------------------------------------------------
                            " LP_PatPush: {{{2
    1              0.000003 fun! s:LP_PatPush(pat)
                            "  call Dfunc("LP_PatPush(pat<".a:pat.">)")
                              let s:npatstack              = s:npatstack + 1
                              let s:patstack_{s:npatstack} = a:pat
                            "  call s:StackLook("patpush") "Decho
                            "  call Dret("LP_PatPush : npatstack=".s:npatstack)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
    1              0.000003 fun! s:LP_PatPop(lookup)
                            "  call Dfunc("LP_PatPop(lookup=".a:lookup.")")
                              if s:npatstack > 0
                               let ret         = s:patstack_{s:npatstack}
                               let s:npatstack = s:npatstack - 1
                              else
                               let ret= "---error---"
                               echoerr "(LogiPat) invalid expression"
                              endif
                            "  call s:StackLook("patpop") "Decho
                            "  call Dret("LP_PatPop ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_OpPush: {{{2
    1              0.000004 fun! s:LP_OpPush(op)
                            "  call Dfunc("LP_OpPush(op<".a:op.">)")
                            
                              " determine new operator's precedence level
                              if a:op == '('
                              	let s:preclvl= s:preclvl + 10
                            	let preclvl  = s:preclvl
                              elseif a:op == ')'
                              	let s:preclvl= s:preclvl - 10
                               if s:preclvl < 0
                                let s:preclvl= 0
                                echoerr "too many )s"
                               endif
                               let preclvl= s:preclvl
                              elseif a:op =~ '|'
                               let preclvl= s:preclvl + 2
                              elseif a:op =~ '&'
                               let preclvl= s:preclvl + 4
                              elseif a:op == '!'
                               let preclvl= s:preclvl + 6
                              elseif a:op == 'Z'
                               let preclvl= -1
                              else
                               echoerr "expr<".expr."> not supported (yet)"
                               let preclvl= s:preclvl
                              endif
                            "  call Decho("new operator<".a:op."> preclvl=".preclvl)
                            
                              " execute higher-precdence operators
                            "  call Decho("execute higher-precedence operators")
                              call s:LP_Execute(preclvl)
                            
                              " push new operator onto operator-stack
                            "  call Decho("push new operator<".a:op."> onto stack with preclvl=".preclvl." at nopstack=".(s:nopstack+1))
                              if a:op =~ '!'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              elseif a:op =~ '|'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              elseif a:op == '&'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              endif
                            
                            "  call s:StackLook("oppush") "Decho
                            "  call Dret("LP_OpPush : s:preclvl=".s:preclvl)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_Execute: execute operators from opstack using pattern stack {{{2
    1              0.000004 fun! s:LP_Execute(preclvl)
                            "  call Dfunc("LP_Execute(preclvl=".a:preclvl.") npatstack=".s:npatstack." nopstack=".s:nopstack)
                            
                              " execute all higher precedence operators
                              while s:nopstack > 0 && a:preclvl < s:opprec_{s:nopstack}
                               let op= s:opstack_{s:nopstack}
                            "   call Decho("op<".op."> nop=".s:nopstack." [preclvl=".a:preclvl."] < [opprec_".s:nopstack."=".s:opprec_{s:nopstack}."]")
                            
                               let s:nopstack = s:nopstack - 1
                             
                               if     op == '!'
                                let n1= s:LP_PatPop(1)
                            	call s:LP_PatPush(s:LP_Not(n1))
                             
                               elseif op == '|'
                                let n1= s:LP_PatPop(1)
                                let n2= s:LP_PatPop(1)
                                call s:LP_PatPush(s:LP_Or(n2,n1))
                             
                               elseif op =~ '&'
                                let n1= s:LP_PatPop(1)
                                let n2= s:LP_PatPop(1)
                                call s:LP_PatPush(s:LP_And(n2,n1))
                               endif
                             
                            "   call s:StackLook("execute") "Decho
                              endwhile
                            
                            "  call Dret("LP_Execute")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_Not: writes a logical-not for a pattern {{{2
    1              0.000004 fun! s:LP_Not(pat)
                            "  call Dfunc("LP_Not(pat<".a:pat.">)")
                              if a:pat =~ '^\.\*' && a:pat =~ '\.\*$'
                               let pat= substitute(a:pat,'^\.\*\(.*\)\.\*$','\1','')
                               let ret= '^\%(\%('.pat.'\)\@!.\)*$'
                              else
                               let ret= '^\%(\%('.a:pat.'\)\@!.\)*$'
                              endif
                            "  call Dret("LP_Not ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_Or: writes a logical-or branch using two patterns {{{2
    1              0.000003 fun! s:LP_Or(pat1,pat2)
                            "  call Dfunc("LP_Or(pat1<".a:pat1."> pat2<".a:pat2.">)")
                              let ret= '\%('.a:pat1.'\|'.a:pat2.'\)'
                            "  call Dret("LP_Or ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_And: writes a logical-and concat using two patterns {{{2
    1              0.000016 fun! s:LP_And(pat1,pat2)
                            "  call Dfunc("LP_And(pat1<".a:pat1."> pat2<".a:pat2.">)")
                              let ret= '\%('.a:pat1.'\&'.a:pat2.'\)'
                            "  call Dret("LP_And ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " StackLook: {{{2
    1              0.000005 fun! s:StackLook(description)
                            "  call Dfunc("StackLook(description<".a:description.">)")
                              let iop = 1
                              let ifp = 1
                            "  call Decho("Pattern                       Operator")
                            
                              " print both pattern and operator
                              while ifp <= s:npatstack && iop <= s:nopstack
                               let fp = s:patstack_{ifp}
                               let op = s:opstack_{iop}." (P".s:opprec_{s:nopstack}.')'
                               let fplen= strlen(fp)
                               if fplen < 30
                               	let fp= fp.strpart("                              ",1,30-fplen)
                               endif
                            "   call Decho(fp.op)
                               let ifp = ifp + 1
                               let iop = iop + 1
                              endwhile
                            
                              " print just pattern
                              while ifp <= s:npatstack
                               let fp  = s:patstack_{ifp}
                            "   call Decho(fp)
                               let ifp = ifp + 1
                              endwhile
                            
                              " print just operator
                              while iop <= s:nopstack
                               let op  = s:opstack_{iop}." (P".s:opprec_{s:nopstack}.')'
                            "   call Decho("                              ".op)
                               let iop = iop + 1
                              endwhile
                            "  call Dret("StackLook")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  Cleanup And Modeline: {{{1
    1              0.000011 let &cpo= s:keepcpo
    1              0.000003 unlet s:keepcpo
                            " vim: ts=4 fdm=marker

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/plugin/manpager.vim
Sourced 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
                            " Vim plugin for using Vim as manpager.
                            " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>
                            " Last Change: 2016 May 20
                            
                            " $MAN_PN is supposed to be set by MANPAGER, see ":help manpager.vim".
    1              0.000009 if empty($MAN_PN)
    1              0.000003   finish

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000241
 Self time:   0.000241

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2016 Feb 16
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
                            " - the "CursorMoved" autocmd event is not available.
    1              0.000019 if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
                              finish
                            endif
    1              0.000003 let g:loaded_matchparen = 1
                            
    1              0.000003 if !exists("g:matchparen_timeout")
    1              0.000002   let g:matchparen_timeout = 300
    1              0.000001 endif
    1              0.000003 if !exists("g:matchparen_insert_timeout")
    1              0.000002   let g:matchparen_insert_timeout = 60
    1              0.000001 endif
                            
    1              0.000002 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000013   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
    1              0.000004   if exists('##TextChanged')
    1              0.000008     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
    1              0.000001   endif
    1              0.000001 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000010 if exists("*s:Highlight_Matching_Pair")
                              finish
                            endif
                            
    1              0.000007 let s:cpo_save = &cpo
    1              0.000010 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000003 function! s:Highlight_Matching_Pair()
                              " Remove any previous match.
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let text = getline(c_lnum)
                              let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
                              if empty(matches)
                                let [c_before, c] = ['', '']
                              else
                                let [c_before, c] = matches[1:2]
                              endif
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' .
                            	\ '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
                            	    \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000015 command! NoMatchParen windo silent! call matchdelete(3) | unlet! g:loaded_matchparen |
                            	  \ au! matchparen
    1              0.000009 command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved
                            
    1              0.000012 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.000771
 Self time:   0.000771

count  total (s)   self (s)
                            " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
                            "            PLUGIN SECTION
                            " Date:		Feb 08, 2016
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and comes with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000015 if &cp || exists("g:loaded_netrwPlugin")
                             finish
                            endif
    1              0.000003 let g:loaded_netrwPlugin = "v156"
    1              0.000006 let s:keepcpo = &cpo
    1              0.000011 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            
                            " Local Browsing Autocmds: {{{2
    1              0.000002 augroup FileExplorer
    1              0.000120  au!
    1              0.000008  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
    1              0.000004  au BufEnter *	sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000005  au VimEnter *	sil call s:VimEnter(expand("<amatch>"))
    1              0.000015  if has("win32") || has("win95") || has("win64") || has("win16")
                              au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
                             endif
    1              0.000001 augroup END
                            
                            " Network Browsing Reading Writing: {{{2
    1              0.000001 augroup Network
    1              0.000040  au!
    1              0.000007  au BufReadCmd   file://*											call netrw#FileUrlRead(expand("<amatch>"))
    1              0.000024  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
    1              0.000022  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
    1              0.000020  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
    1              0.000030  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
    1              0.000003  try                                                       
    1              0.000025   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
    1              0.000004  catch /^Vim\%((\a\+)\)\=:E216/                            
                              au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             endtry
    1              0.000001 augroup END
                            
                            " Commands: :Nread, :Nwrite, :NetUserPass {{{2
    1              0.000020 com! -count=1 -nargs=*	Nread		let s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
    1              0.000018 com! -range=% -nargs=*	Nwrite		let s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000005 com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
    1              0.000014 com! -nargs=*	        Nsource		let s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000006 com! -nargs=?		Ntree		call netrw#SetTreetop(<q-args>)
                            
                            " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
    1              0.000013 com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
    1              0.000012 com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
    1              0.000011 com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
    1              0.000010 com! -nargs=* -bar -bang -count=0 -complete=dir	Vexplore	call netrw#Explore(<count>,1,4+<bang>0,<q-args>)
    1              0.000010 com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
    1              0.000007 com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
    1              0.000007 com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
    1              0.000011 com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore	call netrw#Lexplore(<count>,<bang>0,<q-args>)
                            
                            " Commands: NetrwSettings {{{2
    1              0.000006 com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
    1              0.000007 com! -bang	NetrwClean	call netrw#Clean(<bang>0)
                            
                            " Maps:
    1              0.000004 if !exists("g:netrw_nogx")
    1              0.000014  if maparg('gx','n') == ""
    1              0.000011   if !hasmapto('<Plug>NetrwBrowseX')
    1              0.000010    nmap <unique> gx <Plug>NetrwBrowseX
    1              0.000001   endif
    1              0.000021   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>
    1              0.000001  endif
    1              0.000005  if maparg('gx','v') == ""
    1              0.000009   if !hasmapto('<Plug>NetrwBrowseXVis')
    1              0.000007    vmap <unique> gx <Plug>NetrwBrowseXVis
    1              0.000000   endif
    1              0.000011   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
    1              0.000001  endif
    1              0.000001 endif
    1              0.000003 if exists("g:netrw_usetab") && g:netrw_usetab
                             if maparg('<c-tab>','n') == ""
                              nmap <unique> <c-tab> <Plug>NetrwShrink
                             endif
                             nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
                            endif
                            
                            " ---------------------------------------------------------------------
                            " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
    1              0.000004 fun! s:LocalBrowse(dirname)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
                              if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
                            "             Its purpose: to look over all windows and run s:LocalBrowse() on
                            "             them, which checks if they're directories and will create a directory
                            "             listing when appropriate.
                            "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
                            "             has already been called.
    1              0.000003 fun! s:VimEnter(dirname)
                            "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
                              let curwin       = winnr()
                              let s:vimentered = 1
                              windo call s:LocalBrowse(expand("%:p"))
                              exe curwin."wincmd w"
                            "  call Dret("s:VimEnter")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{1
    1              0.000001 fun! NetrwStatusLine()
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{1
                            "   Usage:  :call NetUserPass()			-- will prompt for userid and password
                            "	    :call NetUserPass("uid")		-- will prompt for password
                            "	    :call NetUserPass("uid","password") -- sets global userid and password
    1              0.000001 fun! NetUserPass(...)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " Modelines And Restoration: {{{1
    1              0.000013 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo
                            " vim:ts=8 fdm=marker

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/plugin/rrhelper.vim
Sourced 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
                            " Vim plugin with helper function(s) for --remote-wait
                            " Maintainer: Flemming Madsen <fma@cci.dk>
                            " Last Change: 2008 May 29
                            
                            " Has this already been loaded?
    1              0.000008 if exists("loaded_rrhelper") || !has("clientserver")
                              finish
                            endif
    1              0.000002 let loaded_rrhelper = 1
                            
                            " Setup answers for a --remote-wait client who will assume
                            " a SetupRemoteReplies() function in the command server
                            
    1              0.000002 function SetupRemoteReplies()
                              let cnt = 0
                              let max = argc()
                            
                              let id = expand("<client>")
                              if id == 0
                                return
                              endif
                              while cnt < max
                                " Handle same file from more clients and file being more than once
                                " on the command line by encoding this stuff in the group name
                                let uniqueGroup = "RemoteReply_".id."_".cnt
                            
                                " Path separators are always forward slashes for the autocommand pattern.
                                " Escape special characters with a backslash.
                                let f = substitute(argv(cnt), '\\', '/', "g")
                                if exists('*fnameescape')
                                  let f = fnameescape(f)
                                else
                                  let f = escape(f, " \t\n*?[{`$\\%#'\"|!<")
                                endif
                                execute "augroup ".uniqueGroup
                                execute "autocmd ".uniqueGroup." BufUnload ". f ."  call DoRemoteReply('".id."', '".cnt."', '".uniqueGroup."', '". f ."')"
                                let cnt = cnt + 1
                              endwhile
                              augroup END
                            endfunc
                            
    1              0.000003 function DoRemoteReply(id, cnt, group, file)
                              call server2client(a:id, a:cnt)
                              execute 'autocmd! '.a:group.' BufUnload '.a:file
                              execute 'augroup! '.a:group
                            endfunc
                            
                            " vim: set sw=2 sts=2 :

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
                            " Vim plugin for downloading spell files
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2006 Feb 01
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of spell files
    1              0.000018 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
                              finish
                            endif
    1              0.000003 let loaded_spellfile_plugin = 1
                            
                            " The function is in the autoload directory.
    1              0.000008 autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000015 if &cp || exists("g:loaded_tarPlugin")
                             finish
                            endif
    1              0.000002 let g:loaded_tarPlugin = "v29"
    1              0.000006 let s:keepcpo          = &cpo
    1              0.000008 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000002 augroup tar
    1              0.000048   au!
    1              0.000007   au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
    1              0.000006   au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
    1              0.000004   au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
    1              0.000004   au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
    1              0.000004   if has("unix")
    1              0.000005    au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
    1              0.000005    au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
    1              0.000005    au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000005    au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000001   endif
                            
    1              0.000005   au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tbz			call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tar.lzma	call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
    1              0.000001 augroup END
    1              0.000008 com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000009 let &cpo= s:keepcpo
    1              0.000004 unlet s:keepcpo

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/plugin/tohtml.vim
Sourced 1 time
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
                            " Vim plugin for converting a syntax highlighted file to HTML.
                            " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
                            " Last Change: 2015 Sep 08
                            "
                            " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
                            " $VIMRUNTIME/syntax/2html.vim
                            "
                            " TODO: {{{
                            "   * Options for generating the CSS in external style sheets. New :TOcss
                            "     command to convert the current color scheme into a (mostly) generic CSS
                            "     stylesheet which can be re-used. Alternate stylesheet support? Good start
                            "     by Erik Falor
                            "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
                            "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
                            "     term) to use for the styling. Suggestion by "nacitar".
                            "   * Add way to override or specify which RGB colors map to the color numbers
                            "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
                            "   * Disable filetype detection until after all processing is done.
                            "   * Add option for not generating the hyperlink on stuff that looks like a
                            "     URL? Or just color the link to fit with the colorscheme (and only special
                            "     when hovering)?
                            "   * Bug: Opera does not allow printing more than one page if uncopyable
                            "     regions is turned on. Possible solution: Add normal text line numbers with
                            "     display:none, set to display:inline for print style sheets, and hide
                            "     <input> elements for print, to allow Opera printing multiple pages (and
                            "     other uncopyable areas?). May need to make the new text invisible to IE
                            "     with conditional comments to prevent copying it, IE for some reason likes
                            "     to copy hidden text. Other browsers too?
                            "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
                            "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
                            "     on Windows). Perhaps it is font related?
                            "   * Bug: still some gaps in the fold column when html_prevent_copy contains
                            "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
                            "     on diff lines though.
                            "   * Undercurl support via CSS3, with fallback to dotted or something:
                            "	https://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
                            "   * Redo updates for modified default foldtext (v11) when/if the patch is
                            "     accepted to modify it.
                            "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
                            "		+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
                            "		+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
                            "     does not show the whole diff filler as it is supposed to?
                            "   * Bug: when 'isprint' is wrong for the current encoding, will generate
                            "     invalid content. Can/should anything be done about this? Maybe a separate
                            "     plugin to correct 'isprint' based on encoding?
                            "   * Check to see if the windows-125\d encodings actually work in Unix without
                            "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
                            "   * Font auto-detection similar to
                            "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
                            "     platforms.
                            "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.
                            "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
                            "	- listchars support
                            "	- full-line background highlight
                            "	- other?
                            "   * Make it so deleted lines in a diff don't create side-scrolling (get it
                            "     free with full-line background highlight above).
                            "   * Restore open/closed folds and cursor position after processing each file
                            "     with option not to restore for speed increase.
                            "   * Add extra meta info (generation time, etc.)?
                            "   * Tidy up so we can use strict doctype in even more situations
                            "   * Implementation detail: add threshold for writing the lines to the html
                            "     buffer before we're done (5000 or so lines should do it)
                            "   * TODO comments for code cleanup scattered throughout
                            "}}}
                            
    1              0.000006 if exists('g:loaded_2html_plugin')
                              finish
                            endif
    1              0.000002 let g:loaded_2html_plugin = 'vim7.4_v2'
                            
                            "
                            " Changelog: {{{
                            "   7.4_v2  (this version): Fix error raised when converting a diff containing
                            "                           an empty buffer. Jan Stocker: allow g:html_font to
                            "                           take a list so it is easier to specfiy fallback
                            "                           fonts in the generated CSS.
                            "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
                            "			    also for version-specific modelines like "vim>703:".
                            "
                            "   7.3 updates: {{{
                            "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
                            "			    g:html_line_ids=0. Allow customizing
                            "			    important IDs (like line IDs and fold IDs) using
                            "			    g:html_id_expr evalutated when the buffer conversion
                            "			    is started.
                            "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
                            "			    insert modeline to set it to manual.
                            "			    Fix bug: diff mode with 2 unsaved buffers creates a
                            "			    duplicate of one buffer instead of including both.
                            "			    Add anchors to each line so you can put '#L123'
                            "			    or '#123' at the end of the URL to jump to line 123
                            "			    (idea by Andy Spencer). Add javascript to open folds
                            "			    to show the anchor being jumped to if it is hidden.
                            "			    Fix XML validation error: &nsbp; not part of XML.
                            "			    Allow TOhtml to chain together with other commands
                            "			    using |.
                            "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
                            "			    highlight groups make up the start-of-modeline text.
                            "			    Improve render time of page with uncopyable regions
                            "			    by not using one-input-per-char. Change name of
                            "			    uncopyable option from html_unselectable to
                            "			    html_prevent_copy. Added html_no_invalid option and
                            "			    default to inserting invalid markup for uncopyable
                            "			    regions to prevent MS Word from pasting undeletable
                            "			    <input> elements. Fix 'cpo' handling (Thilo Six).
                            "		 7.3_v12b1: Add html_unselectable option. Rework logic to
                            "			    eliminate post-processing substitute commands in
                            "			    favor of doing the work up front. Remove unnecessary
                            "			    special treatment of 'LineNr' highlight group. Minor
                            "			    speed improvements. Fix modeline mangling in
                            "			    generated output so it works for text in the first
                            "			    column. Fix missing line number and fold column in
                            "			    diff filler lines. Fix that some fonts have a 1px
                            "			    gap (using a dirty hack, improvements welcome). Add
                            "			    "colorscheme" meta tag. Does NOT include support for
                            "			    the new default foldtext added in v11, as the patch
                            "			    adding it has not yet been included in Vim.
                            "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
                            "			    Brabandt in
                            "			    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
                            "			    This patch has not yet been included in Vim, thus
                            "			    these changes are removed in the next version.
                            "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
                            "			    multiple nested folds with dynamic folding on.
                            "			    Also fix problem with foldtext in this situation.
                            "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
                            "			    and without html_no_pre, default value same as
                            "			    'wrap' option, (Andy Spencer). Don't use
                            "			    'fileencoding' for converted document encoding if
                            "			    'buftype' indicates a special buffer which isn't
                            "			    written.
                            "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
                            "			    characters in generated output (Andy Spencer).
                            "			    Escape text that looks like a modeline so Vim
                            "			    doesn't use anything in the converted HTML as a
                            "			    modeline. Bugfixes: Fix folding when a fold starts
                            "			    before the conversion range. Remove fold column when
                            "			    there are no folds.
                            "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
                            "		  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
                            "		  7.3_v7b2: Remove automatic detection of encodings that are not
                            "			    supported by all major browsers according to
                            "			    http://wiki.whatwg.org/wiki/Web_Encodings and
                            "			    convert to UTF-8 for all Unicode encodings. Make
                            "			    HTML encoding to Vim encoding detection be
                            "			    case-insensitive for built-in pairs.
                            "		  7.3_v7b1: Remove use of setwinvar() function which cannot be
                            "			    called in restricted mode (Andy Spencer). Use
                            "			    'fencoding' instead of 'encoding' to determine by
                            "			    charset, and make sure the 'fenc' of the generated
                            "			    file matches its indicated charset. Add charsets for
                            "			    all of Vim's natively supported encodings.
                            "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
                            "			    user settings interfering with diff mode generation,
                            "			    trailing whitespace (e.g. line number column) when
                            "			    using html_no_pre, and bugs when using
                            "			    html_hover_unfold.
                            "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
                            "			    folds in diff mode when first line was folded.
                            "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
                            "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
                            "			    default to true when not set to anything. Use strict
                            "			    doctypes where possible. Rename use_xhtml option to
                            "			    html_use_xhtml for consistency. Use .xhtml extension
                            "			    when using this option. Add meta tag for settings.
                            "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
                            "			    diff colors and the normal syntax colors
                            "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
                            "}}}
                            "}}}
                            
                            " Define the :TOhtml command when:
                            " - 'compatible' is not set
                            " - this plugin was not already loaded
                            " - user commands are available. {{{
    1              0.000015 if !&cp && !exists(":TOhtml") && has("user_commands")
    1              0.000012   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
    1              0.000001 endif "}}}
                            
                            " Make sure any patches will probably use consistent indent
                            "   vim: ts=8 sw=2 sts=2 noet fdm=marker

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/plugin/vimballPlugin.vim
Sourced 1 time
Total time:   0.000235
 Self time:   0.000235

count  total (s)   self (s)
                            " vimballPlugin : construct a file containing both paths and files
                            " Author: Charles E. Campbell
                            " Copyright: (c) 2004-2014 by Charles E. Campbell
                            "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
                            "            (see |copyright|) except use "Vimball" instead of "Vim".
                            "            No warranty, express or implied.
                            "  *** ***   Use At-Your-Own-Risk!   *** ***
                            "
                            " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
                            "      judge. For in that which you judge another, you condemn yourself. For
                            "      you who judge practice the same things.
                            " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
                            
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000013 if &cp || exists("g:loaded_vimballPlugin")
                             finish
                            endif
    1              0.000002 let g:loaded_vimballPlugin = "v37"
    1              0.000006 let s:keepcpo              = &cpo
    1              0.000007 set cpo&vim
                            
                            " ------------------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000018 com! -range   -complete=file -nargs=+ -bang MkVimball		call vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
    1              0.000007 com! -nargs=? -complete=dir  UseVimball						call vimball#Vimball(1,<f-args>)
    1              0.000005 com! -nargs=0                VimballList					call vimball#Vimball(0)
    1              0.000015 com! -nargs=* -complete=dir  RmVimball						call vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
    1              0.000001 augroup Vimball
    1              0.000058  au!
    1              0.000016  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz	setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
    1              0.000013  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz			let s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
    1              0.000007  au SourceCmd *.vba											if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
    1              0.000013  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz	setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
    1              0.000012  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz			let s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
    1              0.000010  au SourceCmd *.vmb											if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
    1              0.000001 augroup END
                            
                            " =====================================================================
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000010 let &cpo= s:keepcpo
    1              0.000004 unlet s:keepcpo

SCRIPT  /home/user/fbarotjr/.local/share/vim/vim80/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000234
 Self time:   0.000234

count  total (s)   self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Sep 13, 2016
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000012 if &cp || exists("g:loaded_zipPlugin")
                             finish
                            endif
    1              0.000002 let g:loaded_zipPlugin = "v28"
    1              0.000007 let s:keepcpo          = &cpo
    1              0.000007 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Options: {{{1
    1              0.000004 if !exists("g:zipPlugin_ext")
    1              0.000006  let g:zipPlugin_ext='*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000002 augroup zip
    1              0.000047  au!
    1              0.000006  au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
    1              0.000005  au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
    1              0.000004  au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
    1              0.000005  au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
    1              0.000004  if has("unix")
    1              0.000005   au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
    1              0.000005   au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
    1              0.000004   au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000006   au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000001  endif
                            
    1              0.000068  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
    1              0.000001 augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
    1              0.000009 let &cpo= s:keepcpo
    1              0.000004 unlet s:keepcpo

SCRIPT  /home/user/fbarotjr/.vim/plugged/lightline.vim/autoload/lightline.vim
Sourced 1 time
Total time:   0.000487
 Self time:   0.000487

count  total (s)   self (s)
                            " =============================================================================
                            " Filename: autoload/lightline.vim
                            " Author: itchyny
                            " License: MIT License
                            " Last Change: 2016/12/03 12:08:08.
                            " =============================================================================
                            
    1              0.000012 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000003 let s:_ = 1
                            
    1              0.000004 function! lightline#update() abort
                              if s:_
                                call lightline#init()
                                call lightline#colorscheme()
                              endif
                              if !s:lightline.enable.statusline
                                return
                              endif
                              let w = winnr()
                              let s = winnr('$') == 1 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
                              for n in range(1, winnr('$'))
                                call setwinvar(n, '&statusline', s[n!=w])
                                call setwinvar(n, 'lightline', n!=w)
                              endfor
                            endfunction
                            
    1              0.000003 function! lightline#update_once() abort
                              if !exists('w:lightline') || w:lightline
                                call lightline#update()
                              endif
                            endfunction
                            
    1              0.000003 function! lightline#update_disable() abort
                              if !s:lightline.enable.statusline
                                return
                              endif
                              call setwinvar(0, '&statusline', '')
                            endfunction
                            
    1              0.000002 function! lightline#enable() abort
                              call lightline#colorscheme()
                              call lightline#update()
                              if s:lightline.enable.tabline
                                set tabline=%!lightline#tabline()
                              endif
                              augroup lightline
                                autocmd!
                                autocmd WinEnter,BufWinEnter,FileType,ColorScheme,SessionLoadPost * call lightline#update()
                                autocmd ColorScheme,SessionLoadPost * call lightline#highlight()
                                autocmd CursorMoved,BufUnload * call lightline#update_once()
                              augroup END
                              augroup lightline-disable
                                autocmd!
                              augroup END
                              augroup! lightline-disable
                            endfunction
                            
    1              0.000002 function! lightline#disable() abort
                              let [&statusline, &tabline] = [get(s:, '_statusline', ''), get(s:, '_tabline', '')]
                              for t in range(1, tabpagenr('$'))
                                for n in range(1, tabpagewinnr(t, '$'))
                                  call settabwinvar(t, n, '&statusline', '')
                                endfor
                              endfor
                              augroup lightline
                                autocmd!
                              augroup END
                              augroup! lightline
                              augroup lightline-disable
                                autocmd!
                                autocmd WinEnter * call lightline#update_disable()
                              augroup END
                            endfunction
                            
    1              0.000002 function! lightline#toggle() abort
                              if exists('#lightline')
                                call lightline#disable()
                              else
                                call lightline#enable()
                              endif
                            endfunction
                            
    1              0.000081 let s:_lightline = {
                                  \   'active': {
                                  \     'left': [ [ 'mode', 'paste' ], [ 'readonly', 'filename', 'modified' ] ],
                                  \     'right': [ [ 'lineinfo' ], [ 'percent' ], [ 'fileformat', 'fileencoding', 'filetype' ] ]
                                  \   },
                                  \   'inactive': {
                                  \     'left': [ [ 'filename' ] ],
                                  \     'right': [ [ 'lineinfo' ], [ 'percent' ] ]
                                  \   },
                                  \   'tabline': {
                                  \     'left': [ [ 'tabs' ] ],
                                  \     'right': [ [ 'close' ] ]
                                  \   },
                                  \   'tab': {
                                  \     'active': [ 'tabnum', 'filename', 'modified' ],
                                  \     'inactive': [ 'tabnum', 'filename', 'modified' ]
                                  \   },
                                  \   'component': {
                                  \     'mode': '%{lightline#mode()}',
                                  \     'absolutepath': '%F', 'relativepath': '%f', 'filename': '%t', 'modified': '%M', 'bufnum': '%n',
                                  \     'paste': '%{&paste?"PASTE":""}', 'readonly': '%R', 'charvalue': '%b', 'charvaluehex': '%B',
                                  \     'spell': '%{&spell?&spelllang:""}', 'fileencoding': '%{&fenc!=#""?&fenc:&enc}', 'fileformat': '%{&ff}',
                                  \     'filetype': '%{&ft!=#""?&ft:"no ft"}', 'percent': '%3p%%', 'percentwin': '%P',
                                  \     'lineinfo': '%3l:%-2v', 'line': '%l', 'column': '%c', 'close': '%999X X '
                                  \   },
                                  \   'component_visible_condition': {
                                  \     'modified': '&modified||!&modifiable', 'readonly': '&readonly', 'paste': '&paste', 'spell': '&spell'
                                  \   },
                                  \   'component_function': {},
                                  \   'component_function_visible_condition': {},
                                  \   'component_expand': {
                                  \     'tabs': 'lightline#tabs'
                                  \   },
                                  \   'component_type': {
                                  \     'tabs': 'tabsel', 'close': 'raw'
                                  \   },
                                  \   'tab_component': {},
                                  \   'tab_component_function': {
                                  \     'filename': 'lightline#tab#filename', 'modified': 'lightline#tab#modified',
                                  \     'readonly': 'lightline#tab#readonly', 'tabnum': 'lightline#tab#tabnum'
                                  \   },
                                  \   'colorscheme': 'default',
                                  \   'mode_map': {
                                  \     'n': 'NORMAL', 'i': 'INSERT', 'R': 'REPLACE', 'v': 'VISUAL', 'V': 'V-LINE', "\<C-v>": 'V-BLOCK',
                                  \     'c': 'COMMAND', 's': 'SELECT', 'S': 'S-LINE', "\<C-s>": 'S-BLOCK', 't': 'TERMINAL'
                                  \   },
                                  \   'separator': { 'left': '', 'right': '' },
                                  \   'subseparator': { 'left': '|', 'right': '|' },
                                  \   'tabline_separator': {},
                                  \   'tabline_subseparator': {},
                                  \   'enable': { 'statusline': 1, 'tabline': 1 },
                                  \   '_mode_': {
                                  \     'n': 'normal', 'i': 'insert', 'R': 'replace', 'v': 'visual', 'V': 'visual', "\<C-v>": 'visual',
                                  \     'c': 'command', 's': 'select', 'S': 'select', "\<C-s>": 'select', 't': 'terminal'
                                  \   },
                                  \   'mode_fallback': { 'replace': 'insert', 'terminal': 'insert', 'select': 'visual' },
                                  \   'palette': {},
                                  \   'winwidth': winwidth(0),
                                  \ }
    1              0.000003 function! lightline#init() abort
                              let s:lightline = deepcopy(get(g:, 'lightline', {}))
                              for [key, value] in items(s:_lightline)
                                if type(value) == 4
                                  if !has_key(s:lightline, key)
                                    let s:lightline[key] = {}
                                  endif
                                  call extend(s:lightline[key], value, 'keep')
                                elseif !has_key(s:lightline, key)
                                  let s:lightline[key] = value
                                endif
                                unlet value
                              endfor
                              call extend(s:lightline.tabline_separator, s:lightline.separator, 'keep')
                              call extend(s:lightline.tabline_subseparator, s:lightline.subseparator, 'keep')
                              let s:lightline.tabline_configured = has_key(get(get(g:, 'lightline', {}), 'component_expand', {}), 'tabs')
                              for components in deepcopy(s:lightline.tabline.left + s:lightline.tabline.right)
                                if len(filter(components, 'v:val !=# "tabs" && v:val !=# "close"')) > 0
                                  let s:lightline.tabline_configured = 1
                                  break
                                endif
                              endfor
                              if !exists('s:_statusline')
                                let s:_statusline = &statusline
                              endif
                              if !exists('s:_tabline')
                                let s:_tabline = &tabline
                              endif
                              if s:lightline.enable.tabline
                                set tabline=%!lightline#tabline()
                              else
                                let &tabline = get(s:, '_tabline', '')
                              endif
                              for f in values(s:lightline.component_function)
                                silent! call call(f, [])
                              endfor
                              for f in values(s:lightline.tab_component_function)
                                silent! call call(f, [1])
                              endfor
                              let s:mode = ''
                            endfunction
                            
    1              0.000002 function! lightline#colorscheme() abort
                              try
                                let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
                              catch
                                call lightline#error('Could not load colorscheme ' . s:lightline.colorscheme . '.')
                                let s:lightline.colorscheme = 'default'
                                let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
                              finally
                                if has('win32') && !has('gui_running') && &t_Co < 256
                                  for u in values(s:lightline.palette)
                                    for v in values(u)
                                      for _  in v
                                        let [_[2], _[3]] = [lightline#colortable#gui2cui(_[0], _[2]), lightline#colortable#gui2cui(_[1], _[3])]
                                      endfor
                                    endfor
                                  endfor
                                endif
                                let s:highlight = {}
                                call lightline#highlight('normal')
                                call lightline#link()
                                let s:_ = 0
                              endtry
                            endfunction
                            
    1              0.000002 function! lightline#palette() abort
                              return s:lightline.palette
                            endfunction
                            
    1              0.000001 function! lightline#mode() abort
                              return get(s:lightline.mode_map, mode(), '')
                            endfunction
                            
    1              0.000002 let s:mode = ''
    1              0.000002 function! lightline#link(...) abort
                              let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
                              if s:mode == mode
                                return ''
                              endif
                              let s:mode = mode
                              if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
                              endif
                              let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
                              for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
                                for [i, t] in map(range(0, l), '[v:val, 0]') + types
                                  if i != l
                                    exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
                                  endif
                                  for [j, s] in map(range(0, l), '[v:val, 0]') + types
                                    if i + 1 == j || t || s && i != l
                                      exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
                                    endif
                                  endfor
                                endfor
                              endfor
                              exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
                              return ''
                            endfunction
                            
    1              0.000003 function! s:term(p) abort
                              return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
                            endfunction
                            
    1              0.000004 if exists('*uniq')
    1              0.000006   let s:uniq = function('uniq')
    1              0.000002 else
                              function! s:uniq(xs) abort
                                let i = len(a:xs) - 1
                                while i > 0
                                  if a:xs[i] ==# a:xs[i - 1]
                                    call remove(a:xs, i)
                                  endif
                                  let i -= 1
                                endwhile
                                return a:xs
                              endfunction
                            endif
                            
    1              0.000003 function! lightline#highlight(...) abort
                              let [c, f] = [s:lightline.palette, s:lightline.mode_fallback]
                              let [s:lightline.llen, s:lightline.rlen] = [len(c.normal.left), len(c.normal.right)]
                              let [s:lightline.tab_llen, s:lightline.tab_rlen] = [len(has_key(get(c, 'tabline', {}), 'left') ? c.tabline.left : c.normal.left), len(has_key(get(c, 'tabline', {}), 'right') ? c.tabline.right : c.normal.right)]
                              let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
                              let modes = a:0 ? [a:1] : extend(['normal', 'insert', 'replace', 'visual', 'inactive', 'command', 'select', 'tabline'], has('nvim') ? ['terminal'] : [])
                              for mode in modes
                                let s:highlight[mode] = 1
                                let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
                                let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
                                let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
                                let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
                                let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
                                let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
                                for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
                                  for [i, t] in map(range(0, l), '[v:val, 0]') + types
                                    if i < l || i < 1
                                      let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
                                      exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
                                    endif
                                    for [j, s] in map(range(0, l), '[v:val, 0]') + types
                                      if i + 1 == j || t || s && i != l
                                        let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
                                        exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
                                      endif
                                    endfor
                                  endfor
                                endfor
                                exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
                              endfor
                            endfunction
                            
    1              0.000002 function! s:subseparator(components, subseparator, expanded) abort
                              let [a, c, f, v, u ] = [ a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition ]
                              let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" :
                                    \ has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") :
                                    \ has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
                              return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
                            endfunction
                            
    1              0.000003 function! lightline#concatenate(xs, right) abort
                              let separator = a:right ? s:lightline.subseparator.right : s:lightline.subseparator.left
                              return join(filter(copy(a:xs), 'v:val !=# ""'), ' ' . separator . ' ')
                            endfunction
                            
    1              0.000002 function! lightline#statusline(inactive) abort
                              if a:inactive && !has_key(s:highlight, 'inactive')
                                call lightline#highlight('inactive')
                              endif
                              return s:line(0, a:inactive)
                            endfunction
                            
    1              0.000002 function! s:normalize(result) abort
                              if type(a:result) == 3
                                return map(a:result, 'type(v:val) == 1 ? v:val : string(v:val)')
                              elseif type(a:result) == 1
                                return [a:result]
                              else
                                return [string(a:result)]
                              endif
                            endfunction
                            
    1              0.000002 function! s:evaluate_expand(component) abort
                              try
                                let result = eval(a:component . '()')
                                if type(result) == 1 && result ==# ''
                                  return []
                                endif
                              catch
                                return []
                              endtry
                              return map(type(result) == 3 ? (result + [[], [], []])[:2] : [[], [result], []], 'filter(s:normalize(v:val), "v:val !=# ''''")')
                            endfunction
                            
    1              0.000003 function! s:convert(name, index) abort
                              if has_key(s:lightline.component_expand, a:name)
                                let type = get(s:lightline.component_type, a:name, a:index)
                                return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1, v:key == 1 ? "' . type . '" : "' . a:index . '"]'), 'v:val[0] != []')
                              else
                                return [[[a:name], 0, a:index]]
                              endif
                            endfunction
                            
    1              0.000002 function! s:flatten_twice(xss) abort
                              let ys = []
                              for xs in a:xss
                                for x in xs
                                  let ys += x
                                endfor
                              endfor
                              return ys
                            endfunction
                            
    1              0.000005 if v:version > 702 || v:version == 702 && has('patch295')
    1              0.000005   let s:map = function('map')
    1              0.000001 else
                              function! s:map(xs, f) abort
                                let ys = []
                                for i in range(len(a:xs))
                                  call extend(ys, map(a:xs[(i):(i)], substitute(a:f, 'v:key', i, 'g')))
                                endfor
                                return ys
                              endfunction
                            endif
                            
    1              0.000001 function! s:expand(components) abort
                              let components = []
                              let expanded = []
                              let indices = []
                              let previndex = -1
                              let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
                              for [component, expand, index] in xs
                                if previndex != index
                                  call add(indices, index)
                                  call add(components, [])
                                  call add(expanded, [])
                                endif
                                call extend(components[-1], component)
                                call extend(expanded[-1], repeat([expand], len(component)))
                                let previndex = index
                              endfor
                              call add(indices, string(len(a:components)))
                              return [components, expanded, indices]
                            endfunction
                            
    1              0.000002 function! s:line(tabline, inactive) abort
                              let _ = a:tabline ? '' : '%{lightline#link()}'
                              if s:lightline.palette == {}
                                call lightline#colorscheme()
                              endif
                              let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
                              let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
                              let [c, f, t] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type]
                              let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
                              let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
                              let [lt, lc, ll] = s:expand(copy(l_))
                              let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
                              let [rt, rc, rl] = s:expand(copy(r_))
                              for i in range(len(lt))
                                let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
                                for j in range(len(lt[i]))
                                  let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
                                  let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || x ==# '' ? x : '%( ' . x . ' %)'
                                  if j < len(lt[i]) - 1 && s.left !=# ''
                                    let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
                                  endif
                                endfor
                                let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
                                let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
                              endfor
                              let _ .= '%#LightlineMiddle_' . mode . '#%='
                              for i in reverse(range(len(rt)))
                                let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
                                let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
                                let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
                                for j in range(len(rt[i]))
                                  let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
                                  let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || x ==# '' ? x : '%( ' . x . ' %)'
                                  if j < len(rt[i]) - 1 && s.right !=# ''
                                    let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
                                  endif
                                endfor
                              endfor
                              return _
                            endfunction
                            
    1              0.000002 let s:tabnr = -1
    1              0.000003 let s:tabcnt = -1
    1              0.000003 let s:tabline = ''
    1              0.000004 function! lightline#tabline() abort
                              if !has_key(s:highlight, 'tabline')
                                call lightline#highlight('tabline')
                              endif
                              if s:lightline.tabline_configured || s:tabnr != tabpagenr() || s:tabcnt != tabpagenr('$')
                                let s:tabnr = tabpagenr()
                                let s:tabcnt = tabpagenr('$')
                                let s:tabline = s:line(1, 0)
                              endif
                              return s:tabline
                            endfunction
                            
    1              0.000002 function! lightline#tabs() abort
                              let [x, y, z] = [[], [], []]
                              let nr = tabpagenr()
                              let cnt = tabpagenr('$')
                              for i in range(1, cnt)
                                call add(i < nr ? x : i == nr ? y : z, '%'. i . 'T%{lightline#onetab(' . i . ',' . (i == nr) . ')}' . (i == cnt ? '%T' : ''))
                              endfor
                              let abbr = '...'
                              let n = min([max([s:lightline.winwidth / 40, 2]), 8])
                              if len(x) > n && len(z) > n
                                let x = extend(add(x[:n/2-1], abbr), x[-(n+1)/2:])
                                let z = extend(add(z[:(n+1)/2-1], abbr), z[-n/2:])
                              elseif len(x) + len(z) > 2 * n
                                if len(x) > n
                                  let x = extend(add(x[:(2*n-len(z))/2-1], abbr), x[-(2*n-len(z)+1)/2:])
                                elseif len(z) > n
                                  let z = extend(add(z[:(2*n-len(x)+1)/2-1], abbr), z[-(2*n-len(x))/2:])
                                endif
                              endif
                              return [x, y, z]
                            endfunction
                            
    1              0.000002 function! lightline#onetab(n, active) abort
                              let _ = []
                              for name in a:active ? s:lightline.tab.active : s:lightline.tab.inactive
                                if has_key(s:lightline.tab_component_function, name)
                                  call add(_, call(s:lightline.tab_component_function[name], [a:n]))
                                else
                                  call add(_, get(s:lightline.tab_component, name, ''))
                                endif
                              endfor
                              return join(filter(_, 'v:val !=# ""'), ' ')
                            endfunction
                            
    1              0.000002 function! lightline#error(msg) abort
                              echohl ErrorMsg
                              echomsg 'lightline.vim: '.a:msg
                              echohl None
                            endfunction
                            
    1              0.000012 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/user/fbarotjr/.vim/plugged/lightline.vim/autoload/lightline/tab.vim
Sourced 1 time
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
                            " =============================================================================
                            " Filename: autoload/lightline/tab.vim
                            " Author: itchyny
                            " License: MIT License
                            " Last Change: 2016/05/07 22:31:02.
                            " =============================================================================
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000004 function! lightline#tab#filename(n) abort
                              let buflist = tabpagebuflist(a:n)
                              let winnr = tabpagewinnr(a:n)
                              let _ = expand('#'.buflist[winnr - 1].':t')
                              return _ !=# '' ? _ : '[No Name]'
                            endfunction
                            
    1              0.000002 function! lightline#tab#modified(n) abort
                              let winnr = tabpagewinnr(a:n)
                              return gettabwinvar(a:n, winnr, '&modified') ? '+' : gettabwinvar(a:n, winnr, '&modifiable') ? '' : '-'
                            endfunction
                            
    1              0.000002 function! lightline#tab#readonly(n) abort
                              let winnr = tabpagewinnr(a:n)
                              return gettabwinvar(a:n, winnr, '&readonly') ? 'RO' : ''
                            endfunction
                            
    1              0.000002 function! lightline#tab#tabnum(n) abort
                              return a:n
                            endfunction
                            
    1              0.000007 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/user/fbarotjr/.vim/plugged/gruvbox/autoload/lightline/colorscheme/gruvbox.vim
Sourced 1 time
Total time:   0.002356
 Self time:   0.000868

count  total (s)   self (s)
                            " -----------------------------------------------------------------------------
                            " File: gruvbox.vim
                            " Description: Gruvbox colorscheme for Lightline (itchyny/lightline.vim)
                            " Author: gmoe <me@griffinmoe.com>
                            " Source: https://github.com/morhetz/gruvbox
                            " Last Modified: 31 Oct 2015
                            " -----------------------------------------------------------------------------
                            
    1              0.000006 function! s:getGruvColor(group)
                              let guiColor = synIDattr(hlID(a:group), "fg", "gui") 
                              let termColor = synIDattr(hlID(a:group), "fg", "cterm") 
                              return [ guiColor, termColor ]
                            endfunction
                            
    1              0.000004 if exists('g:lightline')
                            
    1   0.000043   0.000014   let s:bg0  = s:getGruvColor('GruvboxBg0')
    1   0.000022   0.000006   let s:bg1  = s:getGruvColor('GruvboxBg1')
    1   0.000020   0.000005   let s:bg2  = s:getGruvColor('GruvboxBg2')
    1   0.000020   0.000006   let s:bg4  = s:getGruvColor('GruvboxBg4')
    1   0.000020   0.000004   let s:fg1  = s:getGruvColor('GruvboxFg1')
    1   0.000022   0.000006   let s:fg4  = s:getGruvColor('GruvboxFg4')
                            
    1   0.000020   0.000005   let s:yellow = s:getGruvColor('GruvboxYellow')
    1   0.000019   0.000004   let s:blue   = s:getGruvColor('GruvboxBlue')
    1   0.000019   0.000005   let s:aqua   = s:getGruvColor('GruvboxAqua')
    1   0.000019   0.000005   let s:orange = s:getGruvColor('GruvboxOrange')
                            
    1              0.000006   let s:p = {'normal':{}, 'inactive':{}, 'insert':{}, 'replace':{}, 'visual':{}, 'tabline':{}}
    1              0.000004   let s:p.normal.left = [ [ s:bg0, s:fg4 ], [ s:fg4, s:bg2 ] ]
    1              0.000003   let s:p.normal.right = [ [ s:bg0, s:fg4 ], [ s:fg4, s:bg2 ] ]
    1              0.000003   let s:p.normal.middle = [ [ s:fg4, s:bg1 ] ]
    1              0.000003   let s:p.inactive.right = [ [ s:bg4, s:bg1 ], [ s:bg4, s:bg1 ] ]
    1              0.000003   let s:p.inactive.left =  [ [ s:bg4, s:bg1 ], [ s:bg4, s:bg1 ] ]
    1              0.000003   let s:p.inactive.middle = [ [ s:bg4, s:bg1 ] ]
    1              0.000003   let s:p.insert.left = [ [ s:bg0, s:blue ], [ s:fg1, s:bg2 ] ]
    1              0.000003   let s:p.insert.right = [ [ s:bg0, s:blue ], [ s:fg1, s:bg2 ] ]
    1              0.000003   let s:p.insert.middle = [ [ s:fg4, s:bg2 ] ]
    1              0.000003   let s:p.replace.left = [ [ s:bg0, s:aqua ], [ s:fg1, s:bg2 ] ]
    1              0.000003   let s:p.replace.right = [ [ s:bg0, s:aqua ], [ s:fg1, s:bg2 ] ]
    1              0.000003   let s:p.replace.middle = [ [ s:fg4, s:bg2 ] ]
    1              0.000003   let s:p.visual.left = [ [ s:bg0, s:orange ], [ s:bg0, s:bg4 ] ]
    1              0.000003   let s:p.visual.right = [ [ s:bg0, s:orange ], [ s:bg0, s:bg4 ] ]
    1              0.000002   let s:p.visual.middle = [ [ s:fg4, s:bg1 ] ]
    1              0.000003   let s:p.tabline.left = [ [ s:fg4, s:bg2 ] ]
    1              0.000002   let s:p.tabline.tabsel = [ [ s:bg0, s:fg4 ] ]
    1              0.000003   let s:p.tabline.middle = [ [ s:bg0, s:bg0 ] ]
    1              0.000002   let s:p.tabline.right = [ [ s:bg0, s:orange ] ]
    1              0.000003   let s:p.normal.error = [ [ s:bg0, s:orange ] ]
    1              0.000002   let s:p.normal.warning = [ [ s:bg2, s:yellow ] ]
                            
    1              0.000677   let g:lightline#colorscheme#gruvbox#palette = lightline#colorscheme#flatten(s:p)
    1              0.000003 endif

SCRIPT  /home/user/fbarotjr/.vim/plugged/lightline.vim/autoload/lightline/colorscheme.vim
Sourced 1 time
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
                            " =============================================================================
                            " Filename: autoload/lightline/colorscheme.vim
                            " Author: itchyny
                            " License: MIT License
                            " Last Change: 2015/03/18 08:37:17.
                            " =============================================================================
                            
    1              0.000013 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000042 let s:cuicolor = {
                                  \ 'black'          : 16,
                                  \ 'white'          : 231,
                                  \
                                  \ 'darkestgreen'   : 22,
                                  \ 'darkgreen'      : 28,
                                  \ 'mediumgreen'    : 70,
                                  \ 'brightgreen'    : 148,
                                  \
                                  \ 'darkestcyan'    : 23,
                                  \ 'mediumcyan'     : 117,
                                  \
                                  \ 'darkestblue'    : 24,
                                  \ 'darkblue'       : 31,
                                  \
                                  \ 'darkestred'     : 52,
                                  \ 'darkred'        : 88,
                                  \ 'mediumred'      : 124,
                                  \ 'brightred'      : 160,
                                  \ 'brightestred'   : 196,
                                  \
                                  \ 'darkestpurple'  : 55,
                                  \ 'mediumpurple'   : 98,
                                  \ 'brightpurple'   : 189,
                                  \
                                  \ 'brightorange'   : 208,
                                  \ 'brightestorange': 214,
                                  \
                                  \ 'gray0'          : 233,
                                  \ 'gray1'          : 235,
                                  \ 'gray2'          : 236,
                                  \ 'gray3'          : 239,
                                  \ 'gray4'          : 240,
                                  \ 'gray5'          : 241,
                                  \ 'gray6'          : 244,
                                  \ 'gray7'          : 245,
                                  \ 'gray8'          : 247,
                                  \ 'gray9'          : 250,
                                  \ 'gray10'         : 252,
                                  \
                                  \ 'yellow'         : 136,
                                  \ 'orange'         : 166,
                                  \ 'red'            : 160,
                                  \ 'magenta'        : 125,
                                  \ 'violet'         : 61,
                                  \ 'blue'           : 33,
                                  \ 'cyan'           : 37,
                                  \ 'green'          : 64,
                                  \ }
                            
    1              0.000033 let s:guicolor = {
                                  \ 'black'          : '#000000',
                                  \ 'white'          : '#ffffff',
                                  \
                                  \ 'darkestgreen'   : '#005f00',
                                  \ 'darkgreen'      : '#008700',
                                  \ 'mediumgreen'    : '#5faf00',
                                  \ 'brightgreen'    : '#afdf00',
                                  \
                                  \ 'darkestcyan'    : '#005f5f',
                                  \ 'mediumcyan'     : '#87dfff',
                                  \
                                  \ 'darkestblue'    : '#005f87',
                                  \ 'darkblue'       : '#0087af',
                                  \
                                  \ 'darkestred'     : '#5f0000',
                                  \ 'darkred'        : '#870000',
                                  \ 'mediumred'      : '#af0000',
                                  \ 'brightred'      : '#df0000',
                                  \ 'brightestred'   : '#ff0000',
                                  \
                                  \ 'darkestpurple'  : '#5f00af',
                                  \ 'mediumpurple'   : '#875fdf',
                                  \ 'brightpurple'   : '#dfdfff',
                                  \
                                  \ 'brightorange'   : '#ff8700',
                                  \ 'brightestorange': '#ffaf00',
                                  \
                                  \ 'gray0'          : '#121212',
                                  \ 'gray1'          : '#262626',
                                  \ 'gray2'          : '#303030',
                                  \ 'gray3'          : '#4e4e4e',
                                  \ 'gray4'          : '#585858',
                                  \ 'gray5'          : '#606060',
                                  \ 'gray6'          : '#808080',
                                  \ 'gray7'          : '#8a8a8a',
                                  \ 'gray8'          : '#9e9e9e',
                                  \ 'gray9'          : '#bcbcbc',
                                  \ 'gray10'         : '#d0d0d0',
                                  \
                                  \ 'yellow'         : '#b58900',
                                  \ 'orange'         : '#cb4b16',
                                  \ 'red'            : '#dc322f',
                                  \ 'magenta'        : '#d33682',
                                  \ 'violet'         : '#6c71c4',
                                  \ 'blue'           : '#268bd2',
                                  \ 'cyan'           : '#2aa198',
                                  \ 'green'          : '#859900',
                                  \ }
                            
    1              0.000004 function! s:convert(rgb) abort
                              let rgb = map(matchlist(a:rgb, '#\(..\)\(..\)\(..\)')[1:3], '0 + ("0x".v:val)')
                              if len(rgb) == 0
                                return 0
                              endif
                              if rgb[0] == 0xc0 && rgb[1] == 0xc0 && rgb[2] == 0xc0
                                return 7
                              elseif rgb[0] == 0x80 && rgb[1] == 0x80 && rgb[2] == 0x80
                                return 8
                              elseif (rgb[0] == 0x80 || rgb[0] == 0x00) && (rgb[1] == 0x80 || rgb[1] == 0x00) && (rgb[2] == 0x80 || rgb[2] == 0x00)
                                return (rgb[0] / 0x80) + (rgb[1] / 0x80) * 2 + (rgb[1] / 0x80) * 4
                              elseif abs(rgb[0]-rgb[1]) < 3 && abs(rgb[1]-rgb[2]) < 3 && abs(rgb[2]-rgb[0]) < 3
                                return s:black((rgb[0] + rgb[1] + rgb[2]) / 3)
                              else
                                return 16 + ((s:nr(rgb[0]) * 6) + s:nr(rgb[1])) * 6 + s:nr(rgb[2])
                              endif
                            endfunction
                            
    1              0.000002 function! s:black(x) abort
                              if a:x < 0x04
                                return 16
                              elseif a:x > 0xf4
                                return 231
                              elseif index([0x00, 0x5f, 0x87, 0xaf, 0xdf, 0xff], a:x) >= 0
                                let l = a:x / 0x30
                                return ((l * 6) + l) * 6 + l + 16
                              else
                                return 232 + (a:x < 8 ? 0 : a:x < 0x60 ? (a:x-8)/10 : a:x < 0x76 ? (a:x-0x60)/6+9 : (a:x-8)/10)
                              endif
                            endfunction
                            
    1              0.000002 function! s:nr(x) abort
                              return a:x < 0x2f ? 0 : a:x < 0x73 ? 1 : a:x < 0x9b ? 2 : a:x < 0xc7 ? 3 : a:x < 0xef ? 4 : 5
                            endfunction
                            
    1              0.000002 function! s:rgb(r, g, b) abort
                              return printf('#%02x%02x%02x', a:r, a:g, a:b)
                            endfunction
                            
    1              0.000002 function! s:upconvert(nr) abort
                              let x = a:nr * 1
                              if x < 7
                                let [b, rg] = [x / 4, x % 4]
                                let [g, r] = [rg / 2, rg % 2]
                                return s:rgb(r * 0x80, g * 0x80, b * 0x80)
                              elseif x == 7
                                return s:rgb(0xc0, 0xc0, 0xc0)
                              elseif x == 8
                                return s:rgb(0x80, 0x80, 0x80)
                              elseif x < 16
                                let y = x - 8
                                let [b, rg] = [y / 4, y % 4]
                                let [g, r] = [rg / 2, rg % 2]
                                return s:rgb(r * 0xff, g * 0xff, b * 0xff)
                              elseif x < 232
                                let y = x - 16
                                let [rg, b] = [y / 6, y % 6]
                                let [r, g] = [rg / 6, rg % 6]
                                let l = [0x00, 0x5f, 0x87, 0xaf, 0xdf, 0xff]
                                return s:rgb(l[r], l[g], l[b])
                              elseif x < 241
                                let k = (x - 232) * 10 + 8
                                return s:rgb(k, k, k)
                              elseif x < 243
                                let k = (x - 241) * 6 + 0x60
                                return s:rgb(k, k, k)
                              else
                                let k = (x - 232) * 10 + 8
                                return s:rgb(k, k, k)
                              endif
                            endfunction
                            
    1              0.000003 function! lightline#colorscheme#fill(p) abort
                              for k in values(a:p)
                                for l in values(k)
                                  for m in l
                                    if len(m) < 4
                                      if type(m[0]) == 1 && type(m[1]) == 1
                                        if m[0] =~# '^\d\+$' && m[1] =~# '^\d\+$'
                                          call insert(m, s:upconvert(m[1]), 0)
                                          call insert(m, s:upconvert(m[1]), 0)
                                        else
                                          call insert(m, get(s:cuicolor, m[0], s:convert(m[0])), 2)
                                          call insert(m, get(s:cuicolor, m[1], s:convert(m[1])), 3)
                                          let m[0] = get(s:guicolor, m[0], m[0])
                                          let m[1] = get(s:guicolor, m[1], m[1])
                                        endif
                                      elseif type(m[0]) == 0 && type(m[1]) == 0
                                          call insert(m, s:upconvert(m[1]), 0)
                                          call insert(m, s:upconvert(m[1]), 0)
                                      endif
                                    endif
                                  endfor
                                endfor
                              endfor
                              return a:p
                            endfunction
                            
    1              0.000003 function! lightline#colorscheme#flatten(p) abort
                              for k in values(a:p)
                                for l in values(k)
                                  for m in range(len(l))
                                    let attr = ''
                                    if len(l[m]) == 3 && type(l[m][2]) == 1
                                      let attr = l[m][2]
                                    endif
                                    let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
                                    if !empty(attr)
                                      call add(l[m], attr)
                                    endif
                                  endfor
                                endfor
                              endfor
                              return a:p
                            endfunction
                            
    1              0.000008 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

FUNCTION  lightline#colorscheme()
Called 1 time
Total time:   0.006394
 Self time:   0.001149

count  total (s)   self (s)
    1              0.000001   try
    1   0.003458   0.001082     let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
    1              0.000003   catch
                                call lightline#error('Could not load colorscheme ' . s:lightline.colorscheme . '.')
                                let s:lightline.colorscheme = 'default'
                                let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
                              finally
    1              0.000007     if has('win32') && !has('gui_running') && &t_Co < 256
                                  for u in values(s:lightline.palette)
                                    for v in values(u)
                                      for _  in v
                                        let [_[2], _[3]] = [lightline#colortable#gui2cui(_[0], _[2]), lightline#colortable#gui2cui(_[1], _[3])]
                                      endfor
                                    endfor
                                  endfor
                                endif
    1              0.000002     let s:highlight = {}
    1   0.001906   0.000016     call lightline#highlight('normal')
    1   0.000990   0.000011     call lightline#link()
    1              0.000003     let s:_ = 0
    1              0.000002   endtry

FUNCTION  <SNR>9_define_commands()
Called 1 time
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    1              0.000015   command! -nargs=+ -bar Plug call plug#(<args>)
    1              0.000026   if !executable('git')
                                return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')
                              endif
    1              0.000010   command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])
    1              0.000008   command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])
    1              0.000006   command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)
    1              0.000009   command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif
    1              0.000004   command! -nargs=0 -bar PlugStatus  call s:status()
    1              0.000004   command! -nargs=0 -bar PlugDiff    call s:diff()
    1              0.000008   command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)

FUNCTION  lightline#init()
Called 1 time
Total time:   0.001920
 Self time:   0.001771

count  total (s)   self (s)
    1              0.000012   let s:lightline = deepcopy(get(g:, 'lightline', {}))
   24              0.000050   for [key, value] in items(s:_lightline)
   23              0.000043     if type(value) == 4
   21              0.000043       if !has_key(s:lightline, key)
   17              0.000041         let s:lightline[key] = {}
   17              0.000009       endif
   21              0.000075       call extend(s:lightline[key], value, 'keep')
   21              0.000034     elseif !has_key(s:lightline, key)
    1              0.000002       let s:lightline[key] = value
    1              0.000001     endif
   23              0.000022     unlet value
   23              0.000018   endfor
    1              0.000004   call extend(s:lightline.tabline_separator, s:lightline.separator, 'keep')
    1              0.000003   call extend(s:lightline.tabline_subseparator, s:lightline.subseparator, 'keep')
    1              0.000007   let s:lightline.tabline_configured = has_key(get(get(g:, 'lightline', {}), 'component_expand', {}), 'tabs')
    3              0.000007   for components in deepcopy(s:lightline.tabline.left + s:lightline.tabline.right)
    2              0.000012     if len(filter(components, 'v:val !=# "tabs" && v:val !=# "close"')) > 0
                                  let s:lightline.tabline_configured = 1
                                  break
                                endif
    2              0.000002   endfor
    1              0.000002   if !exists('s:_statusline')
    1              0.000003     let s:_statusline = &statusline
    1              0.000000   endif
    1              0.000002   if !exists('s:_tabline')
    1              0.000002     let s:_tabline = &tabline
    1              0.000000   endif
    1              0.000002   if s:lightline.enable.tabline
    1              0.000004     set tabline=%!lightline#tabline()
    1              0.000000   else
                                let &tabline = get(s:, '_tabline', '')
                              endif
    2              0.000005   for f in values(s:lightline.component_function)
    1   0.000016   0.000012     silent! call call(f, [])
    1              0.000001   endfor
    5              0.000008   for f in values(s:lightline.tab_component_function)
    4   0.001373   0.001228     silent! call call(f, [1])
    4              0.000005   endfor
    1              0.000002   let s:mode = ''

FUNCTION  <SNR>9_assoc()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000007   let a:dict[a:key] = add(get(a:dict, a:key, []), a:val)

FUNCTION  <SNR>9_reorg_rtp()
Called 1 time
Total time:   0.016343
 Self time:   0.016148

count  total (s)   self (s)
    1              0.000003   if !empty(s:first_rtp)
    1              0.000009     execute 'set rtp-='.s:first_rtp
    1              0.000007     execute 'set rtp-='.s:last_rtp
    1              0.000001   endif
                            
                              " &rtp is modified from outside
    1              0.000003   if exists('s:prtp') && s:prtp !=# &rtp
                                call s:remove_rtp()
                                unlet! s:middle
                              endif
                            
    1              0.000006   let s:middle = get(s:, 'middle', &rtp)
    1   0.000249   0.000054   let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
    1              0.015952   let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')
    1              0.000038   let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',') . ','.s:middle.',' . join(map(afters, 'escape(v:val, ",")'), ',')
    1              0.000032   let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
    1              0.000004   let s:prtp   = &rtp
                            
    1              0.000004   if !empty(s:first_rtp)
    1              0.000016     execute 'set rtp^='.s:first_rtp
    1              0.000011     execute 'set rtp+='.s:last_rtp
    1              0.000001   endif

FUNCTION  AutoPairsMap()
Called 9 times
Total time:   0.000350
 Self time:   0.000350

count  total (s)   self (s)
                              " | is special key which separate map command from text
    9              0.000025   let key = a:key
    9              0.000024   if key == '|'
                                let key = '<BAR>'
                              end
    9              0.000077   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
    9              0.000168   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
                            

FUNCTION  <SNR>36_convert()
Called 10 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
   10              0.000032   if has_key(s:lightline.component_expand, a:name)
                                let type = get(s:lightline.component_type, a:name, a:index)
                                return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1, v:key == 1 ? "' . type . '" : "' . a:index . '"]'), 'v:val[0] != []')
                              else
   10              0.000025     return [[[a:name], 0, a:index]]
                              endif

FUNCTION  <SNR>9_is_local_plug()
Called 12 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
   12              0.000069     return a:repo[0] =~ '[/$~]'

FUNCTION  lightline#link()
Called 1 time
Total time:   0.000979
 Self time:   0.000979

count  total (s)   self (s)
    1              0.000007   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
    1              0.000002   if s:mode == mode
                                return ''
                              endif
    1              0.000002   let s:mode = mode
    1              0.000002   if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
                              endif
    1              0.000011   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
    3              0.000010   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
   11              0.000027     for [i, t] in map(range(0, l), '[v:val, 0]') + types
    9              0.000012       if i != l
    7              0.000104         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
    7              0.000005       endif
   50              0.000127       for [j, s] in map(range(0, l), '[v:val, 0]') + types
   41              0.000094         if i + 1 == j || t || s && i != l
   19              0.000254           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
   19              0.000014         endif
   41              0.000049       endfor
    9              0.000006     endfor
    2              0.000001   endfor
    1              0.000016   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
    1              0.000003   return ''

FUNCTION  <SNR>9_escrtp()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000011   return escape(a:path, ' ,')

FUNCTION  lightline#tab#readonly()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000003   let winnr = tabpagewinnr(a:n)
    1              0.000005   return gettabwinvar(a:n, winnr, '&readonly') ? 'RO' : ''

FUNCTION  plug#begin()
Called 1 time
Total time:   0.000224
 Self time:   0.000105

count  total (s)   self (s)
    1              0.000004   if a:0 > 0
                                let s:plug_home_org = a:1
                                let home = s:path(fnamemodify(expand(a:1), ':p'))
                              elseif exists('g:plug_home')
                                let home = s:path(g:plug_home)
                              elseif !empty(&rtp)
    1   0.000042   0.000019     let home = s:path(split(&rtp, ',')[0]) . '/plugged'
    1              0.000001   else
                                return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')
                              endif
    1              0.000005   if fnamemodify(home, ':t') ==# 'plugin' && fnamemodify(home, ':h') ==# s:first_rtp
                                return s:err('Invalid plug home. '.home.' is a standard Vim runtime path and is not allowed.')
                              endif
                            
    1              0.000002   let g:plug_home = home
    1              0.000001   let g:plugs = {}
    1              0.000002   let g:plugs_order = []
    1              0.000035   let s:triggers = {}
                            
    1   0.000106   0.000010   call s:define_commands()
    1              0.000001   return 1

FUNCTION  lightline#tab#filename()
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000007   let buflist = tabpagebuflist(a:n)
    1              0.000004   let winnr = tabpagewinnr(a:n)
    1              0.000014   let _ = expand('#'.buflist[winnr - 1].':t')
    1              0.000002   return _ !=# '' ? _ : '[No Name]'

FUNCTION  lightline#colorscheme#flatten()
Called 1 time
Total time:   0.001103
 Self time:   0.001103

count  total (s)   self (s)
    7              0.000012   for k in values(a:p)
   27              0.000032     for l in values(k)
   52              0.000078       for m in range(len(l))
   31              0.000037         let attr = ''
   31              0.000107         if len(l[m]) == 3 && type(l[m][2]) == 1
                                      let attr = l[m][2]
                                    endif
   31              0.000239         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
   31              0.000061         if !empty(attr)
                                      call add(l[m], attr)
                                    endif
   31              0.000024       endfor
   21              0.000020     endfor
    6              0.000003   endfor
    1              0.000001   return a:p

FUNCTION  <SNR>9_split_rtp()
Called 2 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    2              0.000069   return split(&rtp, '\\\@<!,')

FUNCTION  <SNR>36_subseparator()
Called 5 times
Total time:   0.000315
 Self time:   0.000315

count  total (s)   self (s)
    5              0.000032   let [a, c, f, v, u ] = [ a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition ]
    5              0.000220   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
    5              0.000054   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'

FUNCTION  <SNR>9_infer_properties()
Called 12 times
Total time:   0.000653
 Self time:   0.000444

count  total (s)   self (s)
   12              0.000021   let repo = a:repo
   12   0.000121   0.000046   if s:is_local_plug(repo)
                                return { 'dir': s:dirpath(expand(repo)) }
                              else
   12              0.000033     if repo =~ ':'
                                  let uri = repo
                                else
   12              0.000028       if repo !~ '/'
                                    throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
                                  endif
   12              0.000041       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
   12              0.000044       let uri = printf(fmt, repo)
   12              0.000007     endif
   12   0.000218   0.000084     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
                              endif

FUNCTION  <SNR>13_HL()
Called 93 times
Total time:   0.005317
 Self time:   0.005317

count  total (s)   self (s)
                              " Arguments: group, guifg, guibg, gui, guisp
                            
                              " foreground
   93              0.000189   let fg = a:fg
                            
                              " background
   93              0.000120   if a:0 >= 1
   75              0.000101     let bg = a:1
   75              0.000049   else
   18              0.000027     let bg = s:none
   18              0.000015   endif
                            
                              " emphasis
   93              0.000201   if a:0 >= 2 && strlen(a:2)
   24              0.000034     let emstr = a:2
   24              0.000017   else
   69              0.000087     let emstr = 'NONE,'
   69              0.000049   endif
                            
                              " special fallback
   93              0.000088   if a:0 >= 3
    6              0.000014     if g:gruvbox_guisp_fallback != 'NONE'
                                  let fg = a:3
                                endif
                            
                                " bg fallback mode should invert higlighting
    6              0.000011     if g:gruvbox_guisp_fallback == 'bg'
                                  let emstr .= 'inverse,'
                                endif
    6              0.000004   endif
                            
   93              0.000977   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
                            
                              " special
   93              0.000146   if a:0 >= 3
    6              0.000028     call add(histring, 'guisp=' . a:3[0])
    6              0.000003   endif
                            
   93              0.001350   execute join(histring, ' ')

FUNCTION  <SNR>9_loaded_names()
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000025   return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')

FUNCTION  <SNR>9_dirpath()
Called 24 times
Total time:   0.000250
 Self time:   0.000250

count  total (s)   self (s)
   24              0.000237     return substitute(a:path, '[/\\]*$', '/', '')

FUNCTION  <SNR>36_expand()
Called 2 times
Total time:   0.000593
 Self time:   0.000367

count  total (s)   self (s)
    2              0.000005   let components = []
    2              0.000004   let expanded = []
    2              0.000003   let indices = []
    2              0.000004   let previndex = -1
    2   0.000327   0.000101   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
   12              0.000021   for [component, expand, index] in xs
   10              0.000015     if previndex != index
    5              0.000015       call add(indices, index)
    5              0.000010       call add(components, [])
    5              0.000008       call add(expanded, [])
    5              0.000004     endif
   10              0.000032     call extend(components[-1], component)
   10              0.000050     call extend(expanded[-1], repeat([expand], len(component)))
   10              0.000016     let previndex = index
   10              0.000007   endfor
    2              0.000010   call add(indices, string(len(a:components)))
    2              0.000004   return [components, expanded, indices]

FUNCTION  lightline#highlight()
Called 1 time
Total time:   0.001890
 Self time:   0.001850

count  total (s)   self (s)
    1              0.000004   let [c, f] = [s:lightline.palette, s:lightline.mode_fallback]
    1              0.000006   let [s:lightline.llen, s:lightline.rlen] = [len(c.normal.left), len(c.normal.right)]
    1              0.000012   let [s:lightline.tab_llen, s:lightline.tab_rlen] = [len(has_key(get(c, 'tabline', {}), 'left') ? c.tabline.left : c.normal.left), len(has_key(get(c, 'tabline', {}), 'right') ? c.tabline.right : c.normal.right)]
    1              0.000011   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
    1              0.000005   let modes = a:0 ? [a:1] : extend(['normal', 'insert', 'replace', 'visual', 'inactive', 'command', 'select', 'tabline'], has('nvim') ? ['terminal'] : [])
    2              0.000003   for mode in modes
    1              0.000003     let s:highlight[mode] = 1
    1              0.000005     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
    1              0.000004     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
    1              0.000004     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
    1              0.000007     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
    1              0.000010     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
    1              0.000008     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
    3              0.000009     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
   11              0.000027       for [i, t] in map(range(0, l), '[v:val, 0]') + types
    9              0.000013         if i < l || i < 1
    7              0.000062           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
    7   0.000212   0.000177           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
    7              0.000007         endif
   50              0.000137         for [j, s] in map(range(0, l), '[v:val, 0]') + types
   41              0.000107           if i + 1 == j || t || s && i != l
   19              0.000183             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
   19              0.000396             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
   19              0.000016           endif
   41              0.000021         endfor
    9              0.000007       endfor
    2              0.000002     endfor
    1   0.000026   0.000021     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
    1              0.000001   endfor

FUNCTION  LightlineReadonly()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003     return &readonly ? '' : ''

FUNCTION  lightline#update()
Called 1 time
Total time:   0.010120
 Self time:   0.000129

count  total (s)   self (s)
    1              0.000003   if s:_
    1   0.001929   0.000009     call lightline#init()
    1   0.006403   0.000009     call lightline#colorscheme()
    1              0.000001   endif
    1              0.000003   if !s:lightline.enable.statusline
                                return
                              endif
    1              0.000005   let w = winnr()
    1   0.001719   0.000042   let s = winnr('$') == 1 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
    2              0.000008   for n in range(1, winnr('$'))
    1              0.000028     call setwinvar(n, '&statusline', s[n!=w])
    1              0.000006     call setwinvar(n, 'lightline', n!=w)
    1              0.000002   endfor

FUNCTION  <SNR>9_parse_options()
Called 2 times
Total time:   0.000082
 Self time:   0.000071

count  total (s)   self (s)
    2              0.000009   let opts = copy(s:base_spec)
    2              0.000006   let type = type(a:arg)
    2              0.000004   if type == s:TYPE.string
                                let opts.tag = a:arg
                              elseif type == s:TYPE.dict
    2              0.000006     call extend(opts, a:arg)
    2              0.000004     if has_key(opts, 'dir')
    1   0.000034   0.000023       let opts.dir = s:dirpath(expand(opts.dir))
    1              0.000001     endif
    2              0.000002   else
                                throw 'Invalid argument type (expected: string or dictionary)'
                              endif
    2              0.000002   return opts

FUNCTION  plug#()
Called 12 times
Total time:   0.001393
 Self time:   0.000558

count  total (s)   self (s)
   12              0.000020   if a:0 > 1
                                return s:err('Invalid number of arguments (1..2)')
                              endif
                            
   12              0.000011   try
   12   0.000149   0.000049     let repo = s:trim(a:repo)
   12   0.000132   0.000050     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
   12              0.000087     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
   12   0.000735   0.000082     let spec = extend(s:infer_properties(name, repo), opts)
   12              0.000035     if !has_key(g:plugs, name)
   12              0.000034       call add(g:plugs_order, name)
   12              0.000008     endif
   12              0.000027     let g:plugs[name] = spec
   12              0.000040     let s:loaded[name] = get(s:loaded, name, 0)
   12              0.000013   catch
                                return s:err(v:exception)
                              endtry

FUNCTION  <SNR>29_LocalBrowse()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
    1              0.000004   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
    1              0.000001    return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  <SNR>38_getGruvColor()
Called 10 times
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
   10              0.000075   let guiColor = synIDattr(hlID(a:group), "fg", "gui") 
   10              0.000058   let termColor = synIDattr(hlID(a:group), "fg", "cterm") 
   10              0.000021   return [ guiColor, termColor ]

FUNCTION  lightline#tab#modified()
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000004   let winnr = tabpagewinnr(a:n)
    1              0.000012   return gettabwinvar(a:n, winnr, '&modified') ? '+' : gettabwinvar(a:n, winnr, '&modifiable') ? '' : '-'

FUNCTION  <SNR>36_flatten_twice()
Called 2 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    2              0.000004   let ys = []
    7              0.000011   for xs in a:xss
   15              0.000017     for x in xs
   10              0.000013       let ys += x
   10              0.000007     endfor
    5              0.000003   endfor
    2              0.000002   return ys

FUNCTION  <SNR>36_term()
Called 8 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    8              0.000034   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''

FUNCTION  <SNR>9_rtp()
Called 11 times
Total time:   0.000169
 Self time:   0.000064

count  total (s)   self (s)
   11   0.000165   0.000060     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))

FUNCTION  AutoPairsTryInit()
Called 1 time
Total time:   0.001237
 Self time:   0.000158

count  total (s)   self (s)
    1              0.000006   if exists('b:autopairs_loaded')
                                return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
    1              0.000002   if g:AutoPairsMapCR
    1              0.000004     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
    1              0.000018       let info = maparg('<CR>', 'i', 0, 1)
    1              0.000003       if empty(info)
    1              0.000002         let old_cr = '<CR>'
    1              0.000002         let is_expr = 0
    1              0.000002       else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
                                  endif
    1              0.000001     else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
    1              0.000013     if old_cr !~ 'AutoPairsReturn'
    1              0.000002       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
    1              0.000024       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
    1              0.000001     end
    1              0.000002   endif
    1   0.001092   0.000013   call AutoPairsInit()

FUNCTION  <SNR>9_trim()
Called 13 times
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
   13              0.000110   return substitute(a:str, '[\/]\+$', '', '')

FUNCTION  AutoPairsInit()
Called 1 time
Total time:   0.001079
 Self time:   0.000729

count  total (s)   self (s)
    1              0.000004   let b:autopairs_loaded  = 1
    1              0.000005   if !exists('b:autopairs_enabled')
    1              0.000003     let b:autopairs_enabled = 1
    1              0.000001   end
    1              0.000004   let b:AutoPairsClosedPairs = {}
                            
    1              0.000004   if !exists('b:AutoPairs')
    1              0.000004     let b:AutoPairs = g:AutoPairs
    1              0.000001   end
                            
    1              0.000004   if !exists('b:AutoPairsMoveCharacter')
    1              0.000004     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
    1              0.000001   end
                            
                              " buffer level map pairs keys
    7              0.000026   for [open, close] in items(b:AutoPairs)
    6   0.000285   0.000048     call AutoPairsMap(open)
    6              0.000017     if open != close
    3   0.000133   0.000020       call AutoPairsMap(close)
    3              0.000003     end
    6              0.000031     let b:AutoPairsClosedPairs[close] = open
    6              0.000010   endfor
                            
    9              0.000042   for key in split(b:AutoPairsMoveCharacter, '\s*')
    8              0.000061     let escaped_key = substitute(key, "'", "''", 'g')
    8              0.000167     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
    8              0.000015   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
    1              0.000003   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
    1              0.000016     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
    1              0.000001   end
                            
    1              0.000003   if g:AutoPairsMapCh
    1              0.000015     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
    1              0.000001   endif
                            
    1              0.000002   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
    1              0.000003     let do_abbrev = ""
    1              0.000005     if v:version == 703 && has("patch489") || v:version > 703
    1              0.000002       let do_abbrev = "<C-]>"
    1              0.000002     endif
    1              0.000017     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
    1              0.000002   end
                            
    1              0.000004   if g:AutoPairsShortcutFastWrap != ''
    1              0.000017     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
    1              0.000002   end
                            
    1              0.000003   if g:AutoPairsShortcutBackInsert != ''
    1              0.000018     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
    1              0.000002   end
                            
    1              0.000003   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
    1              0.000017     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
    1              0.000018     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
    1              0.000001   end
                            
    1              0.000003   if g:AutoPairsShortcutJump != ''
    1              0.000018     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
    1              0.000017     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
    1              0.000001   end
                            

FUNCTION  lightline#tab#tabnum()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return a:n

FUNCTION  <SNR>9_path()
Called 1 time
Total time:   0.000023
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000022   0.000008     return s:trim(a:path)

FUNCTION  <SNR>9_to_a()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000007   return type(a:v) == s:TYPE.list ? a:v : [a:v]

FUNCTION  <SNR>36_line()
Called 1 time
Total time:   0.001651
 Self time:   0.000743

count  total (s)   self (s)
    1              0.000004   let _ = a:tabline ? '' : '%{lightline#link()}'
    1              0.000003   if s:lightline.palette == {}
                                call lightline#colorscheme()
                              endif
    1              0.000006   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
    1              0.000006   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
    1              0.000004   let [c, f, t] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type]
    1              0.000003   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
    1              0.000007   let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
    1   0.000324   0.000015   let [lt, lc, ll] = s:expand(copy(l_))
    1              0.000004   let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
    1   0.000295   0.000011   let [rt, rc, rl] = s:expand(copy(r_))
    3              0.000006   for i in range(len(lt))
    2              0.000009     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
    7              0.000013     for j in range(len(lt[i]))
    5              0.000064       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
    5              0.000032       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || x ==# '' ? x : '%( ' . x . ' %)'
    5              0.000018       if j < len(lt[i]) - 1 && s.left !=# ''
    3   0.000201   0.000035         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
    3              0.000003       endif
    5              0.000000     endfor
    2              0.000011     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
    2              0.000017     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
    2              0.000002   endfor
    1              0.000006   let _ .= '%#LightlineMiddle_' . mode . '#%='
    4              0.000010   for i in reverse(range(len(rt)))
    3              0.000021     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
    3              0.000030     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
    3              0.000014     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
    8              0.000022     for j in range(len(rt[i]))
    5              0.000074       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
    5              0.000037       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || x ==# '' ? x : '%( ' . x . ' %)'
    5              0.000022       if j < len(rt[i]) - 1 && s.right !=# ''
    2   0.000179   0.000030         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
    2              0.000002       endif
    5              0.000003     endfor
    3              0.000003   endfor
    1              0.000003   return _

FUNCTION  plug#end()
Called 1 time
Total time:   0.140071
 Self time:   0.065239

count  total (s)   self (s)
    1              0.000003   if !exists('g:plugs')
                                return s:err('Call plug#begin() first')
                              endif
                            
    1              0.000004   if exists('#PlugLOD')
                                augroup PlugLOD
                                  autocmd!
                                augroup END
                                augroup! PlugLOD
                              endif
    1              0.000004   let lod = { 'ft': {}, 'map': {}, 'cmd': {} }
                            
    1              0.000003   if exists('g:did_load_filetypes')
    1   0.015153   0.014483     filetype off
    1              0.000002   endif
   13              0.000017   for name in g:plugs_order
   12              0.000026     if !has_key(g:plugs, name)
                                  continue
                                endif
   12              0.000022     let plug = g:plugs[name]
   12              0.000049     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
   11              0.000020       let s:loaded[name] = 1
   11              0.000010       continue
                                endif
                            
    1              0.000004     if has_key(plug, 'on')
    1              0.000043       let s:triggers[name] = { 'map': [], 'cmd': [] }
    2   0.000240   0.000231       for cmd in s:to_a(plug.on)
    1              0.000006         if cmd =~? '^<Plug>.\+'
                                      if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))
                                        call s:assoc(lod.map, cmd, name)
                                      endif
                                      call add(s:triggers[name].map, cmd)
                                    elseif cmd =~# '^[A-Z]'
    1              0.000008           let cmd = substitute(cmd, '!*$', '', '')
    1              0.000005           if exists(':'.cmd) != 2
    1   0.000016   0.000009             call s:assoc(lod.cmd, cmd, name)
    1              0.000001           endif
    1              0.000003           call add(s:triggers[name].cmd, cmd)
    1              0.000001         else
                                      call s:err('Invalid `on` option: '.cmd. '. Should start with an uppercase letter or `<Plug>`.')
                                    endif
    1              0.000001       endfor
    1              0.000001     endif
                            
    1              0.000003     if has_key(plug, 'for')
                                  let types = s:to_a(plug.for)
                                  if !empty(types)
                                    augroup filetypedetect
                                    call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')
                                    augroup END
                                  endif
                                  for type in types
                                    call s:assoc(lod.ft, type, name)
                                  endfor
                                endif
    1              0.000001   endfor
                            
    2              0.000005   for [cmd, names] in items(lod.cmd)
    1              0.000031     execute printf( 'command! -nargs=* -range -bang -complete=file %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)', cmd, string(cmd), string(names))
    1              0.000001   endfor
                            
    1              0.000002   for [map, names] in items(lod.map)
                                for [mode, map_prefix, key_prefix] in [['i', '<C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]
                                  execute printf( '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, %s, "%s")<CR>', mode, map, map_prefix, string(map), string(names), mode != 'i', key_prefix)
                                endfor
                              endfor
                            
    1              0.000002   for [ft, names] in items(lod.ft)
                                augroup PlugLOD
                                  execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)', ft, string(ft), string(names))
                                augroup END
                              endfor
                            
    1   0.016353   0.000010   call s:reorg_rtp()
    1   0.107847   0.050044   filetype plugin indent on
    1              0.000009   if has('vim_starting')
    1              0.000005     if has('syntax') && !exists('g:syntax_on')
                                  syntax enable
                                end
    1              0.000001   else
                                call s:reload_plugins()
                              endif

FUNCTION  lightline#statusline()
Called 1 time
Total time:   0.001677
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000005   if a:inactive && !has_key(s:highlight, 'inactive')
                                call lightline#highlight('inactive')
                              endif
    1   0.001666   0.000015   return s:line(0, a:inactive)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1   0.140071   0.065239  plug#end()
    1   0.016343   0.016148  <SNR>9_reorg_rtp()
    1   0.010120   0.000129  lightline#update()
    1   0.006394   0.001149  lightline#colorscheme()
   93   0.005317             <SNR>13_HL()
    1   0.001920   0.001771  lightline#init()
    1   0.001890   0.001850  lightline#highlight()
    1   0.001677   0.000026  lightline#statusline()
    1   0.001651   0.000743  <SNR>36_line()
   12   0.001393   0.000558  plug#()
    1   0.001237   0.000158  AutoPairsTryInit()
    1   0.001103             lightline#colorscheme#flatten()
    1   0.001079   0.000729  AutoPairsInit()
    1   0.000979             lightline#link()
   12   0.000653   0.000444  <SNR>9_infer_properties()
    2   0.000593   0.000367  <SNR>36_expand()
    9   0.000350             AutoPairsMap()
    5   0.000315             <SNR>36_subseparator()
   24   0.000250             <SNR>9_dirpath()
    1   0.000224   0.000105  plug#begin()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    1   0.140071   0.065239  plug#end()
    1   0.016343   0.016148  <SNR>9_reorg_rtp()
   93              0.005317  <SNR>13_HL()
    1   0.001890   0.001850  lightline#highlight()
    1   0.001920   0.001771  lightline#init()
    1   0.006394   0.001149  lightline#colorscheme()
    1              0.001103  lightline#colorscheme#flatten()
    1              0.000979  lightline#link()
    1   0.001651   0.000743  <SNR>36_line()
    1   0.001079   0.000729  AutoPairsInit()
   12   0.001393   0.000558  plug#()
   12   0.000653   0.000444  <SNR>9_infer_properties()
    2   0.000593   0.000367  <SNR>36_expand()
    9              0.000350  AutoPairsMap()
    5              0.000315  <SNR>36_subseparator()
   24              0.000250  <SNR>9_dirpath()
   10              0.000164  <SNR>38_getGruvColor()
    1   0.001237   0.000158  AutoPairsTryInit()
   10              0.000146  <SNR>36_convert()
    1   0.010120   0.000129  lightline#update()

